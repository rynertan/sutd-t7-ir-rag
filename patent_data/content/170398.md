# PROGRAMME SCANNER FOR A PROCESSOR HAVING PLURAL DATA AND INSTRUCTION STREAMS

## Claims
Datenprozessor mit mehreren internen Daten und Befehlsströmen, um gleichzeitig verschiedene Einheiten darin als Antwort auf einen sequentiellen String eines Object Codes zu aktivieren, und mit einem Programmabtaster 10 , der den String des Object Codes abtastet und geeignete Silben für eine Übermittlung an verschiedene Einheiten gruppiert, wobei der Programmabtaster ein Eingangsregister 23 mit mehreren Object Code Silbenpositionen, um einen Abschnitt des Strings des Object Codes zu empfangen mehrere Ausgangsregister 27 bis 33 , deren Ausgänge als Eingänge an die verschiedenen Einheiten des Prozessors geschaltet sind und ein Abtastlogik und Schaltnetzwerk 24a, 24b zur Übermittlung von Silben des Eingangsregisters und von entsprechenden Codesignalen an verschiedene Ausgangsregister aufweist wobei das Netzwerk mehrere adressierbare Speichermittel 40a bis 40f enthält, und zwar eines für jede Silbenposition im Eingangsregister, wobei die Speichermittel angeschlossen sind an und adressiert werden von den entsprechenden Silbenpositionen, wobei das Netzwerk ebenfalls Multiplexermittel 41a bis 41f, 42 enthält, an die die Ausgänge der entsprechenden Speichermittel angeschlossen sind, um anzuzeigen, welche der Silben und entsprechenden Codesignale an unterschiedliche Ausgangsregister übermittelt werden sollen, wobei das Netzwerk außerdem Schaltmittel 24b enthält, die zur gleichzeitigen Übermittlung der Silben und entsprechenden Codesignale an verschiedene Ausgangsregister vorgesehen sind.

## Description
This invention relates to a stored logic program scanner for a general purpose data processor and more particularly to such a processor having plural data and instruction streams. Prior art data processors have in general been sequential in nature due to the sequential nature of conventional imperative code they employ. A particular processor module of this type is disclosed in the Barton, et al. U. S. Patent nos. 3,461,434, 3,546,677 and 3,548,384. These patents are directed toward a stack oriented data processor where the function of the stack mechanism, a first in last out mechanism is to handle the flow of operators and associated parameters in a manner which reflects on the nested structure of particular higher level languages. However, where it is desired to provide the customer with an upgrade to such a processor, it becomes necessary to increase the throughput of the processor while maintaining program compatibility with previous and smaller members of the same processing family. The execution of a sequence of code involves three basic forms of processing the processing of the instruction format, the processing of the references created by that instruction and the execution of the function specified by the instruction. In a simple sequential machine the total time to execute a sequence Si, Si ... Sn is Io Ro Eo Ii Ri Ei ... In Rn En where I is an instruction processing, R is a reference processing and E is an execution processing. In a simple pipeline machine, ignoring certain dependencies, the same sequence can be executed in a time equal to the largest sum of a processing stage, namely Io Ii ... In and so forth where the individual intruction processing, reference processing and execution processing are done in parallel. However, sequential object code as received from a higher level language compiler does not always contain the proper sequencing of code for easy segregation to be sent to various units of such a parallel processor for execution. Thus, a program scanner is provided to scan the incoming code and determine what segments of the code can be grouped together for transmission to various units of the processor. It is then an object of the present invention to provide an improved program scanner for a multiple instruction and data stream processor. It is another object of the present invention to provide an improved program scanner which scans the incoming code and groups appropriate syllables be they instructions, references to data or literal values for transmission on to various units of the processor. It is still a further object of the present invention to provide such a program scanner employing stored logic as required to provide easy expansion of the scanner s functions to recognize new groups that might be added to the object code set of instructions. A data processor according to the invention is set out in claim 1. The above and other objects, advantages and features of the present invention will become more readily apparent from a review of the following specification when taken in conjunction with the drawings wherein A general purpose processor employing the present invention is illustrated in FIG. 1. This processor includes a program scanner or program control unit 10 which is the subject of the present application and which receives strings of code from memory 16 by way of memory addressing unit 15 and supplies operators and parameters to execution unit 11, reference unit 13 and write unit 14 and also data or literal values to central data buffer 12 which in turn can be accessed by both execution unit 11 and reference unit 13. As illustrated in FIG. 1, execution unit 11 receives operators and parameters by way of execution unit queue 11a for subsequent execution in the order in which they are received. Similarly, reference unit 13 is also provided with a reference unit queue 13a to receive address couples, operators and parameters. It is the function of the program scanner 10 of the present invention to supply these operators and parameters to the other units in parallel and to keep the units respective queues filled so that those units can be operating concurrently. FIG. 2 is a diagram illustrating the general organization of the program scanner of the present invention. As shown therein, code is received from memory 16 of FIG. 1 by way of memory address unit 15 and stored in cache memory 20 of FIG. 2. In the present invention, words are formed from the code, which words are 48 bits in width or six 8 bit syllables in width. Word window selector 21 receives two such words from cache 20 under control of program counter 25 as will be more fully described below. Six of these syllables are then selected by word window selector 21 for transmission to barrel shifter 22 which shifts those syllables left according to the shift amount value received from the scanner multiplexor structure 24a and b. The six 8 bit syllables from barrel shifter 22 are then transmitted to scan register 23 where they are scanned in parallel by scanner logic 24a to determine if there is an appropriate grouping of syllables for further transmission to other units of the processor. Depending upon the acceptable groups of syllables determined by scanner logic 24a, the appropriate syllables are then transmitted simultaneously by switch network 24b to the scanner output registers 27, ..., 33. Depending upon the number of syllables that were transmitted from the scanner register 23 to the output registers, the shift amount is determined and sent to barrel shifter 22, as explained above to specify number of syllables necessary to refill scan register 23. The shift amount value is added to the contents of program counter 25 to notify word window selector which additional syllables are to be sent to scan register 23. The contents of the output registers 27, ..., 33 supply their contents to other units of the processor. In certain cases, instruction operators may address a control store not shown and in turn supply micro operators to the appropriate unit. However, that is outside the scope of the present invention. These output registers are POS register 27 which can contain a literal, value call or memory address operator. POM register 28 contains a microcode as a terminal operator as will be more fully described below. Registers POL 29 and POAC 30, respectively, contain a code literal and an address couple. POP register 31 contains a stack parameter which along with POS register 27 controls the top of stack which resides in central data buffer 12 of FIG. 1. POLT register 32 contains a type code which differentiates the formats of the lateral values contained in POL register 29. In regard to the relation between the various output registers of FIG. 2 and the other units of FIG. 1, the operator registers 27 29 and 31 32 are coupled to execution unit 11 of FIG. 1. Registers 27 28 and 30 32 are coupled to reference unit 13, and the registers 29 and 32 are coupled to central data buffer 12 of FIG. 1. The scanner of FIG. 2 has potential of recognizing groups of up to three operators through the use of the scanner logic 24a of FIG. 2. It may extend from the current head of the code stream down through the next two adjacent operators. The code stream head is referred to as the root operator and is located in syllable 0 of scan register 23. As the code stream is scanned for operators or operator groups, the scan register is updated by the number of syllables as the operator or operator groups extracted therefrom, as was indicated above. The scanner is designed to group only the most highly used and therefore most performance oriented operator groups. as is well known, an operator is the part of an instruction which indicates the operation to be performed thereby . The algorithm employed by scanner logic 24a is dependent on the code stream head or root, i.e., the next syllable or instruction in the code stream which is the occupant of syllable 0 of scan register 23 in FIG. 2. Consider that OP1 is the root instruction and OP2 and OP3 are the next two subsequent instructions. The scanning algorithm or decision tree is as described below, where the term terminal or terminates is used to describe when the instruction scanning stops and the term extends is employed to indicate the transfer of control to the next instruction respectively. The result of this scanning algorithm drives the various elements of the scanner of FIG. 2 such as the scan register shift, instruction selection and so forth. The entire implementation must account for the fact that the machine codes for OP1 and OP2 may vary in size from 1 to 3 bytes. This complication is resolved by implementing other paths in the decision tree for all possible length combinations. The first level decision then selects the proper path for its size. The various decision levels will be more thoroughly described below. FIG. 3 is a schematic diagram of the scanner logic 24a of FIG. 2. As shown therein, scan register 23 is a shift register and has six syllable positions 23a, ..., 23f, each of which is an eight bit register. The contents of these positions are used to address stored logic units or rams 40a, ..., 40f, the contents of which implement the scanning algorithm or decision tree that was discussed above. As was indicated before, syllable 0 is the root code that initiates the scanning algorithm and, thus, the contents from ram 40a indicate and thus select the various types of eight basic roots that are being implemented by the scanning algorithm and also selects routing of the contents of the respective rams by way of multiplexors 41a, ..., d to output multiplexor 42. As shown in FIG. 3, the output control signals from multiplexor 42 are selected by a 3 bit set of control signals from ram 40a that in turn is accessed by syllable 0 in scan register position 23a. In a similar fashion, the outputs to multiplexor 42 from multiplexor 41a are selected by a 2 bit set of control signals from ram 40b, the output of multiplexor 41b is selected by a 2 bit set of control signals from ram 40c, the output of multiplexor 41c is selected by a 2 bit set of control signals which are also from ram 40c, and the output of multiplexor 41d is selected by a 2 bit set of control signals from ram 40d. Before describing the operation of the scanner logic of FIG. 3, a more detailed explanation will be given of the various root operators and their effect on the selection of various syllables from register 23 of FIG. 2 to the respective output registers of the program scanner of FIG. 2 by way of switching network 24b of that figure. Apart from normal well known operators such as LOAD , which is self explanatory, the operator set employed in the present invention can be broken down into eight basic groups the variant operator VARI or supplement to the standard primary operators, the duplicate operator DUPL which duplicates the top of stack item in central data buffer 12 of FIG. 1, name call operator NAMC which places an indirect memory address on the stack, the value call operator VALC which fetches an operand from memory and places it on the top of stack, a 16 bit literal value LT16 , and 8 bit literal value LT8 , ZERO ONE, and ELSE none of the above . The VARI root allows no operators to be grouped or adjoined to it. This root merely transfers control of the scanner logic from the SCAN 0 control store table in ram 40a of FIG. 3 to the SCAN V VARI table in ram 40b. Also, the ELSE root allows no operators to be adjoined to it. All but the VARI and the remaining six roots belong to the ELSE class of operators. No significant cost effective advantage has been determined in allowing grouping of ELSE class of operators at the program scanner level. When a root operator is extracted and emitted by the scanner logic switch network 24a and b of FIG. 2 with no adjoining operators, this is referred to as a terminal root. This implies that the scanning algorithm or decision tree is terminated by that root itself. There are two cases which are termed terminal root. One is where the operator is of the ELSE or VARI type. These cases are explicit terminal roots by definition. The other case is where a root, capable of being grouped with other operators, fails to be adjoined due to the scanning algorithm i. e. decision tree s result . This is the case where the root fails to be terminated by a member of its terminal operator set. Therefore, it is extracted and emitted from the scanner as an implicit terminal root. When a root operator and one adjoined operator are extracted and emitted from the scanner, this grouping is referred to as a simple sequence or simply a sequence. The second operator in the grouping is referred to as the terminal operator for the root. When the root operator and two adjoining operators are extracted and emitted from the scanner, this is referred to as an extended sequence, or simply an extension. The second operator of the group is referred to as the extension operator for the root. The third operator is referred to as a terminal operator for the extension. Having described the various basic root operators, a description will now be given of various examples of such operators and how they are implemented by the scanner logic of FIG. 3. Consider the case of a duplicate operator, DUPL, adjoined by a terminal operator such as LOAD. The duplicate operator will reside in syllable 0 and the LOAD operator in syllable 1 of FIG. 3. The output from ram 40a, addressed by syllable 0, will select DUPL input from ram 40b, which output is a set of control signals that will be passed on to switching network 24b of FIG. 2 by multiplexor 42 of the FIG. 3. Similarly, when the root is NAMC followed by a terminal operator, that terminal operator will reside in syllable 2, the 3 bit output from ram 40a will select the NAMC input of multiplexor 42 for receiving the output of ram 40c accessed by syllable 2. In that case, syllable 1 will contain data that is to be transferred to the output registers of FIG. 2 for storage in the stack. This is how an operator sequence is formed. For the example of VALC as syllable 0, VALC address parameter as syllable 1, LT8 as syllable 2, literal data as syllable 3 and the divide operator DIVD as syllable 4. The divide operator is a terminal operator. In this situation, the 3 bit set of control signals from ram 40a will cause multiplexor 42 to select the VALC input to multiplexor 42 from multiplexor 41c, the input of which is selected by the 2 bit set of control signals received from ram 40c. The input to multiplexor 41c is received from ram 40e. This is how an extension is formed. Similar examples can be given illustrating the operation of the other multiplexor and rams but it is believed that the above description is sufficient to describe the nature of these operations. A summary of the outputs of the program control unit of the scanner of the present invention is illustrated in FIG. 5. The size of the various rams 40a, ..., 40f, of FIG. 3 will now be described so as to provide a more detailed description of that figure. In addition to the 3 bit set of control signals from ram 40a to multiplexor 42, 45 bits are supplied in parallel to the ELSE input of multiplexor 42. Ram 40b supplies a 15 bit input to the VARI input of multiplexor 42 and also outputs 12 bits to both multiplexors 41a and 42, including the 2 bit set of control signals to multiplexor 41a. Ram 40c outputs 15 bits, including the 2 bit set of control signals to multiplexor 41b and a 2 bit set of control signals to multiplexor 41c. Ram 40d outputs 11 bit signals, including the 2 bit set of control signals to multiplexor 41d. Ram 40e outputs an 8 bit set of signals, as does ram 40f. The output of multiplexor 42 to the rest of the program s scanner is 36 bits wide and includes the following a 3 bit shift amount value to barrel shifter 22 of FIG. 2 a 3 bit window select value to word window selector 21 of FIG. 2 a 2 bit source select value for the input to POAC output register 30 of FIG. 2 a 2 bit source select value for input to POL register 29 a 3 bit signal indicating the code type of the contents of POL register 29 a 2 bit code type of the contents of POAC register 30 an 11 bit next source select for POM register 28 a 6 bit next source select for POP register 31 and a 4 bit next source select signal for POS register 27. The scanning algorithm or decision tree implemented by the scanner logic of FIG. 3 may be better understood from a review of FIG. 4 which is an illustration of the scanner decision tree. As shown therein, all operations of the scanner logic are initiated by the root operator in syllable 0 and its corresponding control signals in ram 40a of FIG. 3. If that root is ELSE or VARI, that root is a terminal root and only the terminal root is emitted. If the root operator is DUPL, then syllable 1 of scan register 23 is examined by ram 40b which outputs the appropriate control signals. If the root operator is NAMC, syllable 2 is examined by its corresponding ram 40c of FIG. 3. If the root operator is VALC, then syllable 2 is examined by ram 40c which in turn selects outputs from ram 40d as output signals when the extension operator is ZERO ONE or selects the output of ram 40e as the control signals if the extension operator is LT8 and selects the output of ram 40f as the control signals if the extension operator is LT16. The remaining portions of the decision tree function in a similar manner and are believed to be evident from FIG. 4.