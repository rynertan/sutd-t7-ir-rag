# BLOCK PROCESSING APPARATUS

## Claims
Anlage zum Bestimmen einer Anordnung einer Abfolge von gedruckten derart in Zeichenblöcken anzuordnenden Zeichen, daß ein erster Zeichenblock in einer ersten Richtung an einen zweiten Zeichenblock angrenzen kann, wobei die Zeichenblöcke in der ersten Richtung definierte Abmessungen aufweisen und die Anlage eine Speichereinrichtung zum Speichern von Zeichenkodes, die den gedruckten Zeichen entsprechen, sowie eine Verarbeitungseinrichtung zum Festlegen der Anordnung umfaßt, gekennzeichnet durch eine Programmeinrichtung, die in der Lage ist, wenn eine erste Sorte eines Blockmarkierungskodes o und eine zweite Sorte eines Blockmarkierungskodes in einer Speichereinrichtung gespeichert sind, a die Verarbeitungseinrichtung zu veranlassen, Zeichen entsprechend einer ersten Sorte eines Blockmarkierungskodes o zu Zeichenblöcken, die voneinander in der ersten Richtung beabstandet sind, unabhängig von den bestimmten Ausmaßen der Zeichenblöcke zuzuordnen, b die Verarbeitungseinrichtung zu veranlassen, Zeichenblöcke entsprechend einer zweiten Sorte eines Blockmarkierungskodes zu Zeichenblockgruppen zuzuordnen, die voneinander in einer zweiten Richtung beabstandet sind, und c die Verarbeitungseinrichtung zu veranlassen, die Anordnung der Zeichen innerhalb der Zeichenblöcke unter Berücksichtigung der bestimmten Ausmaße zu bestimmen.

## Description
The present invention relates to a block processing apparatus for generating a block from a single serial character array. In a document composing apparatus with a one line display, according to proposals known to the applicant, a document is paragraphed in a block format or is ruled, using the following techniques In technique A , when document editing e.g., instertion, deletion or the like is performed, the block is broken. Editing must be performed again in accordance with the block format. In technique B , when editing e.g., insertion, deletion or the like is performed, block sizes become non uniform. In some cases, characters extend outside their corresponding blocks, and blocking must be performed again. The following techniques are used to compose a paragraphed block document from a one line serial character string. In technique A , when the document is edited e.g., using insertion or deletion , document data differing from frame data is updated, and characters can be written over. In technique B , m blocks are aligned along the vertical direction, and n blocks are aligned along the horizontal direction. The position of the boundary between adjacent horizontal blocks is given. The head lines of the respective blocks are set to start from the next line of the block immediately above. With this arrangement, even if the document is edited e.g., using insertion or deletion , block framing can be easily performed. However, two adjacent horizontal blocks cannot be combined to constitute a single block. In a paragraphed block document using character data, the following block width change techniques are known to the applicant. One technique consists of changing the number of characters per line in each block. Another technique uses a specific function code for characters in each block to change the block width. However, these techniques require cumbersome and time consuming operations and make the block format difficult to grasp. The applicant knows of a column editing apparatus which divides a character array stored in a one line memory and edits it into two vertical or horizontal columns. However, when two vertical columns are further edited to obtain two horizontal columns i.e., a total of four columns and vice versa, the number of characters in each block to be edited or the number of lines per block must be preset. There are two types of ruled line processing apparatuses known to the applicant in the first, a ruled line pattern is directly entered and in the second, a mark representing a ruled line pattern is inserted as a function between the characters, the ruled line pattern is generated, and the mark is converted to the ruled line pattern. In the latter apparatus, either With technique 1 , only one type of mark is required, but the number of marks inserted in the document is equal to the number of ruled line patterns. In technique 2 , only one mark is required for any number of identical ruled line patterns, but the number of different types of marks must be the same as the number of different ruled line patterns. In ruled line block processing apparatuses known to the applicant for dividing a single display document into sections to obtain a block document and drawing ruled lines between the blocks, two techniques are used. In the first, the ruled line frame and the document character array are separately controlled. in the second, the ruled line code itself is treated as a character in the document. When the length of the character array is changed by editing such as insertion or deletion, the ruled line position must be updated. In ruled line processing apparatuses known to the applicant for surrounding characters with ruled lines, the following techniques are used With the above techniques, the operator must be able to predict the ruled line patterns. For example, when a single serial character array is edited into a block document which is then to be surrounded by ruled lines, it is easy to enter breakpoint marks but difficult to predict the ruled line patterns. As a result, ruled line pattern input is very difficult. In an apparatus known to the applicant for composing a document using a one line display, when a document is blocked and the blocks are surrounded by ruled lines, either a ruled line is drawn at a boundary between the blocks, or ruled line codes are entered as characters while the document is being input. The techniques described above, however, are cumbersome and time consuming. The document must be composed in consideration of the block format, so the operator cannot concentrate on document composition. In ruled line document processing apparatuses known to the applicant, the ruled line frame and the document character array are separately controlled. The ruled line codes are entered as characters in the document. For this reason, when the vertical ruled line positions are changed to recreate a new document format, the ruled line frame must be separately changed, and the character blocks are then fitted in the blocks of the new frame. Alternatively, the ruled line codes are relocated in other positions between adjacent characters to create a new document format, thus making operation troublesome and time consuming. An apparatus is known from EP A 0075731 in which a layout for a series of printed characters to be laid out in columns may be determined on a screen. The width of each column is entered, and the entries for the columns are entered and aligned in their respective columns. The table thus formed may be stored and recalled, and the column widths may be varied. According to the present invention, there is provided an apparatus as set out in claim 1 and a method as set out in claim 12. This allows the allocation of characters between blocks displaced in the first direction and the allocation of blocks between groups displaced in the second direction to be determined in accordance with respective block marker codes. Preferably the apparatus has the features of claims 2 to 4. In the preferred embodiment, the apparatus has the features of claim 5. Because the ruled lines border lines are specified by the block marker codes, an embodiment can be provided in which the ruled line positions do not need to be updated separately from the block markers when character array is amended. Also, since the second type of block marker code specifies the presence of two border lines extending in the second direction as well as specifying a boundary in the second direction, the number of different types of code specifying a line may be kept small while the number of codes inserted in the document is less than the number of ruled or border lines. Preferably the apparatus also has the features of claims 6 and 7. In the preferred embodiment, the apparatus has the features of claim 8. Because the block marker codes and the block extent codes are separate, an embodiment can be provided in which the block extents or the number of characters in a block can be varied without resulting in an incorrect arrangement of characters in a block such as an overflow beyond the boundary of a block, and without incorrectly overwriting previously existing characters for the block. Preferably the apparatus also has the features of claims 9 to 11. When the feature of claim 2 is present, the blocks have specified extents in the first direction, and yet a particular block may extend in the first direction more than the extent specified for a single block. For example, the specified extents for two blocks adjacent in the first direction can be combined to constitute the extent for one block. When the feature of claim 3 is present, essentially only two types of block marker code first and second types are needed to divide a character document into vertical and horizontal columns. An embodiment may be provided in which the two types of marks are used in a character array in a memory and have vertical and horizontal column editing functions, respectively, and vertical horizontal column editing with a priority order for setting column order priority vertical over horizontal or vice versa is provided. An embodiment of the present invention may be provided in which a ruled line position always corresponds to the boundary of the blocks in accordance with the lengths of the block lines, even when a one line display document is edited e.g. using insertion or deletion to create a block document. An embodiment of the present invention will be described with reference to the accompanying drawings. The principle of the present embodiment is illustrated in Fig. 1. A serial character array is stored in a memory. Vertical and horizontal division marks are entered in the serial character array. The character array in the memory is converted by a block forming means to a block document. The marks are set at three positions. The first mark indicates the start of the block and represents a horizontal ruled line at the upper edge. The second mark indicates a horizontal ruled line when the large block is further divided into small vertical blocks. The last mark indicates the end of the large block. Each mark represents a vertical ruled line corresponding to an outermost tab position. The mark o indicates that the large block is further divided into small horizontal blocks. Furthermore, the boundary line positions of the ruled line blocks correspond to tab positions excluding the outermost tab positions and are sequentially set as vertical ruled lines. In Fig. 5B, two of the marks o are successively inserted between the characters and A . This indicates that the second block is to be omitted and combined and absorbed in the third block. As shown in Fig. 5C, no vertical ruled line is inserted at the third tab position, and the small block character array ABCDE is printed accordingly. The print positions of the horizontal ruled lines excluding the head line are next to the longest small block included in the large block surrounded by the marks . As shown in Fig. 5D, when the second tab position is shifted one position to the left and is set, the first large block is enlarged by one line from two to three lines. The second horizontal ruled line position is automatically moved downward. The second large block requires only two lines, so the last horizontal ruled line is moved upward by one line. An embodiment of the present invention will be described in detail with reference to the accompanying drawings. Fig. 2 is a block diagram of a character processing apparatus according to an embodiment of the present invention. A CPU Central Processing Unit executes the contents of the program memory contained in a ROM Read Only Memory and controls the respective components connected thereto via a bus line. The ROM is the program memory and stores the program whose steps are shown in the accompanying drawings. A bus line BL is connected to the respective components of the character processing apparatus. A keyboard KB is connected to the bus line BL, and key character data entered at the keyboard KB is supplied to and stored in a document memory BSM, which is part of a RAM Random Access Memory , through the bus line BL. The keyboard KB has character keys CRK, a block identification key, a control key and the like. The memory RAM stores character data and displays it on a display LCD Liquid Crystal Display . Fonts corresponding to the character codes are read out from a character generator CG controlled by an LCD controller LCONT and supplied to and displayed on the display LCD through the bus line BL under the control of the CPU. In addition to the document memory BSM, the memory RAM has areas of a block memory BRM for forming blocks, a tab memory TBM for storing tab position data, a vertical ruled line table TKT representing vertical ruled line positions of each divided block, a small block range table SHT representing head and end positions of small blocks to be described later , a number LNO of horizontal ruled lines No., a number DS of large blocks, and a number SS of small blocks RZF and MJF flags required for program execution and temporary memory areas such as CRGM and CRLM for storing printer carriage position and cursor position. The printer is a device for printing the contents of the block memory under the control of the CPU. Fig. 3 is an enlarged view of the keyboard KB in Fig. 2. The character keys CRK are used to enter characters. A character code corresponding to a depressed character key is stored in the document memory and displayed on the display LCD. The keyboard KB includes a keys BDK1 and BDK2 to be described later for entering marks and o for dividing identifying the blocks. Cursor left and right shift keys CRLK and CRRK shift the cursor representing the character position on the display to the left and right, respectively. Carriage left and right shift keys CRGLK and CRGRK shift the printer carriage to the left and right, respectively. A tab set key TABK sets a tab at a position corresponding to the carriage position. A tab reset key TABRK resets the tab. A ruled line block key KBEK creates a ruled line block from a serial character array. Figs. 4A to 4E show formats of the document memory BSM, the block memory BRM, the tab memory TBM, the vertical ruled line table TKT and the small block range table SHT in the RAM. The document memory BSM serially stores the character data from the start address to the end address. The serial character data is represented by BSM i , BSM 1 , BSM 2 , ... . The block memory BRM has a matrix structure in which data represented by BRM x,y BRM 1,1 , BRM 1,2 , ... is addressed from the head line. The tab memory TBM stores set tab position data in the order of addresses. The tab position data is represented by TBM j TBM 1 , TBM 2 , ... . The vertical ruled line table TKT gives tab positions for each large block to be described later , where the tab position data is represented by TKT p,q TKT 1,1 , TKT 1,2 , ... . The small block range table SHT stores data consisting of the head and end lines and indicating which memory block area is a destination for each small block to be transferred thereto. The data in the small block range table SHT is represented by SHT m,1 , SHT m,2 SHT 1,1 , SHT 1,2 , SHT 2,1 , ... . A printer P prints data read out from the RAM. The operation of the embodiment described above according to the present invention will be described with reference to the flow charts in Figs. 6 to 10 and the memory contents in Figs. 11A to 11E and Figs. 12A to 12E. When the power switch of the document processing apparatus is turned on, step s1 in Fig. 6 is executed. In step s1, the document memory BSM, the block memory BRM, the tab memory TBM and the vertical line table TKT in the RAM are cleared. The carriage is set in the home position. The cursor is set at the start address of the document memory BSM. The carriage position memory CRGM and the cursor position memory CRLM are initialized. The flow then advances to step s2, and the CPU awaits key input at the keyboard KB in Fig. 3. When the operator depresses a key, the flow advances to step s3 to determine which key was depressed. The flow advances one of steps s4 to s9 in accordance with the determination result in step s3. Step s4 is executed when the operator depresses one of the character keys CRK. When one of the keys CRK is depressed, a corresponding character code is stored in an area of the document memory BSM which corresponds to the cursor position memory CRLM. The cursor position is then incremented by one, and at the same time the address of the cursor position memory CRLM is incremented by one. Step s5 is executed when the operator depresses the carraige right or left shift key CRGRK or CRGLK. For example, if the operator depresses the carraige left shift key CRGLK, the printer carriage is shifted one character position to the left, and at the same time the content of the carriage position memory CRGM is decremented by one. However, if the operator depresses the carraige right shift key CRGRK, the printer carriage is shifted one character position to the right, and at the same time the content of the carraige position memory CRGM is incremented by one. Step s6 is executed when the operator depresses the cursor right or left key CRRK or CRLK. For example, if the operator depresses the cursor left shift key CRLK, the address of the cursor position memory CRLM is decremented by one. However, if the operator depresses the cursor right shift key, the address of the cursor position memory CRLM is incremented by one. Tab set processing is performed in step s7. The content of the carriage position memory CRGM is set in an empty area of the tab memory TBM in Fig. 4. The tab positions are stored in ascending order. The carriage position upon carraige shift is always stored in the carriage position memory CRGM, so that the tab is set at the actual carriage position. Tab reset processing is performed in step s8. By referring to the content of the carriage position memory CRGM, if identical tab positions are present among the tab positions stored in the tab memory TBM in Fig. 4, the contents of the identical tab positions are cleared, and the lower address content is moved up one address. Therefore, the tab memory always stores carriage positions in ascending order. In step s9, the content of the document memory BSM in Fig. 4 is used to create a ruled line block document while the content of the tab memory TBM is being retrieved, and the processed result is stored in the block memory BRM. Print processing is performed in step s10. A detailed description of step s9 is made in Fig. 7. Referring to Fig. 7, in step s9.1, the number of large blocks is calculated in accordance with the number of marks in the document memory. the number of large blocks is set as the number DS in the RAM area. In step s9.2, the positions of the vertical ruled lines for the large blocks are calculated to create the vertical ruled line table TKT. This processing will be described in detail with reference to Fig. 8. In step s9.2.1, pointers and a flag are initialized. A flag RZF is used to check the continuous state of the marks and o and is initially set at logic 0 . Pointers is represented by a 6. As shown in Fig. 11C, 6 is transferred to the first large block. When the transfer is completed, the pointer When the CPU determines in step s9.2.5 that the flag RZF is set at logic 1 , the immediately preceding character indicates the mark or o and the flow advances to step s9.2.7. When the above marks are continuous, the vertical ruled line is omitted, and thus the pointer In this case, the vertical ruled line corresponding to the second mark position is omitted. As shown in Fig. 11C, 9 is not included in the first block. Thereafter, the flow returns to step s9.2.2. When the CPU determines in step s9.2.3 that the character in the document memory BSM is the mark , the flow advances to step s9.2.8. The flag RZF is set at logic 1 , and the content of the tab memory TBM is transferred to the vertical ruled line table TKT. The horizontal pointer of the vertical ruled line table TKT is incremented by one. The flow advances to step s9.2.9, and the pointer The operations between steps s9.2.8 and s9.2.11 indicate that tab positions are set in a double vertical ruled line table TKT for causing one mark to set two vertical ruled lines at the end tab position of a given block and the head tab position of the next block. In this manner, the vertical ruled line table TKT shown in Fig. 11C is obtained. Referring back to Fig. 7, in step s9.3, the vertical pointer The flow advances to step s9.4, and the number of small blocks within one large block is determined. The calculated number is set as the number SS in the RAM area. In step s9.5, each small block range is calculated in accordance with the vertical ruled line table TKT. In the case of Fig. 11C, the first large block has three vertical ruled line positions 1, 6, 12 , so that there are two small blocks therein. The small blocks fall within the ranges between 2 and 5 and between 7 to 11, respectively. This is summarized in a table in Fig. 11D. In step s9.6, the one line horizontal ruled line data is set in the block memory, and at the same time, the value of the next line is set in the block line No. LNO. This operation will be described in detail with reference to Fig. 9. In step s9.6.1, in Fig. 9, the content of the block memory BRM is checked to find a blank line. The blank line number is set in the block line No. LNO. The flow advances to step s9.6.2. The horizontal ruled line marks are set from the head to the end positions of the line corresponding to the block line No. LNO. These positions are stored in the tab memory TBM. Thereafter, in step s9.6.3, the horizontal pointer In step s9.6.5, the pattern In step s9.6.7, the pattern In step s9.6.8, the pattern The character array included in the small block in the document memory is transferred together with the vertical ruled line data to the block memory BRK with reference to Fig. 10. In step s9.7.1, a character flag MJF is cleared to logic 0 . The flag MJF is set at logic 1 when even one ordinary character is entered. This flag is required to distinguish the start of the block from its end since the mark represents the start or end of the block. The value of the block line No. LNO is set in the vertical pointer of the second line is completely transferred. In this case, the flow advances to step s9.7.5, and a required number of vertical ruled lines is set for the transferred line. Thereafter, the vertical pointer However, when the CPU determines in step s9.7.4 that one line small block has not been completely transferred to the block memory BRM, the flow advances to step s9.7.6. The horizontal pointer and can be transferred, as shown in Fig. 12B. When the CPU determines in step s9.7.2 that the content of the document memory BSM represents the mark or o , the flow advances to step s9.7.7. The flow then branches in accordance with the value of the character flag MJF. When the character flag MJF is set at logic 0 , it indicates the start of a large or small block. The pointer In step s9.8, the pointer of Fig. 11 is transferred, as shown in Fig. 12C. The flow advances to step s9.10. In step s9.10, the pointer In step s9.11, calculation of number DS 1 is performed to check whether or not the character data included in all the large blocks is completely transferred. If the number of large blocks which have not been transferred is not zero, the flow returns to step s9.4, and the next large block is transferred. When a subtraction result is zero, the character data transfer of all the large blocks is complete and the flow advances to step s9.12. In step s9.12, the ruled line at the end line of the block is transferred to the block memory. The ruled line patterns are set throughout the line in the same manner as in step s9.6. The ruled line patterns When the operator depresses the print key PK after blocks are prepared as described above, the key is identified in step s10. As a result, the content of the block memory is printed at the printer. The black document is printed at the printer in the above embodiment. However, the contents of the block memory can be displayed on a display.