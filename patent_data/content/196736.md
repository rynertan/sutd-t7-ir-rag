# MICROPROGRAM CONTROLLED DATA PROCESSING APPARATUS

## Claims
Datenverarbeitungsanlage mit einer Mikroprogrammeinrichtung 20 24 zur Durchf√ºhrung von Maschinenpegelinstruktionen mit Hilfe von Mikroinstruktionsfolgen,

## Description
This invention relates to data processing apparatus in which machine level instructions are executed by sequences of microinstructions. During operation of the processing apparatus, certain exception conditions may occur, for example as the result of a program error. For example, an instruction may attempt to access a region of store which is currently forbidden or unavailable. The microprogram may be arranged to detect these exceptions and to resolve them i.e. to determine the exact cause of the exception and to initiate the appropriate corrective action or, if corrective action is not possible, at least to inform the operator of the nature of the exception . However, this tends to increase the lengths of the sequences of microinstructions and hence slows down the rate of execution of the machine level instructions. The object of the invention is to alleviate this problem. According to the invention, there is provided data processing apparatus comprising microprogram means for executing machine level instructions by means of sequences of microinstructions, characterised by mode selection means having a first state indicating a fast mode and a second state indicating a slow mode, wherein at least some of the machine level instructions have alternative fast and slow microprogram sequences which are selected according to the state of the selection means, the fast sequences being effective to detect exception conditions without resolving them, and the slow sequences being effective both to detect and to resolve exception conditions, wherein, upon detection of an exception condition during a fast sequence, the current machine level instruction is abandoned and re started with the selection means set to the second state, the selection means being reset to the first state following execution of a slow sequence. Thus, it can be seen that the invention avoids the problem referred to above by having a fast mode and a slow mode. Normally, machine level instructions are executed by the fast microprogram sequences. Because these fast sequences are not constrained by the requirement of resolving exception conditions, they can be made very short and hence very fast. When an exception condition is detected, the instruction in question is re tried using the corresponding slow microprogram sequence, which resolves the exception condition. The slower speed of this sequence does not have a significant effect on the performance of the processing apparatus, since exception conditions are, in general, a comparatively rare occurrence. Another advantage of having fast and slow modes is that the two modes in general perform the required operations by different routes, using different hardware. Thus, if an instruction fails in fast mode because of a hardware fault, it may still be able to be executed in the slow mode. This increases the resilience of the system. One data processor in accordance with the invention will now be described by way of example with reference to the accompanying drawings. Figure 1 is a block diagram of the processor. Figure 2 is a diagram of microprogram sequencing logic forming part of the processor. Figures 3 and 4 illustrate a slow microprogram sequence and the corresponding fast sequence. Figure 5 is a flow chart summarising the operation of the microprogram. Referring to Figure 1, the processor comprises a plurality of functional units including an address mill 10, a slave store 11, a shifter 12, local registers 13, a main mill 14, and a check mill 15. The address mill 10 performs arithmetic operations for generating addresses, such as adding a displacement value to a base register. The slave store 11 acts as a fast access buffer holding copies of operands, instructions and addresses currently in use by the processor. It is addressed by the output of the address mill 10. If the required data is not present in the slave store, the address which is a virtual address is translated by an address translation unit ATU 16 to form a real address. This is then applied to a main store 17 so as to fetch the desired data into the slave. If the address translation fails, because the ATU does not hold the necessary information for the translation, an interrupt signal, referred to as a virtual store interrupt VSI, may be generated and this initiates a special program to update the information held in the ATU. The combination of a slave store, main store and ATU is well known and so will not be described in further detail. The shifter 12 performs shift operations on operands and addresses, or can act merely as a buffer between the slave store and the main mill 14 and check mill 15. The local registers 13 hold various items of data, including back up copies of the contents of various registers in the processor. These can be used for restoring the processor to a consistent state where execution of an instruction has been abandoned. The main mill 14 performs the main arithmetic and logical operations for the processor, while the check mill 15 is used to perform certain operational checks to detect exception conditions. For example, the check mill can be used to test whether the address from the address mill is greater than a specified limit. The address mill, main mill, and check mill share access to a register file 18 which contains the main registers of the processor. These registers include, for example, an accumulator register ACC, a descriptor register DR, a local name base register LNB, and a stack front register SF. Operation of the processor is controlled by a microprogram store 20, having 16K 16384 individually addressable locations, each capable of holding a microinstruction. The first 4K locations are referred to as the lower microprogram store 21, and the remaining locations as the upper microprogram store 22. Each microinstruction in the lower microprogram store has an extension, held in an area referred to as the lower microprogram store extension 23. Machine level instructions in the processor are executed by sequences of microinstructions. The first microinstruction in each sequence is always in the lower microprogram store 21, and the extension of that instruction contains a jump address XA pointing to the second microinstruction in the sequence, which will normally be in the upper microprogram store 22. Addressing of the microinstructions in the upper microprogram store is sequential. The addresses for the microprogram store are generated by microprogram sequencing logic 24 which is described in more detail below with reference to Figure 2. Each microinstruction read out of the store 20 directly provides control signals A and V for the address mill and the slave store. The microinstruction is also decoded by a decoder 25 to produce control signals S, R, M and C for the shifter, local registers, main mill and check mill. The decoder 25 also produces a jump control signal J and further miscellaneous control signals not shown for setting various status registers. One of these status registers contains a mode bit, to be described below, which specifies either a fast or slow mode of operation. It will be appreciated that each of the control signals A,V,S etc. consists of a plurality of bits for specifying the operation of the functional unit in question. For example, the control signal M consists of the following control fields The jump control J consists of the following control fields A relative jump with zero address which would otherwise be meaningless is used to specify a special jump GFE go to fast error routine . The purpose of this jump will be described below. In total, there are 180 control bits forming the various control signals for the processor. These bits are compressed into a 32 bit microinstruction format by some suitable compression scheme such as that described in our co pending European Patent Application No. 85 30 0459. As a result, only 32 control bits out of 180 can be specified by a single microinstruction, the remaining bits are given a predetermined default value, e.g. zero. Thus, a given microinstruction cannot specify control signals for all the functional units, but only for a sub set of them. In particular, a long jump address field JADD occupies 28 bits of the microinstruction and this restricts the number of other control signals which can be specified by that microinstruction. In contrast, the GFE jump referred to above occupies only 4 bits, since it has a zero jump address and jump function code. The control signals A and V are applied directly to the address mill and slave store. The control signals S and R are delayed by one clock best in a pipeline register 27, and then fed to the shifter and local registers. The control signals M and C are delayed by two clock beats in pipeline registers 27 and 28, and then applied to the main and check mills. The jump control signal J passes through three pipeline registers 27,28 and 29 and hence becomes active three beats after the initial decoding of the microinstruction. Thus, it can be seen that each microinstruction is fetched and executed in a six stage pipeline structure, in six clock beats, as follows. The last microinstruction in each sequence also passes through a seventh stage, in which the values of the registers are written into a register archive. The fetching and execution of successive microinstructions are overlapped in the pipeline so that up to six microinstructions may be active in the processor at the same time. Pipelined processors are well known in the art and so it is not necessary to describe the pipeline structure in greater detail. Figure 2 shows the microprogram sequencing logic 24 in detail. This logic includes an instruction buffer 30 which holds the current machine level instruction. This instruction is decoded by a decoder circuit 31 to produce a microprogram start address pointing to a location in the lower microprogram store 21. This address is modified by a MODE bit from a mode register 32, having two values FAST and SLOW . When MODE FAST, the third most significant bit of the microprogram start address is forced to zero, so that the address is in the first 2K locations of the microprogram store. When MODE SLOW, the third bit is forced to 1, so that the address now points to the corresponding one of the next 2K locations. Thus, for any given machine level instruction, one of two alternative start addresses is produced, according to the value of the MODE bit. The sequencing logic also includes a multiplexer 33 controlled by a signal INT which indicates that an interrupt is pending. If no interrupt is pending INT 0 the multiplexer selects the start address from the decoder 31 if an interrupt is pending, it selects a fixed address INTA which points to the start of an interrupt handling routine. As shown in Figure 2, the microprogram store 20 is addressed by a 14 bit address MPA from a microprogram address register 34. At each clock beat this register is updated with a new address from a multiplexer 35. This multiplexer has eight inputs 0 7 as follows The multiplexer 35 is controlled by the output of a priority encoder circuit 39 having seven inputs 0 6, input 0 being the highest priority. It can be seen that, if one of the inputs of the encoder circuit 39 is enabled, the corresponding input of the multiplexer 35 is selected. If more than one input to the encoder circuit 39 is enabled, only the one with the higher priority is effective. If none of the inputs is enabled, the encoder circuit 39 produces the default value 7 which selects input 7 of the multiplexer 35. The inputs to the priority encoder circuit 39 are as follows. In summary, whenever a microprogram sequence finishes, the start address of the next sequence is supplied by MPSA. This will either be the start address derived from the current machine level instruction or the interrupt address INTA. In either case, the address of the second microinstruction in the sequence is supplied by XA from the lower microprogram store extension 23. This will normally point to the upper microprogram store. Addresses for subsequent microinstructions in the upper microprogram store come from the incrementer 38 and hence are sequential. When a jump instruction is obeyed, the next microinstruction is at the address specified by JADD or, in the case of a fast error jump, by FASTERR. All the above possibilities are overriden by a virtual store interrupt. It was shown above that, in general, a machine level instruction initiates one of two alternative microprogram sequences according to the state of the MODE Bit. The microprograms selected in the slow mode include tests to detect and resolve program errors or other exception conditions. The microprograms selected in the fast mode detect the exception condition but do not resolve them. As a result the fast microprogram sequences are generally considerably shorter, and hence faster, than the slow ones. For example, consider a typical machine level instruction which involves reading an operand and performing an operation on it. Figure 3 shows the slow microprogram sequence for executing this instruction, and Figure 4 shows the corresponding fast sequence. In these figures, time is represented by the vertical axis, and the pipeline stage is represented by the horizontal axis. Hence, each microinstruction is represented by a diagonal row of boxes, sloping downwards from left to right. As can be seen from Figure 3, in the slow sequence the first microinstruction specifies an address mill operation to calculate the address of the operand and a check mill operation to check the address e.g. by comparing it with the contents of the stack front register SF . The next microinstruction is an absolute jump which is obeyed if the address check fails. The third microinstruction reads the operand from the slave store and buffers it in a temporary register. The fourth microinstruction is a null i.e. it performs no operations. The fifth microinstruction in the sequence buffers the operand from the slave store into the shifter, and then performs the required operation on the operand in the main mill. The final microinstruction is another null. If the address check fails, the second microinstruction in the sequence causes a jump to another part of the sequence not shown which creates an interrupt parameter, specifying the exact nature of the error. An error handling routine is then initiated as will be described later. It can be seen that in this sequence, the main mill operation is not initiated until the second clock beat after the jump decision in the last stage of the second microinstruction . This allows enough time to prevent the main mill operation, and any main store activity resulting from the slave store action, from taking place if the jump is obeyed. Also, the next microprogram sequence indicated by the broken lines cannot start until after the jump decision has been made. Both these measures are necessary to ensure that, when an error condition is detected, it can be fully resolved. Referring now to Figure 4, the corresponding fast microprogram sequence consists of just two microinstructions. The first specifies the address mill, main mill and check mill operations, and also the fast error jump GFE. The second is a null and is included because the minimum sequence length in the processor is two beats. As mentioned above, the fast error jump GFE does not require many bits to specify it, and hence can be included in the same microinstruction as the control fields for the address mill, slave store, main mill and check mill. It can be seen that the fast sequence is much shorter and hence faster than the slow sequence. Both sequences can detect a specified program error condition e.g. address greater than stack front . The slow sequence also resolves this error by jumping to a specific sequence which forms a parameter indicating the exact nature of the error. In contrast, when the fast sequence detects an error, it simply jumps to the fast error address FASTERR which is common to all exception conditions. Thus, when the microprogram arrives at this address, it has no information about how it arrived there it could have been as the result of any of a number of exception conditions. Thus, the fast sequence cannot resolve the error and it is necessary to roll back the instruction and re try it in the slow mode, as will be described. As another example of a machine level instruction, consider the case of a floating point addition. The slow sequence for executing this instruction fetches the operands and tests them to ensure they are normalised. If they are not normalised, the sequence performs the necessary shifts to normalise them. Finally, the addition is performed. The slow sequence thus detects the exception condition un normalised operands and also resolves it by performing the normalisation . The fast sequence, on the other hand, fetches and adds the operands in parallel without testing them. Thus, it is not known until the end of the sequence whether the operands are normalised, by which time the addition has already been performed. This again causes a jump to the fast error address, and the instruction will be re tried in slow mode. Referring now to figure 5, this is a flow chart showing the overall structure of the microprogram. It is assumed that initially the mode bit is set so that MODE FAST. The execution of each machine level instruction starts at box 50. Assuming that there are no interrupts pending, this initiates the fast microprogram sequence box 51 for executing the instruction. If there are no exceptions, the instruction is executed very rapidly, and the microprogram returns to box 50, i.e. the start of the next machine level instruction. However, if an exception is detected, the microprogram jumps to the fast error address FASTERR box 52 . This sets the interrupt parameter to zero, and jumps to an error handling routine box 53 . The error handling routine is a roll back routine which restores the processor to its state at the start of the machine level instruction in question. For example, it replaces the machine registers with copies which were preserved in the local registers 13 at the beginning of the instruction. The error routine then sets the MODE bit to SLOW, and produces a delayed interrupt signal DINT. The microprogram then returns to box 50. Since the interrupt signal DINT generated at box 53 was a delayed interrupt, it is not yet effective and so the microprogram starts to execute the instruction again, using the corresponding slow sequence box 54 . The slow sequence tests for program errors. If no program errors are detected, it then executes the instruction, and returns to box 50. The delayed interrupt DINT previously generated at box 53 is now active, and causes the microprogram to jump to an interrupt routine box 55 . Since the interrupt parameter is zero, this routine simply sets the MODE bit back to FAST and returns to box 50. Operation then continues in fast mode. If, on the other hand, the slow sequence box 54 detects a program error, it creates an interrupt parameter specifying the exact nature of the error, and then jumps to the error routine box 53 . As before, this routine rolls back the instruction to its initial state. This time, since MODE SLOW, it produces a non delayed interrupt signal INT. Now, when the microprogram returns to box 50, the interrupt is active, and causes a jump to the interrupt routine box 55 . As before, the interrupt routine resets the MODE bit back to FAST. The interrupt routine then examines the interrupt parameter created by the slow sequence and performs the appropriate actions for dealing with the program error. The microprogram then returns to box 50 so as to begin the next instruction. As described above, a VSI causes the microprogram to jump immediately to the start of a VSI sequence box 56 . This creates a special VSI parameter and then jumps to the error routine box 53 which rolls back the instruction. If MODE FAST, the error routine sets the mode to SLOW, and generates a delayed interrupt DINT. The microprogram then returns to box 50. Since DINT is not yet active, no interrupt is produced, and the microprogram proceeds to retry the instruction using the corresponding SLOW sequence box 54 . The VSI will occur again during this slow sequence, when it attempts to access the operand again, causing another jump to box 56. Once again, the VSI sequence creates the VSI parameter, and jumps to the error routine, which again rolls back the instruction. This time, since MODE SLOW, the error routine produces a non delayed interrupt INT. Thus, when the microprogram returns to box 50, the interrupt is active, and causes a jump to the interrupt routine box 55 . This resets the mode to FAST, and examines the interrupt parameter to find that this is a VSI. The interrupt routine therefore takes the appropriate action to deal with the VSI i.e. loading the appropriate address translation information into the ATU , before returning to box 50. Thus, it can be seen that when a VSI is encountered in FAST Mode, it is ignored and the instruction is rolled back and tried again in SLOW mode, before attempting to handle the VSI. This avoids difficulties in handling VSI s generated in FAST mode.