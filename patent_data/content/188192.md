# EXTENDED ERROR CORRECTION FOR PACKAGE ERROR CORRECTION CODES

## Claims
Gerät zur digitalen Fehlererkennung und korrektur, umfassend

## Description
This invention relates generally to error correction. In particular, it relates to the correction of a number of hard errors beyond the unextended capability of the error correction code being used. As the size of computer memories has increased while the individual memory cells have become further miniaturized, there has resulted an unacceptable occurrence of bit errors in data stored in a memory. No longer can an occasional error be allowed to cause a program to stop operating or require replacement of a memory chip. These bit errors are of two general types, soft errors and hard errors. A soft error is a seemingly random inversion of stored data. This inversion is caused by occasional bursts of electrical noise and, in some cases, by atomic particles, the so called alpha particle upset. The soft error problem has increased as the individual cell sizes have been reduced so that noise levels represent relatively low amounts of power. A hard error, in contrast, represents a permanent electrical failure of the memory chip, often restricted to particular memory locations but also sometimes associated with peripheral circuitry of the memory chip so that the entire chip can be affected. Naturally, designers of memory chips have striven to reduce the occurrence of both hard and soft errors in their chips. However, both types of errors have not been completely eliminated and, indeed, it is not believed that they can be eliminated. Reliability beyond a certain point can be bought only at the expense of reduced performance or increased cost. An alternative to the above solution for both hard and soft errors has been the implementation of error correction codes ECC in large computer memories. The fundamentals of error detecting and correcting are described by R.W. Hamming in a technical article entitled Error Dectecting and Error Correcting Codes appearing in the Bell System Technical Journal, Vol. 26, No. 2, 1950 at pages 147 160. In one of the most popular Hamming codes, an 8 bit data word is encoded to a 13 bit word according to a selected Hamming code. A decoder can process the 13 bit word and correct any 1 bit error in the 13 bits and can detect if there are 2 bit errors. The decribed code, thus, is classified as SEC DED single error correct double error detect . The use of such codes has been particularly efficient for memory chips having single bit outputs. For instance, if a relatively simple computer were to have 16K 16,348 bytes of data where each byte contains 8 data bits, then an efficient error protected design would use thirteen 16Kx1 memory chips with the extra five 16K chips providing a Hamming SEC DED protection. The Hamming code can correct only a single random error occurring in any byte but can further correct for any one failed 16K memory chip since any one memory chip contributes only 1 bit per each error protected word. Of course, the described 13 bit Hamming code could only correct one error, whether it be a hard error or a soft error. As a result, if one memory chip has suffered a hard failure in all its locations, then the remaining chips are not protected against an occasional soft error although it could be detected but not corrected. For this and other reasons, more elaborate error correcting codes have been developed and implemented. As a general rule, the more errors that can be corrected in a word, the more extra bits, i.e., redundant bits or check bits, are required for the check code. Hamming codes and similar codes are thus useful for correcting hard errors when each bit of a data word is stored in a different memory chip. However, the trend has been toward memory chips of ever increasing density. Single memory chips having 1 megabit of capacity, or even 4 megabits, will soon become commercially available. However, many systems do not require 1 megabyte or 4 megabytes of storage. This large amount of storage would result when these larger chips are used to store only a single bit of every data word. As a result, it is anticipated that many systems will use the larger memory chips to store multiple bits of the same data word. For instance, a 1 megabit memory chip can be easily adapted to have 4 data ports, each simultaneously accessible. This chip would then be properly designated as a 256Kx4 memory. Eight of these 1 megabit chips would then provide 256K of storage for 32 bit words. Error protection will likely need to be provided for such a large memory based upon such a dense memory chip. Soft errors, of themselves, do not present much of a problem because of their random occurrence in one or a few memory locations. Hard errors, however, present a much more difficult problem for multi bit memory chips. The problem is that the hard error is often not restricted to a single bit output port but affects all the bits associated with the memory package. In the 256Kx4 package described above, this means that a hard error is likely to produce up to four simultaneous errors in the same word. Error correction codes are available for handling this large number of errors and, indeed, error correction codes can be developed for almost any number of errors in a word. However, such codes require a large number of extra bits to perform such large scale correcting. Recently, a better procedure has been developed for dealing with hard errors in multi bit packages. These errors will be referred to as package errors and the error correction codes designed specifically for package errors will be called package codes. These codes rely upon the fact that the multiple hard errors do not randomly occur across the entire field of the data word. Instead, the multiple errors are confined to a sub field of the data word, defined by the outputs of the package. In the context of the previously described example, such a code cannot correct any four errors occurring in the 32 bit word. However, the code can correct four bit errors that occur in any one of the eight 4 bit sub fields. Nonetheless, even such codes are not completely satisfactory. If the code is a SPC DPD single package correct double package detect code, then the code can correct any errors that occur in only one package and can detect, but not correct, errors occurring in two packages. Thus if one package has suffered a hard failure, the occurrence of any additional errors, either hard or soft, in the remaining packages means that the error condition can be detected but the errors cannot be corrected. Thus, the existence of one hard failure is the effective limit of correction provided by a SPC DPD code. Woo in US A 3,449,718 has proposed a novel method of correcting errors, particularly applicable to magnetic tapes. Magnetic tapes have parallel tracks with the parallel locations defining a byte. One of the tracks or parallel bits is dedicated to a check bit that records the parity of the remaining bits of the byte. The bytes are further arranged on the tape in fairly long blocks. At the end of a block, there are several additional recorded bytes that provide a block check. That is, the bits of the block check must be consistent with the previous data and check bits. The parity check bits can only detect, but not correct, a single error. In Woo s apparatus the assumption is made that all errors within a block occur in a single track, an assumption that is likely for magnetic tape recording. Woo then reads the tape with the assumption that the errors are occurring in the first track. He reads the tape, byte by byte, and checks for parity errors. If a parity error is indicated within a particular byte, the bit in the first track is inverted. Data, with possible inversions, is then subjected to comparison with the block check bits. If the initial assumption was correct, the data was corrected and the block check bits indicate correct data. However, if the initial assumption were incorrect, then the assumption is changed to one that all errors are occurring in the second track. The data is then reread from the tape with parity errors causing inversion in the second track. The process is repeated until agreement with the block check bits is obtained or until after the tape has been read with each track being separately assumed to contain errors. An example of package codes for detecting package errors is disclosed by Kaneda et al in a technical article entitled Single Byte Error Correcting Double Byte Error Detecting Codes for Memory Systems appearing in IEEE Transactions on Computers, Vol. C 31, No. 7, July 1982 at pp. 596 602. Further examples of package codes and their hardware implementation are disclosed by Bossen in US A 3,629,824 and by Chen, one of the present inventors, in US A 4,464,753. Closely related to Chen s patent is US A 4,319,357 to Bossen which discloses the use of SEC DED code to correct double errors, one of which is a hard failure. The storage location of the erroneous word is checked for a stuck bit. A new syndrome is calculated and compared with the syndrome of the erroneous word to locate the transitory error. Hsiao et al, in a technical article entitled Double Error Correction, appearing in the IBM Technical Disclosure Bulletin, Vol. 14, No. 4, September 1971 at p. 1342 discloses a method of using a single error correcting SEC code to correct a double error by consecutively inverting bits until only a single error remains, which can be corrected by the code. However, this technique provides no localization of the errors. Furthermore, the inversion of a correct bit produces three errors which the code must unambiguously detect as an error. Scheuneman et al in US A 4,139,148 disclose a method of correcting double errors with a single error correcting SEC code. Whenever a single error is detected, the syndrome bits used to correct the error are stored. If, subsequently, the same word produces a detection of a double error, the previously stored syndrome is used to correct one of the errors. Bossen et al in a technical article entitled A System Solution to the Memory Soft Error Problem appearing in IBM Journal of Research and Development, Vol. 24, No. 3, May 1980 at pp. 390 397 discuss the problem of simultaneous hard and soft errors. One solution, applicable to a subclass of errors, is to complement the read data, store the complement in the original memory location, reread the complemented data and recomplement it. In some but not all combinations of hard failures and data, this complement and retry technique overcomes these hard failures. Carter in US A 3,949,208 also describes an extended error correction technique utilizing complement and retry. Error Correction Coding for Digital Communications by G.C. CLARK and J.B. CAIN, 1981, Plenum Press, New York, pp 214 216 discloses a means for correcting errors in non binary BCH codes by substituting arbitrary received symbols in the known erased positions. A set of simultaneous equations is then formed from which the errors can be corrected. Whilst this method may be generally applicable, in the simple binary case a systematic trial and error approach in which 1s and 0s are interchanged will be simpler to implement. Accordingly, it is an object of this invention to provide a method and apparatus for the correction of multiple errors in a data word. It is a further object of this invention to provide for the correction of errors occurring in more than one package when the error correction code is capable of correcting only single package errors. The invention, as claimed, can be summarized as an extension of the retry method for correcting hard errors that have been detected but cannot be corrected by the error correction code that is being used. A data word is read and stored in a register. The error correction code operates on the data word and when it detects an uncorrectable multi package error, the originally read word is complemented before being restored in the original location. The complemented word is then retrieved and recomplemented and passed through the error correction code. If an uncorrectable error still results, the retrieved, once complemented word is compared bit by bit with the originally read word stored in the register to determine in which packages hard errors have occurred. Once the boundaries of the hard error have been found, the bits in the data sub field are sequentially changed in the retrieved, once complemented word. The selectively changed word is then recomplemented and passed through the error correction code. If an uncorrectable double package error still results, another combination of change bits is attempted until the change bit pattern of the sub field matches the error free originally stored data with the result that the error correction code can correct the error in the remaining erroneous sub field. FIG. 1 is a flow diagram illustrating the extended error correction method provided by this invention. FIG. 2 is a block diagram illustrating a memory system protected by the extended error correction of this invention. FIG. 3 is a circuit diagram of an embodiment of the ECC extender for use with the system of FIG. 2. FIG. 4 is a circuit diagram of an embodiment of a decoder used in the ECC extender of FIG. 3. FIG. 5 shows a truth table for the decoder of FIG. 4. FIG. 6 is a table illustrating an example of the operation of the present invention. One embodiment of the invention is described with reference to an SPC DPD single package correct double package detect code that can correct any number of errors in one package but can only detect the existence of errors in two packages. Any SPC DPD code can be used, such as those of Kaneda et al or of Chen, previously referenced. A complement and retry technique is used to identify one or more of the packages having hard errors. Since the SPC DPD code can detect any number of errors in that package, possible combinations of data are tried for that package until the SPC DPD code no longer detects errors in the identified package. Any incorrect combination results in an error detection. Once the correct combination has been found, the code can additionally correct the errors in the remaining error containing package. The flow diagram for the operation of the invention is illustrated in FIG. 1. A data word is first encoded according to a SPC DPD code. The encoded word is stored in its proper location A in a memory along with the check bits resulting from the encoding. These first two steps occur whenever during normal processing a data word is to be stored in the memory. Of course, the location A in the memory will vary according to the identification of the data word. Sometime later, the computer will need the information stored at the particular location A in memory. The computer reads the word from the designated location A, which word will be called R. The word R and its various permutations used in this invention will be understood to include both the data bits and the associated check bits, unless otherwise specified. The read word R may differ from the word originally stored at the designated location because of either hard or soft errors. The read word R is latched twice into registers A and C consecutively. The SPC DPD procedure is executed upon the word R from register A. If the read word R contains no errors, or if it contains errors restricted to a single package, then there will be no uncorrected errors since the SPC DPD code can correct all the errors in one package. In this case, the access is complete because either the read word R is correct or has been corrected and the corrected word R can be used. The above procedure is normal ECC processing. If, however, there are errors in two different packages, the ECC procedure can only indicate the existence of this condition and cannot correct. If errors occur in more than two packages, the ECC may, in some situations, flag the condition as an uncorrected error. However, in some other conditions, the condition will not be flagged as an uncorrected error. At this point the first stage of extended error correction, called E²CC, is initiated. If there is an uncorrected error, the value of the read word R is also stored in a register B, and R is then inverted to its complemented value. The complemented value The ECC code is then applied to the recomplemented retrieved data If there is no indication of an uncorrected error after this ECC processing, then the corrected value from the E²CC is used for the value of the originally read word R. It is recommended that this new value of R be immediately restored in the designated location A in memory because one of the errors so detected may have been a soft error. Soft errors do not indicate a bad memory location but only that the data bits had been inverted at that location. Once the data has been correctly restored at that location, it is highly unlikely that it will reinvert. However, soft errors accumulate over time and may accumulate to the point that they become too numerous in any word to correct. Thus it is advisable to correct any soft error as soon as it is detected in what is described as a scrubbing operation. This completes the E²CC process involving complement and retry. If, however, the ECC processing of the recomplemented retrieved word still produces a flag of an uncorrected error, then the next level of extended error correcting, called E³CC, is implemented as follows. A bit by bit comparison of W and R is made from their values stored respectively in registers A and C. Any true comparison between the bits indicates that the double inversion with the intervening store did not reproduce the same bit value. That is, the bit location in the package is stuck at some value, a hard failure. This comparison is made to find at least one hard failure in one of the two packages with errors. The location of the hard failure isolates or identifies one of the bad packages within the data word. Of course, if all the errors in one of the packages were soft errors, the comparison would not identify this package. It is to be noted that the procedure thus relies upon there being a hard error in at least one of the two error containing packages. If all the errors are soft errors, the present procedure cannot correct the data. At this point, one of the faulty packages has been identified, and it is assumed that additional errors are restricted to only one further package. As a result, the data contained in the identified package becomes almost irrelevant. Of the 16 possible combinations of data in the identified 4 bit package, the SPC DPD code can detect the 15 wrong combinations. The 16th and correct combination, combined with the rest of the word, results in a full data word with errors localized to one other package. The ECC code can correct this situation. Thus, the various combinations of data in the identified package are passed through the ECC code until it can correct the word. The preferred procedure will now be described. The value of W stored in register A is used as a starting point. The bits associated with the identified hard error package are sequentially and one by one changed to produce a changed data sub word W If all 16 combinations of data in the identified package still do not produce a fully corrected word, it is assumed that the ECC had initially detected errors in three or more packages or possibly that the hard errors are intermittent within the extended ECC cycle. The described embodiment is incapable of handling these situations and an uncorrected error is flagged If two packages have been identified as containing hard errors, then it is preferable simultaneously to change the bits in both of them since this is likely to more quickly produce one correct combination. A hardware implementation of the extended error correction of the present invention will now be described. The memory system shown in FIG. 2, consists of four memory packages 10 each having four bits of output. An ECC logic 12 is provided which implements a single package correct double package detect SPC DPDx4 code for a resultant 16 bit protected data word, divided into four sub fields each of four bits. The designation x4 indicates the specific package width of four bits for the code. Such an SPC DPDx4 code may require 12 or more checkbits, but for short data fields it can be shortened to a considerable degree, as is well known. Kaneda et al, in the previously cited article, describe an example of ECC logic 12 of the class needed for this invention. It must be noted that the simplified embodiment described here is for illustrative purposes only and that other sizes of data field and of sub fields are common in the computer industry. However, these differing sizes present no fundamental changes to the invention. The ECC logic can correct up to four bit errors occurring in any one of the four memory packages 10 and outputs the corrected data to a B register 14. The ECC logic 12 can also detect any number of bit errors occurring in any two of the memory packages 10. However, it cannot further specify the location of the double package errors but can only output an uncorrected error flag signal. The existence of errors in three or four packages 10 may or may not be flagged by the ECC logic that is designed to unequivocally detect only double package errors. The invention further provides an ECC extender 16 associated with each one of the memory packages 10 and receiving four bits of data from that package 10 through a 16 bit A register 17. The ECC extender 16 also provides four of the 16 bits of data to the ECC logic 12. The data which the extender 16 provides to the ECC logic 12 may be the original data from the associated memory package 10 or the data may be modified according to the process described before. A controller 18 receives the signal for an uncorrected error from the ECC logic 12 and controls the operation of the ECC extender 16. An E²CC signal from the controller 18 indicates that the extended error correction is in the initial stage of complement and retry while a E³CC signal indicates that a counter 20 is changing the bits of the sub field associated with a memory package 10 having a hard failure. The details of the ECC extender 16 are shown in FIG. 3. Each of the outputs of one of the memory packages 10 is connected to an associated A latch 30 which forms 1 4 of the A register 17, previously referred to. The output of each of the latches 30 is connected to the input of an associated C latch 32 which forms 1 4 of the previously mentioned C register. Both sets of latches 30 and 32 are latched by the controller 18, and the C latches 32 are used for storing the word R for the bit by bit comparison. A set of four compare circuits 34 receive inputs from a respective pair of one of the A latches 30 and one of the C latches 32 and outputs a high or 1 signal when the two bits of input are equal. This comparison is the bit by bit comparison of W and R. The output of each one of the compare circuits 34 is fed to one of the inputs e, f, g, and h of four decoders 36. Each decoder controls the selective inversion of the data bit latched in the associated A latch 30. The selective inversion is performed by an exclusive OR gate 38. Each exclusive OR gate 38 provides as its output one of the 16 inputs to the ECC logic 12, only four of which are shown in the memory system of FIG. 3. The outputs of the ECC logic 12 are separately latched in B latches 40. Sixteen of the B latches 40 form the B register 14. The four bit counter 20 has four output lines each connected to an input d of a different one of the four decoders 36. The decoder 36 is composed of logic gates, as shown in FIG. 4. The four inputs e, f, g and h to an OR gate 44 indicate which of the bits of the associated memory package 10 has a hard failure, as indicated by the results of the complement and retry test. A high value on any one of these inputs produces a high value on the HFI hard failure indicator output. If a hard failure has been indicated for any of the bits of the associated package, then the bits within the hard failed package will be changed in the E³CC procedure as the counter counts through. It should be noted that the bits in the sub word W The truth table for the decoder 16 is given in FIG. 5 with the E²CC and E³CC signals and the 1 bit count signal as inputs. The value of the hard failure indicator HFI is high whenever one of the hard fail comparison signals e, f, g and h are high. If both the E²CC and E³CC signals are low, then the decoder outputs a 0 so that the data bit is not inverted. This is the normal mode of operation for the initial attempt at error correction, exclusive of the extended ECC of this invention. If the controller 18 outputs the signals E²CC 0 and E³CC 0, then the initial phase of error correction is being attempted for the word R latched in the A latches 30. The decoder 36 then outputs a 0 so that the data and check bits are passed to the ECC logic 12. The output of the ECC logic 12 is latched in the B latches 40. If the data is correct or correctable, then the ECC logic 12 outputs a valid data signal for the data in the B latches 40. An invalid data flag or uncorrected error signal indicates to the controller 18 that further error correction is required. For an uncorrected error, the uncorrected data word R passes through the ECC logic to the B latches 40. If the controller 18 outputs the signals E²CC 1 and E³CC 0 based on an uncorrected error signal resulting from the ECC check of the initially fetched data , then the complement and retry or E²CC stage of the extended error correction is being attempted. The R data in the B latches 40 is passed back to the A latches 30. This pass back allows pipelined operation wherein a subsequent data word may already have been stored in the A latches 30 but not yet in the C latches 32 . The decoder 36 then outputs a 1 so that all data and check bits of the data word are inverted regardless of the value of the hard fail indicator and the count. The inversion produces the word If however, the controller 18 outputs the signals E²CC 0 and E³CC 1 based on an uncorrected error signal resulting from the ECC check after the double complement or E²CC step , then the second or E³CC stage of the extended error correction is being attempted, that is, the bits of a hard failure memory package 10 are being changed. If HFI 0 for this decoder 36, then the hard failure is occurring in some other memory package 10. In this case, the inversion is performed regardless of the value of the count, as W It is thus seen that the counter 20 controls the bit to be changed in the data word originating from the memory package 10 having a hard failure. If more than one package 10 has a hard failure, then the changes are performed simultaneously in the separate packages 10. The counter should begin at an initial count of 1. A count of 0 does not need to be attempted because this count corresponds to no changes and this case was already tested in the normal ECC processing of the word R. In the general case of n bit memory packages 10, the count proceeds for 2 An example of the correction process performed according to the invention is presented in the table of FIG. 6. Three packages are illustrated in this figure although more could be used so long as no other package contains an error. The first row shows the data that is stored in the three packages. It is assumed that the data has been encoded according to a SPC DPD code. For sake of example, it is assumed that all four bits of the first package have hard failures HF and are stuck at a value of 1. Additionally, one bit in the third package is assumed to have suffered a soft S failure. As a result, when the data is read as word R, it contains erroneous data in two packages. When the word R is processed through the ECC, the double package detect code can only indicate that there is an uncorrected error. The complement and retry or E²CC stage is then begun. The word R is both stored in the ECC extender C register 32 and is also complemented to The bit by bit comparison shown in FIG. 1 is not explicitly shown in the table of FIG. 6 because this comparison is performed at each stage of the counter once E³CC has been entered. Upon entry to E³CC, the counter is set to 1 for the first cycle. Upon a count of 1, the lowest order bit of a package of W is changed actually not inverted when W is complemented but only for those packages suffering a hard failure. The asterisks in FIG. 6 indicate the bits of W that are changed. The changed W is then complemented to The one bit change of W corrected one of the hard errors in the first package but not the other. As a result, the counter is incremented to make another change upon the originally stored value of W. Note that the change to the lowest order bit from cycle 1 does not occur in cycle 2. However, the change of cycle 2 is still insufficient to correct the first package so that the ECC once again indicates a double package error. On a further count from the counter, both low order bits of the word W are changed. This change produces the correct value of W for the first package, that is, the complement of the data originally stored in the package. Nonetheless, the soft error persists in the value of W The description of the above embodiment has assumed that the sub fields of the SPC DPD code are aligned with the boundaries of the multi bit packages. There is no requirement for this alignment for the practice of the invention and a single package may contain multiple sub fields or a single sub field may extend over more than one package. The description has been further based upon the use of a SPC DPD code. Nonetheless, the invention can be used to enhance other error correction codes implemented in the ECC logic. Examples of these alternate codes are SEC DED SPD, SPC DPD, and SEC TED. A TED code is one that can detect a triple bit error. In particular, the E³CC can also be used to correct a single package error, including any number of erroneous bits within that package, when only a SEC DED SPD code exists or it can correct a triple bit error when only a SEC TED code exist. In this last case, it can be seen that the sub field can be associated with a single bit. It is seen that the invention is applicable to many different codes. For non package codes, that is, the number of bits per package b 1, the invention is useful when the number of bits m that can be detected exceeds the number of bits n that can be corrected. However, the usefulness is limited by the number s of soft error bits. The number c of erroneous bits that are correctable is c m if s n. When m n 1, then E²CC is sufficient since the normal invert retry method will correct the error. For package codes b 1, the parameters are redefined as n equals the package error correction capability m equals the package error detection capability s equals the number of packages in which only soft errors occur and c equals the maximum number of erroneous packages that can be corrected. Then c m, if s n. For package codes, when m n 1, E²CC alone will not perform the needed correction unless the data fortuitously line up with the hard fails in a particular fashion. Although the described embodiment is mostly implemented in hardware, a software implementation or a combination of hardware and software is possible. The advantage of the hardware approach is that the functions can be mostly contained on the memory card and are nearly transparent to the user. It is seen that the present invention can be advantageously used with an error correction code that can detect more bit errors than it can correct. The operation of the invention requires that at least some of the bits have hard failures. In this case, the locations of the hard fails are isolated by a complement and retry technique. Then the bits associated with the hard failing locations are changed until the ECC no longer detects an error in those changed bits.