# DATA COMPRESSION METHOD FOR STORING A COMPLEX CHARACTER FONT

## Claims
Verfahren zum Speichern von komplexe Zeichen repräsentierenden Daten, mit Speichern einer Punktmatrixdarstellung jedes Zeichens in einer komprimierten Form für eine nachfolgede Aufweitung durch Hinzufügen von Daten, um eine Reproduktion des Zeichens in aufgeweiteter Form zu ermöglichen, gekennzeichnet durch die folgenden Schritte

## Description
The present invention generally relates to complex character generation, and more particularly to an enlargement procedure for scaling a stored font of complex characters in order to economize the memory requirements of computer output devices for printing or displaying dot matrix patterns of the complex characters. Although, the invention has particular application to the generation of Kanji or Chinese characters, the principles of the invention can be readily applied to the generation of other complex characters such as Hebrew characters, Arabic characters or the like. In fact, the principles of the invention can be applied to the generation of any complex characters including graphical characters. For the computer output of Kanji Chinese characters, the output device is often required to have the capability of printing or displaying more than one font of a character set. The most popular fonts for Kanji Chinese characters are Mincho, an example being given in Figure 1. A character set usually contains between 7,000 and 11,000 characters. In order to make all characters in a font legible, the dot matrix size should be at least 24x24. From the point of view of printer resolution, if a printer has a resolution of say, 200 pels inch, and it is to print 10 point 10 72 inch size characters, then the dot matrix size must be 28x28. Naturally, a larger dot matrix size is needed for a higher resolution printer to print a given size of characters. Commonly used dot matrix sizes are 24x24, 28x28, 32x32, 36x36, and 40x40. Assuming that an electrophotographic printer a page printer is to store 24x24 and 28x28 fonts, each font requires 720,000 bytes and 980,000 bytes of storage, respectively, taking a round number of 10,000 characters in each font. A total of 1.7 million bytes is by no means a small storage when it is the high speed RAM for high speed printers. There are a number of known character compaction and generation schemes for decreasing the number of memory locations to generate a given character set, each having certain advantages and disadvantages. U.S. Patent No. 3999167 to Masamichi Ito et al discloses a technique for generating Kanji characters wherein every other dot element in an original character matrix is stored thereby achieving a reduction of one half in the required memory allocation for the character generator. U.S. Patent No. 3936664 to Hiroshi Sato discloses a technique of generating Kanji characters wherein a given Kanji character is broken down into a plurality of vectors however, the generated character is only an approximation of the original character. Even with the memory savings achieved by the techniques of Ito et al and Sato, the memory space required remains excessive. A much greater savings in memory is achieved by the method disclosed in U.S. Patent No. 4181973 to Samuel C. Tseng and assigned to the assignee of this application. According to the prior Tseng method a dot matrix defining a given character is compacted into a sparse matrix with the original character being reconstructed for printing or display from the compacted character defined in the sparse matrix. Each character in the character set is compacted and stored in memory one time only with decompaction being performed each time a given character is to be generated. A set of symbols are defined to represent different patterns which occur frequently in the entire complex character set. Different combinations of the symbols define a given character. The information stored for each sparse matrix representing a given character is comprised of each symbol in the sparse matrix, its position, and its size parameter if the symbol represents a family of patterns which differ only in size. The Tseng method is further developed in U.S. Patent No. 4286327 to Gerald Goertzel et al, also assigned to the assignee of this application. Whereas the character generator of Tseng operates in full serial fashion such that a given pattern must be decoded and then written before the decoding process of the following pattern is achieved, the complex character generator of Goertzel et al operates in parallel mode such that as one pattern is being written, the following pattern is being decoded. Further, greater compaction is achieved by the Goertzel et al techniques. Another, but not mutually exclusive, approach to the problem of memory savings in the generation of complex characters is to store a single font of characters in one dot matrix size and generate other size fonts from the one stored size. An example of this is disclosed in U.S. Patent US A 4090188 to Gojiro Suga. The approach taken by Suga is to compare the adjacent bits in rows or columns and insert an 1 between compared bits when both are 1 s or insert an 0 in all other cases in order to increase the size of the font. This technique can, however, produce serious distortions in the generated characters. It is accordingly an object of the present invention to provide a method of storing data which avoids such distortions. According to the invention there is provided a method of storing data representing complex characters, including storing a dot matrix representation of each character in a compressed form for subsequent expansion by addition of data to permit reproduction of the character in expanded form, characterised by the steps of developing, for each character, patterns of horizontal and vertical lines of dots constituting first and second input dot matrices respectively representing the character in compressed and expanded form, partitioning the first and second input dot matrix representing a given character into sections, each section containing at least one feature of the character represented by a high density of dots in the matrix, selecting a section of the second dot matrix for expansion by comparing the number of lines therein with the number of lines in the corresponding section of the first dot matrix, comparing the dot distribution in a section so selected in neighbouring lines to determine where in such section lines are to be inserted and the content of such inserted lines, and storing data representing where the lines are to be inserted and the content of such lines as side information with the originally stored dot matrix, whereby an enlarged font of characters which closely resembles the stored font or characters can be produced on the fly from the data representing the stored font of characters and the side information. A refinement of this basic technique additionally stores a sparse matrix containing the error of the generated matrix as compared with the original one. This additional information permits the generation of the exact duplicate of the original font. The invention will be better understood from the following detailed description with reference to the drawings, in which Consider the same character displayed in both 24x24 and 28x28 fonts as shown in Figures 2B and 2A, respectively. Our procedure scales up the 24x24 font to a 28x28 font which resembles the original 28x28 font as close as possible. Obviously, four horizontal and four vertical lines of pels 0 s and 1 s must be added to the 24x24 font. The main part of the procdudre involves a decision regarding the locations of the inserted lines. For the sake of simplicity, only the problem of inserting and deleting horizontal lines vertical expansion is considered in this description however, those skilled in the art will recognize that the problem of horizontal expansion can be handled in a similar way. In order to preserve the basic shape of the character, it is convenient to first partition the dot matrix into sections, each of which contains a very pronounced and recognizable portion of the character. Then a decision is made in which sections to insert or delete lines. In this way, the various sections are enlarged without distorting the basic overall shape of the character. Next, a decision is made exactly where in each section to either insert or delete lines. Finally, a decision is made what the inserted lines should look like. These four problems are discussed in order in the following description. The character in Figure 3 embodies the different strokes typically used in a Mincho font dot, horizontal stroke, vertical stroke, hook, and slant stroke. Statistically, horizontal and vertical strokes occur more frequently than do other strokes, and typically some of these appear more pronounced to the human eye than do others. In Figures 4A and 4B, significant horizontal and vertical lines are distinguished by marking X s on them. This encourages us to imagine the lines with X s on them as wires on a grid. Ideally, we should be able to stretch the 24x24 font along vertical and horizontal directions until the grid wires line up with those of the 28x28 font. The significant vertical and horizontal strokes are used as boundary lines with which we partition the dot matrix into sections. We then have to match the sections of the 24x24 font with those of the 28x28 font. To determine which horizontal strokes are significant, we first define the density functions F1 and F2 as follows The density functions of the character in Figure 3 are given in Figures 5A and 5B for the 28x28 and 24x24 fonts, respectively, shown in Figures 2A and 2B. The peaks of the density functions occur at what we call the significant strokes. In most character patterns, there exists a one to one correspondence between the peaks of F1 and F2. When this happens, we partition and then match corresponding sections. It may happen that a one to one correspondence does not exist, or that the fourth largest peak is not unique. Heuristic methods may be used to deal with those situations. Using such methods, it is sometimes necessary to use either fewer or more than four significant strokes to partition our matrices into matched sections. Once we have a one to one correspondence between the sections of the 24x24 font and those of the 28x28 font, we check to determine that this correspondence is indeed a proper one. Section mismatch may occur, for example, when adjacent lines have very close density values. We first check to determine that each of the 28x28 font has at least as many lines as its corresponding section in the 24x24 font but no more than four more lines. If this is indeed the case, then we consider the match to be correct. If this is not the case, however, we do not yet conclude a section mismatch. Next, we introduce the test function For a proper match, T j should be close to 1 for all j. If TH1 T j TH2 for all j 1,...,N 1, where TH1 and TH2 are some experimentally determined threshold values, then we consider our sections to be well matched. Otherwise, we have a section mismatch, and again heuristic methods may be used to deal with these situations. These methods divide the matrices further into more sections until a proper match is found. One we have matched sections, our next decision is in which sections to either insert or delete lines, and how many lines to insert in each section. The test function introduced in the previous discussion always guarantees that we need to delete at most one line from each section. We compute the differences D j , J 1,...,N, of the number of lines in the j th section of the 28x28 font minus the number of lines in the j th section of the 24x24 font. From the above, D j 1 and by construction, If D j is non negative, then we have to insert D j lines into the j th section. If D j 1, then we have to delete a line from the j th section. Tables showing matched sections of 24x24 and 28x28 fonts and the corresponding D vector are given below In considering where to insert lines into a section which we have already decided to expand, we have tried two approaches. The first is to look for two consecutive lines whose Hamming distance is very short i.e. their patterns are very similar and to insert a line between them. The disadvantage of this approach is that it may overemphasize very pronounced strokes. The second approach is to look for lines with minimal density values and to insert a line right below them. The drawback of the second approach is that it may over enlarge sparse parts of the dot matrix. The choice of approach to use for each particular character is obviously a matter of taste. As far as deletions are concerned, we look for two adjacent lines with minimal Hamming distance and delete the one with the smaller density value. Deletions occur very infrequently. Once we have decided where in a particular section to insert lines, we have to determine what those lines should look like. We offer two methods. The first is to simply copy the line immediately preceeding the inserted one. This has the advantage of speed since we avoid any computation in forming the inserted line. But this method has a tendency to produce rough looking strokes in some characters it especially affects slant strokes by producing undesirable zig zags. Alternatively, we may produce the line to be inserted by interpolating its two immediate neighbours. The arrangements of 0 s and 1 s in a dot matrix of Mincho font are not random, but highly correlated. By observing the basic strokes which form these characters, we have obtained the following Boolean interpolation equations to create an inserted line x i from the knowledge of its adjacent lines a i and b i where denotes and and denotes or . If we have to insert a line after the last line of a section, then we may either duplicate the last line or instead insert an interpolated line between the next to the last line and the last one. While the method of interpolaton does smooth out the strokes, it may also destroy some desirable zig zags. Again, the choice of which method to use is a matter of taste. The method thus far described scales a 24x24 font up to a produced 28x28 font which closely resembles an original 28x28 font of the same character. For those who insist on an exact duplicate of the original font, the following refinement can be added to the basic procedure. Let A denote the dot matrix of the original font, let B denote the dot matrix of the produced font, and define the 28x28 dot matrix as Summarizing the principle features of the procedure according to the invention, reference is now made to Figure 6 of the drawings which shows a flowchart of the scaling operation. In operation block 10, the data of the 24x24 and 28x28 fonts is inputed to the computer. The computer in operation block 11 takes the vertical density functions for both the 24x24 and 28x28 fonts. Based on these density functions, each font is divided into sections in operation block 12, and the divided sections are matched in operation block 13. Then in decision block 14, the match is tested. If there is a match, the procedure goes next to operation block 15 otherwise, the sections are adjusted in operation block 16 and the procedure returns to block 13. In operation block 17, the number of lines needed are determined for each section, and then in operation block 18 the places where the lines are to be inserted or deleted is determined. In operation block 19 the lines to be inserted are produced, and in block 20, lines are inserted and deleted as required. Next in decision block 21, a decision is made as to whether expansion is completed. In our discussion so far only vertical expansion has occurred therefore, we proceed to operation block 22 wherein a 28x24 font is obtained. Next, in block 23 the horixontal density functions of both the 28x24 and 24x24 fonts is taken, and the process returns to block 12 to obtain horizontal expansion. Then an exit is made from decision block 21 to operation block 24 in which the 28x28 font is obtained. At this point, the data for scaling the 24x24 font to the 28x28 font has been obtained. Therefore, in block 25 this scaling information is encoded as the side information, and in block 26, it is stored with the 24x24 font. The algorithm which we have described without using the exact duplication refinement provides a fairly good enlargement for most Mincho characters. For those not satisfied with the results, we have produced an Interactive Font Generating Tool IFGT . This is a software package which allows the user to use a graphic facility to actually test out various combinations of insertions and deletions and then decide which combination s he likes best. Once the user makes a decision, s he can encode the information using the methods described. The IFGT is illustrated in the flowchart of Figure 7. To begin, the data of the 24x24 and 28x28 fonts is inputed to the graphic facility as indicated by operation block 27, and then the two fonts are displayed in block 28. The user then provides a manual input for vertical expansion in block 29. The manual input is processed in block 30, and the generated font is displayed in block 31. In decision block 32, if four lines have not been added to effect the vertical expansion, the interactive process returns to block 29 for further manual input. Other wise, the user is prompted in decision block 33 as to whether s he desires to reoperate the procedure. If the user is satisfied and does not wish to reoperate the procedure, the 28x28 and the vertically expanded 28x24 fonts are displayed in block 34. On the other hand, if the operator decides to reoperate the procedure, the original 24x24 and 28x28 fonts are redisplayed in block 28. Returning to the display in block 34, the user next provides a manual input to the graphic facility to effect horizontal expansion as indicated by block 35. This manual input is processed in block 36, and the resulting generated font is displayed in block 37. If four lines have not been added, then decision block 38 returns the operation to block 35 for further manual input by the operator otherwise, the process goes to block 39 in which the generated 28x28 font is obtained. Again, the operator will be prompted to indicate satisfaction of the generated font as indicated by decision block 40. This time there are three choices. If totally unsatisfied, the operator can opt to return to block 28 to begin anew. If the operator remains satisfied with the previously obtained vertical expansion, s he can simply return to block 34 where the 28x28 and the previously generated 28x24 fonts are redisplayed. The third choice is, of course that the operator is satisfied with the generated font in which case the procedure goes to block 41 where the operations are encoded into side information and then to block 42 where the side information is stored with the 24x24 font memory. It will be observed that the IFGT performs exactly the same procedure as that of our scaling algorithm. The difference is the substitution of an empirical approach for a purely analytical one. The IFGT also provides facilities for block expansion of those characters which are composed of distinct subpatterns. The example in Figure 8 shows a Chinese character which is composed of distinct subpatterns. The idea behind block expansion is that each subpattern is treated separately, and this often yields better results. Even though we could have incorporated block expansion into our basic algorithm, as subpatterns are quite pronounced in Mincho Characters, we have opted in our preferred embodiment of the invention not to do so because this would have enormously increased the complexity of the algorithm. Instead, we have only introduced the block expansion facility in our IFGT. The drawback of block expansion is the added requirement of memory to store the boundaries of all the blocks. The described data compression scheme stores information to generate computer printout of Chinese Kanji characters of various fonts. Several alternatives have been described, the costlier ones yield more desirable outputs. Figures 9A to 9F show the results of the various methods. Figure 9A shows the original 28x28, 9B the original 24x24 font, 9C a generated 28x28 font by the copying method, 9D a generated 28x28 font by the interpolation method, 9E a generated 28x28 font by the interactive font generation tool, and 9F the exact reproduction of the 28x28 font. Although the invention has been described in terms of one specific application, that of scaling a 24x24 font to a 28x28 font, the principles of the invention are equally applicable to the scaling between other and different fonts including non square dot matrices. Moreover, it will be understood by those skilled in the art that the scaling of Chines Kanji characters is but a subset of the problem of scaling graphic characters of any arbitrary type.