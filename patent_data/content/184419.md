# INTERACTIVE RASTER DISPLAY SYSTEM

## Claims
In einem System mit einer Rasterzeige, einem Eingabegerät, einem Puffer zum periodischen Auffrischen der Anzeige und einem Prozessor, der die Anzeige und den Puffer verbindet, sorgt der Prozessor dafür, daß das Eingabegerät die Pufferinhalte ändert, wobei der Puffer einen farbcodierten n x m Raster Pelbereich enthält, der sich in mindestens einem geschlossenen Polygon befindet, das aus benachbarten Rasterdurchläufen besteht, wobei jeder Durchlauf aus einer von q Reihen eines ersten farbcodierten r x q Pel Unterfelds ausgewählt wird dabei ist jeder Durchlauf ein rationalzahliges Mehrfaches von q Pels in der Länge, q und r 1 darüber hinaus wird ein Verfahren zum Festlegen der Polygonform und zum Füllen des festgelegten Form mit benachbarten Rasterdurchläufen, die aus r Reihen eines zweiten farbcodierten r x q Pel Unterfeldes ausgewählt werden, beschrieben, wobei das Verfahren folgendes umfaßt

## Description
This invention relates to interactive raster display systems and more particularly to a method for ascertaining the boundary of an arbitrarily shaped closed polygon filled with a first colour coded pel pattern and for filling the ascertained polygon with a second colour coded pel pattern in such a system. Prior art interactive buffered raster displays include low persistence phosphor multiple gun colour cathode ray tubes CRTs . Such a CRT is the electronic medium upon which an image is painted by way of electron beam deflection and intensity modulation of its multiple coloured guns. Information, both defining the image to be painted and providing the necessary control, is obtained from a buffer intermediate the CRT display and a stored program controlled processor. The processor executes lists of graphical orders ultimately resulting in the CRT painted image. In executing its tasks, the processor causes bit values in the form of a multibit code to be stored in a counterpart location in the buffer. The multibit code, termed a pel , consists of an x,y position coordinate and a colour number or value. As each pel is extracted from the display buffer during a horizontal scan of a raster driven display, the bits are used to index a translate table which converts them into a larger number of bits. This larger number of bits, in turn, drives designated red, green, and blue digital to analog converters actually modulating the multigun CRT beam intensities. Foley and Van Dam, Fundamentals of Interactive Computer Graphics , Addison Wesley Publishing Co., 1982, devote chapter 12 pp. 479 503 to the rudiments of a raster display architecture. Also, at pp. 456 460, they describe the contemporary state of the art in the ascertaining of the boundary of arbitrarily shaped closed polygons and the filling thereof for a bit mapped presentation display system such as an interactive stored processor control raster colour coded display. The preferred method described on pp. 457 458 for ascertaining the shape of the polygon to be filled involves finding the intersections of a scan line with all the edges of a polygon, sorting the intersections by an increasing x coordinate, and filling in all pels between pairs of intersections. Appel and Evangelisti, Automatic Filling of Bounded Areas in a Raster Display , IBM Technical Disclosure Bulletin, Vol. 21, pp. 1300 1303, August 1978, show the scanning and filling of a raster object starting at an arbitrary point within the object domain and then determining pel colour and filling on the fly. The method of filling the pel cell positions constituting the polygon interior requires that a cell of arbitrary colour, termed a seed cell, be placed within the polygon. If an empty cell is adjacent contiguous only to the seed cell, then said empty cell is filled. The filled cell in turn becomes a new seed . If an empty cell is between a cell defining the polygon border and a seed cell, it is left empty. Admittedly, such a recursive procedure uses no boundary equations. However, the identify and fill cells on the fly appear valid only for runs of simple patterns such as black objects in white fields. Indeed, where a pattern is complex such as an r x q subarray of pels of multiple colours, then the recursion becomes effectively non terminating because where the replacement colour coded pattern corresponds at any point to the original colour coded pattern, then the system of marking previously visited locations has the effect of leaving those locations unmarked. It is accordingly an object of this invention to devise a method wherein the bounded area of a closed polygon shape in a raster display is ascertained and filled. Furthermore the raster polygon shape is ascertained and filled even though it exhibits a complex colour pattern, and the method execution time shall be finite and any area ambiguities are to be completely resolvable. The object is satisfied by a method for use in a bit mapped presentation display system, as defined in the attached claims. How the invention may be carried into effect is hereinafter particularly described with reference to the accompanying drawings, in which In a typical prior art, there is shown an interactive raster display system Figure 1A including a multigun colour display monitor 5, a keyboard 3 with programmable function keys, a mix of RAM and ROM based memory 7, one or more DASDs 9 attachable through an adaptor 2, and a stored program controlled microprocessor 1 interconnecting the monitor 5, keyboard 3, memory 7, and adapter 2. One configuration for example, includes an IBM 5153 Colour Monitor with an IBM 4910 Colour Adaptor Card, an IBM 5160 Systems Unit, an IBM PC keyboard, and a 13,335cm 51 4 inch floppy disk drive with a PC adaptor. The refreshed raster display portion Fig. 1B of this system comprises a display buffer 13, a translate table 15, the processor 1, and a refresh controller 11. The processor 1 constructs an image of pels and writes them into the display buffer 13 over paths 27 and 29. Furthermore, processor 1 also may access and alter the contents of translation table 15 over paths 23 and 25. Once the image is resident in buffer 13, it is normally cycled through the translate table 15 and the raster display controls not shown as regulated by the refresh controller 11 over path 33. The refresh controller actually accesses consecutive locations in buffer 13. The colour values of the extracted pels are in turn converted by the translate table and applied to the red, green, and blue guns 17, 19 and 21 of the CRT of the colour monitor 5. The x,y coordinates associated with the extracted pel control the electron beam deflection of the CRT. Because each location in the display buffer 13 defines one point sized element of an image, a simple buffer having 1 bit per pel would suffice for a two colour black white image. However, colour images need a multibit code for definition. To extend the colour and richness of pels and patterns without burdening the buffer, the code points are used as pointers in a larger code space. These are among the functions performed by structured sets of colour translate tables, as described in US A 4,255,861. That is, a translate table serves to minimize display refresh buffer size while maximizing the number of distinctly displayable colours. A black and white raster coded object is shown in Figure 2A, representing a bit map such as might appear in the refresh buffer or on the display face. The entire m x n array 4 of pels is termed a domain . If an object is defined as the replication of a reference pattern in the domain, then several objects are included in the domain of Figure 2A. These comprise considering white on black, a white chain linked object in a black field and considering black on white a black band having a chain link aperture set in a white field. In either case, the object is closed or bounded and consists of runs of contiguous pels of like colour in the raster scan line direction. Another way of viewing a run is with reference to comparing a given row of a reference pattern with the row raster scan line of the domain being compared. Thus, in an r x q white reference pattern 6 Figure 2B for a given r n and q m, the first row consists of four white pels. If comparison were made four pels at a time, then a raster run would consist of as many repetitions of four white pels in a row in the raster scan line direction. The reference pattern also indicates that the next row beneath the first row should consist of a row of four white pels. Thus, the white pels encountered in the second row of the object would be considered contiguous, whereas the black pels in the row immediately above the first row of the object in Figure 2A having a different colour indicate a border or boundary. In a typical primitive r x q subarray 8 Figure 3 , of contiguous pels, each pel may assume one of three, four, or more colour values. In this regard, the difficulty of ascertaining the boundary of an object formed from multiple contiguous arrays of colour complexity is greater than that of patterns of solid colour, e.g. Figure 2A. This is illustrated in Figure 4 where the chain linked object is somewhat masked by being embedded or formed from the colour rich patterns. A run is operationally defined as the colour value match of q consecutive pels on the ith row of a first or reference pattern with q consecutive pels on the jth row or raster scan line of a domain. With reference to Figure 2, each row of the reference pattern consists of pels of like colour value so that for a given raster scan line of the domain, a run would exhibit contiguous pels of the same colour value. However, where a reference pattern has pels of several colour values, then a run would require the replication on a pel comparison match basis. In this regard, reference should be made to Figure 9B where the reference pattern consists of a r x q array of a pattern of red, white, and blue pels. The top row of the reference pattern is coded as blue white blue white and runs in the domain Fig. 9A can be found in the first, fourth, and seventh domain rows from the top. Likewise, the second reference pattern row is coded as white red white white. This appears without ambiguity in the second, third, fifth, sixth, eighth and ninth rows of the domain. As is visible in high contrast in Figures 2 to 5, a raster scan line may have one or more runs. In Figure 5, the leftmost pel position of a run is labelled for illustration by letters. In the preferred embodiment, the location of a run is defined by the position of the leftmost pel position. The first method step contemplates identifying the pattern constituting the object. In the simplified illustration used with Figure 5, the pattern is a r x q white pel array. It should be recalled that in the IBM Technical Disclosure Bulletin article referred to above, neighbouring cells are recursively coloured starting with the colour value of a single seed cell. This recursive colouring continues until a border cell of an object was detected. While attractively simple, this can not use replacement colour coded patterns more complex than a single pel for the algorithm because there can be no guarantee of a termination of the identify and filling of cells on the fly where the replacement colour coded pattern corresponded at any point to the original colour coded pattern. This is because the system of marking previously visited locations by replacing them with new values has the effect of leaving them unmarked. In the domain shown in Fig. 9A, white cells are liberally interlaced with red and blue cells. Because the disclosed system is monochromatic, it would either white out, red out, or blue out the domain depending upon whether its seed cell was red, white, or blue. If an attempt is made to use a more complex replacement colour coded pattern, such as a different pattern of red, white, or blue pels, it would be non terminating. For example, if the process started on a blue cell and that cell was replaced by another blue cell from a complex replacement colour coded pattern, and the same happened in an adjacent cell, then after filling on the fly two adjacent cells, they would be effectively unchanged, and the algorithm would cycle indefinitely between them. Referring now to Figure 8, there is shown a connected graph representation of runs identified in the white object depicted in Figure 5. Each run is represented by a counterpart labelled vertex. Line to line contiguity between runs is shown by an edge connecting a pair of vertices. This means that the determination of the area of a closed polygon by scanning contiguous runs is the same as dealing with the graph and visiting the vertices and connecting edges in a systematic fashion. The determination of the polygon area formed by unique contiguous runs is equivalent to presenting such runs as a graph and then traversing the graph such that each node is visited only once. In this specification, both a recursive depth first and non recursive parent child traverse are discussed. In this regard, a depth first search, which is a generalization of the preorder traversal of a tree, is one important technique. A depth first search works by selecting one vertex v as a start vertex and marking v as visited. Then each unvisited vertex adjacent to v is searched in turn, using depth first search recursively. Once all vertices that can be reached from v have been visited, the search of v is complete. If some vertices remain unvisited, an unvisited vertex is selected as a new start vertex. This process is repeated until all the vertices have been visited. The name depth first search is apt because the technique continues searching in the forward deeper direction as long as possible. For example, if x is the most recently visited vertex, then a depth first search selects some unexplored edge connecting x to y. If y has been visited, the procedure looks for another unexplored edge connected to x. If y has not been visited, then the procedure marks y as visited and initiates a new search at y. After completing the search through all paths beginning at y, the search returns to x, the vertex from which y was first visited. The process of selecting unexplored edges emanating from x is then continued until all edges from x have been explored. Illustrative of a pseudocode representation of a depth first search is the following An adjacency list can be used to represent the vertices adjacent to vertex x, and a data structure such as an array mark, whose elements are chosen from visited, unvisited , can be used to determine whether a vertex has been previously visited. Assume that the above procedure dfs v is applied to the graph of Figure 8 with the A replacing v. The procedure marks A visited and selects vertex B from the adjacency list of vertex A. Since B is unvisited, the search continues by calling dfs B . The algorithm now marks B visited and selects the first vertex from the adjacency list for vertex B. Thus, dfs F is in turn invoked. The algorithm now marks F. D is in turn marked and since A has already been marked, a pattern is invoked using dfs C , dfs G , dfs E , or dfs E , dfs G , dfs C . At this point, the original call of dfs is complete and all the vertices have been marked. Among the properties of the depth first search is a traversal of all connected vertices in a graph and marking a memory or list to indicate those vertices visited. Another way of visiting all the nodes of a graph exactly once is to identify all of the nodes contiguous to a given node on an echelon basis . A more colourful terminology would recognize that any given node or vertex may be labelled a parent or ancestor and each of those adjacent to it termed its child or descendant . The following illustrative example exemplifies the non recursive parent child traverse and is an alternative to the recursive traverse. The factors dictating of one or the other are those ordinarily appreciated by those skilled in the art and include the amount of available internal memory. It is, for example, well known that recursive procedures may require an order of magnitude or more of memory than non recursive procedures. Referring now to Figure 6 and 7, the method of the invention utilizes three lists a permanent final list and a temporary parent and child list. Assuming that the first pattern is identified in step 101, and starting at an arbitrary point s within an object, a graph traversing search or scan is invoked. A conventional left scan is made until the lefthand end of a run is identified in step 102 and labelled, in this case a. After identifying the coordinates of the left end of a run, a scan is made to determine the length moving from left to right. In this case, run starting at a is nine pels long. It is then placed on the parent list in step 103 and on the final list in step 104. It is next desirable to identify in step 105 the contiguous runs or, as set out above, those identif ied as descendants or children . The children of run a are the contiguous runs b, c, d, and e. Because the descendants are found not to be on the final list in step 106 , they are therefore added both to the final list in step 107 and the child list in step 108. In step 109, it is determined whether the parent has any more children. If so, step 105 is repeated. If not, the next stage is reached. Then the entries on the child list are moved over to the parent list in step 110. Starting with run b, runs a and f are contiguous thereto. However, because run a is already on the final list , it does not appear on the child list . Consequently, only run f appears on the child list . At this point, runs b, c, d, e, and f are added to the final list . Then it is determined in step 111 whether there are any parent runs added to the final list. If so, step 105 is used. The child or descendant contiguous runs associated with run c are processed. These are runs a and g. Because run a is already on the final list , it does not reappear on the child list . Thus, only run g appears on the child list . At this point, runs b, c, d, e, f and g are on the final list . Then the runs contiguous to run d are processed, namely runs f and a are the contiguous descendents of run D. Because they are already on the final list , there is no change. The same is true with run e as a parent because a and g are also already on the final list . At this point, in step 110 the child list runs of f and g are transferred to the parent list . There are no descendant runs because runs b, c, d, and e are already on the final list . As step 111 now indicates no new parent runs added to the final list, the final list now completely describes the object to be filled in step 112. The procedure terminates upon exhaustion of the parent list . In the following discussion, there are fifteen steps as follows In step 1, two run counters are created. These are the current and previous run counters and are both set to zero. Next, the workspace buffer is divided into two equal parts where list 1 stores the screen starting byte offsets 1 word , and list 2 stores the byte length of the run, the end pel offset and the start pel offset. After this, list 1 and list 2 pointers are set to the top of lists 1 and 2 respectively. The list 2 pointer for a run is equal to the list 1 pointer for the run plus half the workspace buffer length. In step 2, the starting byte offset is set to the beginning column offset, and the length and the start pel offsets are set to zero. The cursor travels left from the beginning column offset to find the run s starting location of the run. First, it must be ascertained whether the pattern matches to the byte boundary. If so, set the byte match flag is set high. At this point, it is necessary to begin to match the background pattern with the Regen buffer the screen on a byte level. Each time an entire byte matches lefthand of Fig. 7A , it is necessary to decrement the start byte offset and increment the byte length. This continues until a match fails or until the left edge of the screen is reached. This location is the starting byte offset unless modified in the ensuing step. In step 3, because a byte match has failed righthand of Fig. 7A , it is necessary to find the pel offset and the byte offset to the start of the run. If the byte match flag from step 2 is greater than zero, then it is necessary to ascertain whether three, two or lastly, one of the Regen pels matches the background pattern looking left from the start byte offset. The start pel offset is found to be one if the closest three pels match, two if the closest two pels match Fig. 7B , and three if the closest pel matches from the start byte offset. If a non zero pel offset is found, then the start byte is decremented and the byte length incremented. If the byte match flag from step 2 is equal to zero, a different procedure is followed. In this case, it is first necessary to ascertain whether the two closest pels match the background pattern looking left from the start byte offset. If the two closest pels do not match the background, then it is necessary to determine whether the closest pel matches. If no match is found, then the start pel position is the remainder when the beginning column offset is divided by four. If a match is found, then the starting pel position is decremented by the number of pels that matched. With this starting location, i.e. both byte and pel offsets, it is necessary to check list 1 first for a match, and then the starting pel offset in list 2 for confirmation. If the current run is already on list 1 and list 2, then go to step 10. In step 4, travel rightward on a byte match basis to determine that the end of the run requires that the end pel offset be set to 3 and the byte match flag set to low. From the beginning column offset, travel towards the right. Determine whether the pattern matches to the byte boundary. If so, it is necessary to set the byte match flag high and then begin to match the background pattern with the Regen buffer on a byte level and each time an entire byte matches, then increment the byte length. This continues until a match fails or the right edge of the screen is reached. At this point, the run length has been found unless modified by step 5. In step 5, travel is rightward on a pel match basis to determine the end of the run. Because the byte match failed, it is necessary to find the end offset of the pel and the length of the run byte. If the byte match flag from step 4 is greater than zero, then see if three, two, or lastly, one Regen pel matches the background pattern looking left beginning at the position equal to the start byte plus the length of the run byte plus one. If a match is found, then it is necessary to increment the byte length. The end pel offset is found to be two if three pels match, one if two pels match, and zero if one pel matches. If the byte match flag from step 4 is equal to zero, a different procedure is followed. At this point, it is necessary to determine whether the two closest pels match the background pattern looking right from the beginning column offset divided by four. If they do not match, then it is necessary to check if the closest pel matches. The end pel offset is equal to the beginning pel offset from step 3 plus the number of pels that matched. In step 6, it is necessary to put run data on list 1 and list 2. If the length of the run in pels makes for a valid run, then the starting byte offset is placed onto list 1 and the byte length of the run, and the ending and starting pel offsets onto list 2. At this point, the current run count number is incremented. Also, the current list 1 and list 2 pointers are incremented so that they point to the first empty space in their buffers. In the event that there is no more room in the buffer, then an error flag is set and a transfer made to step 15. If the previous count number is not zero, then a transfer is made to step 10. For scanning purposes in step 7, the dependent runs are now the ancestor or parent runs. In this regard, the descendant or child run list becomes the ancestor or parent run list by setting the ancestor or parent run list pointers into list 1 and list 2 to the start of the descendant or child runs in list 1 and list 2. This is accomplished by backing up the pointers from the first empty space on list 1 and list 2 by the number of descendant or child runs. The pointers for the next generation of descendant or child runs continues to point to the first empty space on list 1 and list 2. Relatedly, the descendant or child run count number becomes the parent count number and the dependent count number is reset to zero. In step 8, it is necessary to scan or look up one raster line for new child or descendant runs unless the descendant or child scan line is already at the top of the screen. This is implemented by obtaining the starting byte, starting and ending pel, and byte length of an ancestor or parent and determining the new starting byte if the ancestor or parent were one line up. Also, the beginning and ending column numbers of the run are ascertained as well as the beginning and ending byte of the entire line in the Regen buffer for one line up. In step 9, new runs are checked. This means that if the screen pel matches the background pattern, this is treated as a new beginning point and a return is made to step 2. Otherwise, a transfer is made to step 11. At step 10, a scan is made for new descendant or child runs from the end of the current descendant or child run. Thus, a skip is made to the end of the currently identified valid descendant or child run, two columns are added, an update of the trial starting byte of the next descendant or child run is performed. With respect to the latter, a check is also made to see whether this is greater than the ending column of the ancestor or parent run. If so, then a transfer is made to step 12. Otherwise, a start is made from this new starting column and a transfer to step 9 performed. In step 11, in the event of no match, travel is made right to one pel. Since the Regen buffer pattern does not match the background pattern, travel right one pel, and an update is made of the trial starting byte of the next descendant or child run. After this, a transfer is made to step 9 unless past the end of the ancestor or parent run. In this latter event, a transfer is made to step 12. In step 12, a scan down of one line for new descendant or child runs is made unless already at the bottom of the screen. A transfer is made to step 13, if step 12 has already once been performed. From the parent or ancestor starting byte, it is necessary to determine the new starting byte if that ancestor or parent were one line down. Also, the beginning and ending column number of the run, and the beginning and ending byte of the entire line in the Regen buffer for one line down must be recovered. In step 13, the next ancestor or parent run is obtained. This signifies that all the descendant or child runs of the ancestor or parent run have been identified and placed on the descendant or child run list. The ancestor or parent run is no longer needed so that the previous run count is decremented by one and the parent run pointer points to the next ancestor or parent run in list 1 and list 2. After this, a transfer is made to step 8 until the previous run count is decremented to zero. In step 14, all of the descendant or child runs have been found. Thus, all the descendants or children of all the parents or ancestors have been found and put on the run list. A transfer is made to step 7 until the current run list contains zero runs. In step 15, all runs are written to the screen. This means that all runs have been identified. Thus, beginning at the top of list 1, all the runs can be filled with the fill pattern. The fill pattern is justified to the top lefthand corner of the screen and repeated as many times as necessary in order to fill the interior region of the ascertained shape. The following table sets out an assembly level code sequence instructing the processor portion of an interactive raster display system in the execution of the method steps of this invention. The syntax for assembly code is from left to right Note, that each comment is prefixed by a semicolon . Also, the abbreviations dw , db , and respectively designate define word, define byte, and reserve or allocate space.