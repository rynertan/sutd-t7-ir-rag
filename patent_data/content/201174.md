# Method and apparatus for addressing a memory

## Claims
Verfahren zum Adressieren eines Speichers, bei demDatenelemente, die ein Datenfeld mit n Dimensionenrepräsentieren, gespeichert werden oder gespeichert werdensollen, wobei der Speicher physikalische Reihen undSpaltenadressen und einen Datenport hat, wobei das Verfahrendas Erzeugen einer Folge von Datenelementadressen umfasst,die den Speicherstellen gewählter Datenelemente in einergewählten Reihenfolge entsprechen, gekennzeichnet durch diefolgenden Schritte Zuführen eines einzelnenDatenfeldumformungsoperators einer datenfeldorientiertenSignalverarbeitungssprache zu einem Adressgenerator 100 indem Datenport, wobei der Datenfeldumformungsoperator Daten inBezug auf eine Basisadresse, die ein Anfangsdatenelement desDatenfeldes identifiziert, einen Verschiebungsparameter fürjede Dimension des Datenfeldes und einen Längenparameter fürjede Dimension des Datenfeldes umfasst, Benutzen des bzw.jedes Verschiebungsparameters und des Längenparameters derentsprechenden Dimension zum Erzeugen einer Folge vonphysikalischen Reihen und physikalischen Spaltenindexpaaren,wobei jedes Indexpaar einem jeweiligen Datenelement desDatenfeldes entspricht, und Kombinieren jedes Indexpaares mitder Basisadresse zum Erzeugen einer entsprechenden Folge vonDatenelementadressen, und Zugreifen auf den Speicher mit derFolge von Datenelementadressen.

## Description
This invention relates to a method of addressing a memory inwhich data elements representing a data array having n dimensionsare or are to be stored, the memory having physical row and columnaddresses and a data port, the method comprising generating asequence of data element addresses corresponding to the memorylocations of selected data elements in a selected order. Theinvention also relates to a memory in which data elementsrepresenting a data array having n dimensions are or are to bestored, the memory having physical row and column addresses and adata port including an address generator for generating a sequenceof data element addresses corresponding to the memory locations ofselected data elements in a selected order. In many digital processing systems, specially programmedunits control the ordering of data access from memories whilespecial purpose interfacing units link up components withdifferent data formatting requirements. The proliferation ofspecial purpose units results in inefficiencies, causing highsystem development costs, long development times, highprogramming costs, and high system maintenance costs. The arithmetic unit AU in prior processors usuallyassisted the processor control unit to sequence data items to thearithmetic section or transform data items into a form appropriatefor an operation to be performed this not only increased thecomplexity of the control unit, but also interrupted dataprocessing, causing a reduction in processor efficiency. Inaddition, often the AU is idle while the next instruction is beinginterpreted. It is desirable to continuously control formattingoperations over related data items, like arrays, and to let theAU perform continuous AU functions. Sometimes special purpose instructions are implemented in digital signal processors to facilitate performing vector matrixmathematics. Generally, a series of instructions is required toperform a signal processing algorithm using the available specialpurpose instructions and other instructions for correctly indexingand dimensioning arrays. A higher order language that eliminatesthe need for ancillary parameters to index and dimension arrays ishighly desirable, especially when the hardware required toimplement such a language is not prohibitive. US A 4 051 551 is concerned with storage problems inparallel memory systems that arise in performing matrixcomputations. For example, in a two dimensional memory row,forward diagonal and reverse diagonal elements may be accessed inparallel, while column elements must be accessed serially. Amultidimensional parallel access memory system is disclosedwherein matrix elements along linear matrix vectors are non conflictinglystored in a plurality of independent memories, so asto permit parallel processing of the elements along any linearvector. An alignment network properly associates particularmatrix elements stored in the plurality of memories withparticular processing units. Two indexing tags are generated oneof which aligns a particular memory with a particular processor,and the other addresses the memory. These tags are generated inaccordance with a particular storage arrangement of matrixelements. A sequence of addresses is produced by two primarystorage indexing equations. GB A 2 029 990 discloses a data management system based upona hierarchical model of data structure to store records of an n dimensionalmatrix type data group in file storage means atsuccessive locations designated by respective single dimensionaladdresses. The system is required to derive from the coordinatevalues of an item of data the single dimensional address in thefile storage means. Any one of the records can be accesseddirectly on the basis of the matrix coordinates of the data in the record independent of the order in which the coordinates arespecified. Circuitry is operable to derive the single dimensionaladdress of a record of the matrix data group on the basis of thematrix coordinates of the record by establishing a hierarchy ofvirtual sets of records in the calculation of the singledimensional address. The present invention is, however, concerned with thereading and writing of arrays. According to one aspect of the present invention, a methodof the kind defined hereinbefore at the beginning is characterisedby the steps of supplying a single array transformation operatorof an array oriented signal processing language to an addressgenerator in the data port, the array transformation operatorcomprising data relating to a base address identifying an initialdata element of the array, a displacement parameter for eachdimension of the array, and a length parameter for each dimensionof the array, utilizing the or each displacement parameter and thelength parameter of the corresponding dimension to generate asequence of physical row and physical column indices pairs, witheach indices pair corresponding to a respective data element ofthe array, and combining each indices pair with the base addressto generate a corresponding sequence of data element addresses,and accessing the memory with the sequence of data elementaddresses. According to another aspect of the invention there isprovided a memory as defined in claim 14 hereinafter, to whichreference should now be made. In a preferred embodiment of the present invention, a methodis provided for generating addressing sequences for an array,which may be a vector, a matrix or a block, in a memory. Anaddressing sequence is specified by an array transformationoperator comprising a plurality of parameters. An addressgenerator is loaded with a plurality of parameters of the array transformation operator. These parameters include an initialaddress parameter. A plurality of row and column indicesspecified by displacement and length parameters of the arraytransformation relative to the initial address parameter aregenerated and each pair of the row and column indices istranslated into an address for the memory. The method furthercomprises the step of interpreting a boundary parameter of thearray transformation for controlling or modifying the generatingof the addressing sequences when one of said displacementparameters causes the address to be generated outside a boundaryof an array. The boundary parameter specifies one of theboundary modes of operation comprising a wrap around mode, azero fill mode and an ignore boundaries mode. In the preferred embodiment of the invention, an indexgenerator means in an address generator is loaded with an initialaddress specified by an initial address parameter, delta 0, ofthe array transformation, and a displacement parameter of thearray transformation. A counter in the address generator isloaded with a length parameter, L1, of the array transformationand a plurality of addresses is generated by incrementing theinitial address parameter in the index generator with thedisplacement parameter a number of times equal to the lengthparameter. This method produces a line or vector of L1addresses. Further methods in accordance with this inventionproduce a sequence of addresses for arrays of a two dimensionalmatrix or a three dimensional block. In another embodiment of the invention, a memory having aplurality of ports is provided with at least three of said portsbeing intelligent ports comprising an address generator forgenerating a sequence of addresses for arrays including a vector,a matrix or a block in response to parameters of an arraytransformation operator. The parameters are loaded into anindices generator by a displacement control word and a length control word for generating a plurality of row and column indicesrelative to an initial reference point of a single or multidimensionalarray. An address translator coupled to the indicesgenerator converts each pair of row and column indices into anaddress. A microprogrammed sequencer controls the operation ofthe address generator. Each of the intelligent ports may operatein a read or write mode. In accordance with a further feature ofthe embodiment, an address generator of an intelligent memoryport is provided comprising an index generator means forgenerating a plurality of row and column indices, the indexgenerator means being loaded with an initial address specified byan initial address parameter, delta 0, of an arraytransformation, means for storing in the index generator means adisplacement parameter, delta 1, of the array transformation,means for storing in the address generator a length parameter,L1, of the array transformation, means for incrementing theinitial address with the displacement parameter a plurality ofthe times equal to the length parameter, and means fortranslating the row and column indices into a plurality ofaddresses. The index generator means comprises a plurality ofrow index generators and column index generators. Thisembodiment generates a line or vector of L1 addresses, and it mayalso generate addresses for a plurality of arrays of two or moredimensions. The above mentioned aspects and other features of theinvention are explained more fully in the following descriptiontaken in connection with the accompanying drawings inwhich Referring to FIG. 1, there is shown a block diagram ofa Macro Function Signal Processor MFSP 10 illustrating anoverall system in which an intelligent memory 12 may be usedcomprising an array transformation address generator implementationof the present invention. More particularly, theintelligent memory 12 may have a plurality of intelligentports 14 22, although in the MFSP 10 embodiment describedherein two of the ports 14 and 22 are simply serving asdirect memory access DMA ports known to one skilled in theart. Portl 16, port2 18 and port3 20 are the intelligentports in the system of FIG. 1, primarily because of theirability to execute addressing sequences based on an arraytransformation operator while completely hiding data attributeconsiderations from an arithmetic unit 38. In addition to the intelligent memory 12, the MFSP 10comprises the arithmetic unit 38, a control processor 32,a node control unit 24, a System I O unit 40, an I Bus 26,an S Bus 28 and an A Bus 30. Intelligent port2 18 andintelligent port3 20 of the intelligent memory 12 each have32 bit direct connections to inputs of the arithmetic unit 38and a 64 bit output of the arithmetic unit 38 connecting tointelligent portl 16, thereby providing the means for streamingdata to and from the arithmetic unit 38. The A bus 30not only interconnects the three intelligent ports 16 20, but in addition serves as the MFSP 10 internal control bus interconnectinga 2 port RAM 34 of control processor 32 and thearithmetic unit 38. The control processor 32 comprises the2 port RAM 34 and a command interpreter 36 for interpretinginstructions and setting up the intelligent memory 12 andthe arithmetic unit 38 for execution of said instructions.The system bus, S Bus 28, interconnects a plurality of unitsincluding the node control unit 24, port0 14, port4 22,2 port RAM 34, command interpreter 36, arithmetic unit 38and system I O unit 40. DMA port0 14 is connected to thenode control unit 24 via the I Bus 26. The node controlunit 24 provides an interface between networks of high speedbusses in a distributed multiprocessor and a processor orother device such as the MFSP 10. DMA port4 24 has a direct32 bit connection to the system I O unit 40 for systemapplication I O information transfer. Referring now to FIG. 2, there is shown a block diagramof the intelligent memory 12 comprising five memory banks52 60, an arbitration and switching network 62 and a pluralityof ports 14 22, including the three intelligent ports 16 20and two DMA ports. 14 and 22. The arbitration and switchingnetwork 62 directs the flow of data between the ports 14 22and the memory banks 52 60 it provides an 88 bit wide, 5 X 5crossbar switch with arbitration logic for the five inputs ports and five outputs memory banks . Although a particular embodiment of the intelligent memory is describedhere for the MFSP 10, the invention is not limited to aspecific number of memory banks nor to a specific numberof intelligent ports nor to a specific size crossbar switch. Still referring to FIG. 2, the 5 X 5 crossbar handles 64bits for data, 24 bits for address and control from each ofthe ports 14 22. The arbitration logic resolves conflictsbetween the ports 14 22. If more than one port requests thesame bank of memory, the arbitration logic holds off the lower fixed priority port until the higher priority portcompletes its transfer. Arbitration is performed on a cycleby cycle basis. Four of the memory banks, bank0 52, bankl54, bank2 56 and bank3 58 are random access memories RAM ,each organized as 64K words by 64 bits. Memory bank4 60 isa read only memory ROM organized as 16K words by 64 bits.Two of the RAM memory banks 52, 58 are used primarily byport2 18 and port3 20 which are primarily used as READ ports.The other two RAM memory banks are scratch pad areas ofmemory and as such are used primarily for storing intermediatevalues via portl 16 which is primarily used as a WRITE port.ROM memory bank 60 stores constants and approximation tablesfor use during the operation of various macro functions.The DMA ports 14 and 22 act as an interface between the IBus 26 or the system I O unit 40 and the intelligent memory12 for the purpose of transferring large blocks of data the blocks of transferred data reside in consecutive locationsin the intelligent memory 12. The DMA ports 14 and 22 alsointerface with the S Bus 28 for control and status, the IBus 26 or the system I O unit 40 for transfer block dataaccesses external to the intelligent memory 12 and to thearbitration and switching network for transfer block dataaccesses to the intelligent memory 12. The intelligent ports, port1 16, port2 18 and port3 20,have independent controls to address and format each data element. Each port s setup parameters describe the shape ofthe packed data, where it is to be found i.e. base address ,and the method of access i.e. read write, transposed,reversed, etc. . When a port is started, it begins accessingthe first element of the described data and continues untilall data is read or written regardless of errors. The readports and write ports are identical except for port ID bitsfor determining the port s function. Referring now to FIG. 3, there is shown a block diagramof one of the intelligent memory ports 16 20 comprising anaddress generator 100, a memory controller 102 and a dataformatter 104. The address generator 100 produces addressesto access a data array in memory banks 59 so that the dataarray can appear in various convenient shapes for arithmeticunit 38 manipulation. The data formatter 104 acts as a datatranslator between the memory banks 59 and the arithmetic unit 38. Data is packed into 64 bit words in the memorybank 59. Packed data is unpacked and left justified in thedata formatter 104 prior to its use in arithmetic unit 38.The memory controller 102 provides control for the addressgenerator 100 and the data formatter 104, as well as providing control line interfaces to the arithmetic unit 38. Inaddition, the memory controller 102 is coupled to the arbitrationand switching network 62 and it initiates and controlsall memory accesses of an intelligent memory port. The intelligent memory 12 requires a small set ofparameters to execute any addressing sequence required by ahigh level signal processing language such as a Macro FunctionLanguage MFL described hereinbelow. These parameters havebeen integrated into a single addressing operator called anarray transformation that directly specifies the hardwarecontrol parameters from the signal processing language syntax.The address generator 100 implements the address functionsspecified by the array transformation. A pair of 16 bitcontrol words, the displacement control word 80 and lengthcontrol word 90, as shown in FIGS. 4A and 4B and describedhereinbelow, contain array transformation parameters andinitialize address registers within the address generator 100of any one of the intelligent ports 16 20 which then proceedsto execute memory address sequences specified by the arraytransformation. Prior to describing further the structure and operationof the invention in conjunction with the drawings, it isnecessary at this point to describe the array transformationoperator and certain aspects of the language used to specifythe parameters in the array transformation in order tounderstand the invention. The address generator 100 of theintelligent memory 12 as previously noted is functionallyspecified by the array transformation operator. The word operator is used here in the general mathematical sense ofan entity that transforms an input into an output accordingto the definition of the operator. The input and output areboth arrays, hence the name array transformation. Thisoperator describes array addressing in terms of a factoredseries of nested addressing sequences. An array transformationcomprises ten parameters for specifying an operation andhas the following syntax which is described below An intelligent memory 12 becomes possible when thetechnique of instruction factoring is used in conjunction with the separation of data parameters from the processing program.Instructions are factored into control operators, variablefunctions, array modifiers, and operands. Each of these withthe exception of functions has a significant effect upon memoryoperation. Control operators act as an addressing control modeto determine the sequence s of applying operand data to thearithmetic unit 38. Control operators specify relationshipsbetween array transformations such as length parameters. Variablefunctions specify the arithmetic and logical operations tobe performed on the elements fetched from memory. Array modifiersalter the normal addressing mode specified by the controloperator in use. Operands refer to the specific data to be used. When these instruction parameters are intentionally separatedfrom the parameters of data, the data parameters can be maintainedin a data descriptor. A data descriptor would consist of acollection of information describing the variable operands suchas data type, format and location. At run time, a program referencesan operand through the variable s descriptor. Dynamicchanges in data shape can be handled with no changes affectingthe program. One important requirement of an intelligent memoryis the treatment of an entire variable data array as a singleoperand. Consequently, the location of the data is determinedby a base address or an initial reference point which referencesthe initial element of the array of data. Signal processing algorithms are conveniently expressed in the language of matrix mathematics. For this reason, MFLis an array oriented language. Most variables in MFL programsdenote many elements of related data to be treated as singleentities. Most operations are defined directly on arrayswithout requiring item by item statements. MFL arrays takethe form of vectors, matrices and blocks. Referencing anindividual element of an array requires one, two or threenumbers called indices to mark its position in the array. A vector is an array whose elements are selected by asingle index. In other words, a vector has one coordinateand is considered to be a collection of elements arranged ina line. The number of elements in this line is called thelength of the vector. A null vector is a vector containingno elements. The length of a null vector is zero. A matrix is an array whose elements are selected by twoindices. It has two coordinates and is considered to be acollection of elements arranged in a rectangle. The numberof elements in each row is called the row length. The positionof an element along the row coordinate is called therow position or the column number. The number of elementsin each column is called the column length. The position ofan element along the column coordinate is called the columnposition or row number. Together, the row length I andcolumn length J constitute the shape of the matrix. Theshape is written J I. In some applications the matrix has a direct correspondenceto some physical reality such as the data derivedfrom an array of pixels which represent a planar image. Inthese cases the properties of a matrix are directly applicableto the processing. In other cases the matrix is simply aconvenience for purposes of processing. In many signalprocessing operations, a matrix is merely a collection ofvectors. The shape is consistent with the number of rowvectors and the length of each vector which is equivalentto the number of columns . The processing requires an iterativeuse of the vector set using and modifying one vector ata time. Consequently the usual interpretation of an arraymodifier is to apply it to each row vector rather than tothe entire array or matrix. Of course it is sometimes necessaryto modify the complete array as well. In this case thearray can be considered as a single long vector. A block is an array whose elements are selected by threeindices. It has three coordinates and is considered to be acollection of elements arranged in a set of matrices. Ablock uses the row and column terminology defined previouslyfor matrices. In addition, the number of matrices in theblock K is called the depth of the block. The position ofan element along this coordinate is called the depth positionor the matrix number. Together, the row length, columnlength and depth constitute the shape of the block. The shape of the block is written K J I. To illustrate the concept of factored addressing, thefollowing example qualitatively describes array transpositionin terms of factored addressing. When a matrix in row majororder is read by columns instead, the output will be a matrixwith rows consisting of columns from the input array. Theoutput array is of rank two, implying that the procedure mustrequire two displacement sequences. Referring now to FIG. 5, let I equal the length of rowsin the input array and let J equal the length of columns.The array transformation is described by the followingsequences The sequences illustrated in the preceding example maybe generalized into a procedural definition of the arraytransformation In a Macro Function Language MFL , an array transformationon an input array C is specified by ten parameterswritten directly below the name of the array and its data descriptor according to the following syntax Referring now to FIG 6, the boundary mode B parameterof an array transformation sets a geometrical context forthe displacements and lengths. The boundary mode determinesthe action of the address generator 100 if a given displacementresults in an address that falls outside the boundariesof the array. The boundary modes are as follows Displacements of an array transformation are iterativelyadded to an initial point to generate addresses in a regularsequence. The displacements are defined as pairs of numbersrepresenting generalized spacing on a two dimensional surface,thereby facilitating detection of the endpoints of each rowand column of a matrix. This representation is appropriatefor most signal processing macros. If desired, the conceptmay be extended to n tuples for general displacements on ann dimensional array. Displacements on arrays may be writtenas complex numbers where the imaginary part is the displacementin the row direction and the real part is the displacementin the column direction. Real number displacements are inthe row direction with no displacement in the column direction.Either form may be used with vectors, matrices and blocks.Symbols may also be used. As shown in FIG. 7, i defines aunit displacement to the right across the row direction, j defines a unit displacement down the column direction, and k defines a unit displacement into the depth direction.Displacements by multiples of either i, j or k are indicatedby preceding the symbol with the size of the displacement.For example, 5j denotes a displacement by five points in thenegative column direction. A general displacement through a block requires a tripletof numbers in a particular form e.g. depth column row . Formost applications, the k direction does not require the samelevel of flexibility given to the j and i directions. Dataformed into a three dimensional block usually can be treatedas a set of matrices. In these instances, two dimensionaldisplacements on each matrix along with sequential accessingof each matrix in the block are suffficient. As a result,displacement triplets through a block are not always directlysupported in hardware. However, devices implementing largern tuples might be advantageous for some applications. Avariable displacement value may be stored in a co operand tothe array transformation. Presence of an explicit value inthe co operand is indicated by a d symbol in the correspondingdisplacement of the array transformation. The d is used for user defined variable, and may also be definedby a translator in order to insert a non coded constant intothe appropriate register of the address generator 100. Thedisplacements notation of an array transformation along with their interpretation in terms of 1 through 4 are summarizedas follows The instruction loading time is reduced by assigningcodes to the most frequently required displacements. Onepossibility is to choose three bit codes for i, j, k, or0. The eighth code is for d , to signify that the displacementvalue is a separate complex number sent by the commandinterpreter 36. All variable displacements and constantsnot equal to i, j, k, or 0 are sent to the address generator100 as d s. In a two dimensional address generator,each d is replaced with a complex number denoting a generaldisplacement in the combined i and j directions. If eitherthe real or imaginary part is zero, the displacement issolely in the i or j direction respectively. k displacementsof the form Zk are specified as Z x Jj, on an array reshaped to K x J I. Hardware directly supporting thefull three dimensional representation would require d s inthe form of triplets. With the three bit codes, four displacementsand the initial point can be placed into a single16 bit word as shown in FIG. 4A. Referring now to FIG. 8 and FIG. 9, the initial pointis a displacement from 0 0 0, the upper left corner of thearray. For negative values, its location depends on theboundary mode. FIGS. 8 and 9 compare the different locationsof some initial points for wrap around and zero fill.For wrap around, the displacements to a few of the cornersof a block are as follows Lengths of an array transformation are real integersindicating the number of times a displacement is performedand the resulting shape of the array. Several mnemonics areprovided to specify output lengths in terms of the input shape of the array. A capital letter K indicates thedepth, J indicates the column length and I indicates therow length of the input array. Other numeric lengths mustbe written explicitly in the transformation if they areconstant and in a co operand if they are variable in a formsimilar to explicit displacements. For most numerical applications, two ports simultaneouslyaccess data to create a pair of input streams for a dyadicfunction. If a displacement must occur as many times asnecessary to match the corresponding displacements of theother input argument to a dyadic function, the number 1 iswritten. This symbol may be overwritten at run time by thecommand interpreter 36 with the appropriate length to matchthe other argument s array transformation or portl 16 andport2 18 can monitor the corresponding port length to determinethe replacement length dynamically. If the two arraytransformations have corresponding lengths equal to one, nodisplacement occurs for the sequence. This is how a controloperator becomes two coupled array transformations. A displacement may be specified to continue until aboundary of the array is encountered. The length S, meaning stop on boundary, is used for this case. In wrap aroundmode, if length m is set to S, displacements by Δm continueuntil a m encounters a boundary. In zero fill mode, displacementsby m continue until any lower level displacement encounters a boundary. When stop on boundary is used as a length parameter ofa port addressing one of the input data streams of a dyadicfunction, the corresponding length in the other port must be 1 , meaning repeat until the other array stops on its length. The following summarizes the array transformation lengthsymbols The following examples show a few simple forms of arrayoperations possible with array transformations. Each exampleis given in terms of a Macro Function Language MFL syntax.The array transformation is applied to an array B or C ofsome sample shape and type contained in its data descriptor.Below the array transformation is written the data descriptorof the output array from the transformation. The parentheses enclosing this information indicate that it is a responsefrom the intelligent memory 12. Several conventions may be used to abbreviate arraytransformations as follows Returning now to the description of the structure andoperation of the invention, and referring now to FIG. 10,there is shown a block diagram of the address generator 100,which provides an address 130 for its intelligent port eachmachine cycle. The address generator 100 comprises a microsequencer 122 along with its control store 120, an indicesgenerator 111 comprising two matrix access chips MAC 110and 112, an address translator 114, a multiplier 118 and a PBus 128 for information transfer within the address generator100. The matrix access chips MAC 110 and 112 provide row and column indices specified by the parameters of an arraytransformation which are loaded into MAC 110, 112 via the16 bit displacement control word 80 shown in FIG. 4A and the16 bit length control word 90 shown in FIG. 4B for addressingeach and every data element of an array. This pair of 16 bit control words containing arraytransformation parameters shown in FIG. 4A and FIG. 4Binitialize address registers within the address generator100 of any one of the intelligent ports 16 20 which thenproceeds to execute memory address sequences specified bythe array transformation. The displacement control word 80as shown in FIG. 4A has six fields. Five of these fieldsare identical and contain 3 bit codes for specifying each ofthe displacement parameters, delta 4 through delta 0, of anarray transformation. The other field is a 1 bit fractionalfield F which when set to a 1 indicates that the leastsignificant 5 bits of a 16 bit data bus are used to supportfractional displacement. Table 1 lists the eight functionsavailable for most of the delta fields except for the Pfunction . The length control word 90 as shown in FIG. 4B has sixfields. Four of these fields, length 4 through length 1,are identical and contain 3 bit codes for specifying each ofthe length parameters of an array transformation. The mode field is also 3 bits and the Boundary B field is 1 bit. Each of the length fields has eight possible functionsand Table 2 lists these functions and their definitions.The mode field defines the modes of operation within theaddress generator 100 of the matrix access chips 110, 112,and Table 3 lists the eight modes. The boundary fieldbit, B, determines the response of the intelligent ports16, 18, 20 when a boundary condition is encountered. Whenset to 0 the port performs a zero fill mode. The boundarymodes are described herein and illustrated in FIG. 6. Each MAC device 110, 112 may be implemented with a 180pin, 7500 gate, CMOS gate array technology. The addresstranslator 114 is coupled to the MAC 110 and 112 and themultiplier 118. The multiplier 118 may be embodied bymodel IDT7217L multiplier manufactured by Integrated DeviceTechnology, Inc. of 3236 Scott Boulevard, Santa Clara, CA95051. The address translator 114 converts the row andcolumn indices to the 30 bit address 130 which points tothe location of the most significant bit of a data elementin the intelligent memory 12. The multiplexer 116 can becontrolled so that row and column indices are multipliedtogether to produce FFT coefficients. The address translatormay be implemented with a 144 pin, 5700 gate, CMOSgate array technology. The microsequencer 122 and itsassociated control store 120 directly control index generationin the MAC 110 and 112 and provide control signals for data flow within the entire intelligent memory 12 pipeline.The microsequencer may be implemented with an AS890 sequencermanufactured by Texas Instruments Incorporated of Dallas,Texas 75265. The MAC 110, 112, devices together with themicrosequencer 122, constitute the bulk of the intelligence of the Ports 16, 18 and 20. The partitioning of the MAC 110, 112 logic provides aslice architecture that allows each MAC 11Q, 112 to independentlyaddress two dimensional variables specified by anarray transformation. The intelligent memory architecturesupports two independent address streams one at a time, withswitching between the streams under microcode control 124 asdirected by the 3 mode bits in the length control word 90.Hence, the 3 mode bits provide eight modes of operationsummarized in Table 3 for the MAC 110, 112 and are as follows MAC DUPLEX Mode refers to the operation of each MAC independently,each producing its own address sequence, while MACSIMPLEX Mode refers to the operation of the MAC 110, 112devices together to produce a single address sequence.Simplex mode comprises a full simplex mode and a half simplexmode. Full simplex mode uses both MACs 110, 112 but halfsimplex mode uses only the lower MAC 112. Half simplex modeis only an optimization for speed that comes from microcodepartitioning. Duplex mode contains submodes called flushedduplex mode and non flushed duplex mode each having three variations for a scalar, vector, and matrix. Flushed modedata are routed back into Address Generator 100 through the PBUS 128, whereas nonflushed mode data go to the AU 38 or theaddress directs where AU 38 data goes in RAM memory 50.Scalar, vector, and matrix modes determine when the rest ofintelligent memory services the indices generated by theother MAC. The architecture of the MAC 110, 112 devices allowsdirect support of array transformation statements and MAC110, 112 devices are cascaded within the indices generator111 to handle up to four dimension variables. The idea ofdisplacement and length parameters as described hereinbeforeis the basis of the array transformation statements. FIG. 11shows the location of the array transformation parameterswithin the cascaded upper and lower matrix access chips 110,112 of the indices generator 111. Array transformationssupported by the pair of MAC 110, 112 devices allow for ageneric method of generating an address sequence for a rankfour output shape array from a rank two input shape array. Referring now to FIG. 11, FIG. 12 and FIG. 13, there isshown the functional structure of a MAC 110, 112 device.Within each MAC 110, 112 there are four index generators140 143 comprising an upper row and column index pair 140,141 and a lower row and column index pair 142, 143. Eachindex generator contains a 16 bit base working register 162 and a 16 bit displacement register 160 as shown in FIG. 12.Each of these two registers can be written to and read fromvia the A BUS 30 prior to instruction execution. The data in the displacement register 160 of the lowerMAC 112 once loaded from the CI 36, will not change. Alldata held in the MAC 110, 112 will be 16 bit two s complementand loaded as integers. When the fractional addressingmode is selected, the shifters 148, 149 will shift the data5 bits to the right sign extended before the index is produced.When the fractional addressing mode is not selectedthen all loaded data is in integer format and the shiftersare transparent. The comparators 146, 147 make running comparisons betweenthe current index and the contents of the two boundary registers,column length register 144 and row length register145. The running comparison allows the circuitry to determinewhen the current index has exceeded the boundary limitsof the Input Shape via the status bits in the conditioncode register and MUX 158. The Input Shape is defined bythe contents of the column length register 144 and row lengthregister 145. The upper length counter 150 and lower lengthcounter 151 are used to count the number of displacementincrements imposed on the contents of the 0 register containedin the same level. As each displacement is added tothe current content of 0 the associated length counter within that level is decremented. Negative sign detectioncircuits generate status 152, 153 bits which flag to themicrosequencer 122 the boundary of the output shape. Still referring to FIG. 13 showing a block diagram ofone of the index generators 140 143, both the displacementregister 160 and the working register 162 have four clearand preset inputs 171 174. Two of these are dedicated tothe selective clears or presets of the upper 15 bits of theregister. The other two preset and clear inputs are dedicatedto the least significant bit LSB of the register.Hence, these registers 160 and 162 are asynchronously presetand cleared to one of four default values 0, 1, 1, 2. Eachone of the index generators 140 143 has a 16 bit complementcapability performed by exclusive or gates 168 and the complement175 signal. Also, there is a 16 bit fast carryadder 170 complete with carry input 176. This architectureallows the uncomplemented or complemented contents of thedisplacement register 160 or column length registers 144and row length register 145 to be added to the currentcontent of the working register 162. The upper and lower level registers in the index generators140 143 in each MAC 110, 112 are distinguished by theprefix U and L respectively. Thus, the displacement register160 and the working register 162 in the index generator ofthe MAC 110, 112 devices have the following designations Referring now to FIG. 14, there is shown a block diagramof the length counter 150, 151. The length number register 180contains static data i.e., not updated during execution andacts as a reference for re initializing the length countnumber register 182. The length count number register 182contains a current count of the number of displacements thatan index generator 140 143 will invoke in order to generate aone dimension access sequence. Each level of a MAC 110, 112handles one dimension. Thus, the MAC 110, 112 length registersare referred to as follows The length counter 150, 151 decrements the current contentof the length count number register 182 by one when a validindex offset pair has been generated. If the current countis negative then it stays negative even after several decrementsexecuted due to condition code pipeline delay. This gives thecircuitry more time to catch the end condition. Both thelength number and count number registers 180 and 182 containedin a length counter 150, 151 allow read and write accessover the bus in a similar manner as the index generator140 143. However, these registers 180 and 182 are notindependently writable because this function is not required. Referring now to FIG. 15, there is shown a matrix witha plurality of zones identified outside of its boundaries..The row length 200 and column length 202 comprise the INPUTSHAPE . The top left hand corner is regarded as the zeroreference point. An initial displacement 0 is an offsetfrom this reference point. The input shape or matrix consistsof the number of rows and columns of data elements and isthus limited to two dimensions. Each data element is uniquelydefined in terms of its row index and column index. Thereference point is therefore defined as 0,0 . An element in zones 1, 4 or 7 is said to have exceeded the lower rowboundary of the input shape. The column index of any suchelements will be negative. The MAC 110, 112 are thereforerequired to handle negative numbers via the two s complementnotation. The MAC 110, 112 supplies to the microsequencer122 a status bit 157 sourced from the sign bit of the currentcolumn index.An element in zones 1, 2 or 3 is said to haveexceeded the lower column boundary of the input shape ormatrix. The row index of any such elements will be negative.The MAC 110, 112 supplies to the microsequencer 122 a statusbit sourced from the sign bit of the current row index. An element in zones 3, 6 or 9 is said to have exceededthe upper row boundary of the input shape or matrix. Anysuch elements will have positive column indices but theinteger value of the column length 202 will be greater thanor equal to the row length 200. A running comparison is performed between the currentcolumn index of each level and the column length of the inputshape. The MAC 110, 112 supplies to the microsequencer 122a status bit 154 which indicates the result of this runningcomparison. An element in zones 7, 8 or 9 is said to have exceededthe upper column boundary of the input shape or matrix. Anysuch elements will have positive row indices of integer valuegreater than or equal to the column length. A running comparison is performed between the current row index of eachlevel and the column length. The MAC 110, 112 supplies tothe microsequencer a status bit 155 which indicates theresult of this running comparison. Referring now to FIG. 16, in addition to FIGs. 11 14,a MAC 112 is required to generate a sequence of elements inresponse to an array transformation where each element isspecified by a row index and a column index pair which willdefine an output shape. Movement from one element to thenext element in a sequence is accomplished by specifying thecontents of a row and column displacement register 160 andadding it to the contents of the current working register 162and decrementing the length counter 182 in a MAC 112. Thelower level of the MAC 112 is used for this one dimensionalmovement. The displacement register 160 in the lower leveland the working register 162 in lower level are loaded withthe 1 displacement index parameter of the array transformation.In the example shown in FIG. 16 the workingregister 162 initially is loaded indirectly by the commandinterpreter 36 prior to going into execution mode with theindex of point 1 as defined by a 0 in an array transformation.When a movement in the one dimension specifiedby the contents of the lower level displacement register160 comes to an end index 6 in FIG. 16 and when the lengthcounter is negative then the following occurs the displacement register 160 in the upper level of the same MAC 112 willcontain the 2 displacement index of the array transformationrequired to move the current index of that level to the nextlinear sequence i.e. from 1 to 7 in FIG. 16 . The result,after being loaded back into the lower level working register162 and validated, will be down loaded into the lower levelworking register 162 of the MAC 112 and the length counternumber LCN register 182 will be re loaded from the contentsof the length number LN register 180. The lower level ofMAC 112 is then ready to once more complete a linear sequencefrom 7 to 12 in FIG. 16 as specified by the 1 displacementindex parameter. This process corresponds to a two dimensionaladdress sequence since 1 and 2 will not be altered also,this description can be extended to higher order addresssequences up to four dimensions in the present embodiment.Each time a new dimension is invoked, transfer of data froman upper level to a lower level of MAC 110, 112 hardware isrequired. It is therefore a requirement of the MAC 110, 112that each 0 working register 162 have access from thelevel above which includes upper MAC 110 to lower MAC 112transfers. Referring now to FIG. 16 and FIG. 17, the indexes 5, 6and 12 as shown in FIG. 16 are said to be outside the inputshape or out of bounds. The occurrence of these indiceswill be handled differently depending on the boundary mode selected. Each level of MAC 110, 112 contains a lengthnumber register 180 which stores the length control word asshown in FIG. 4B. The length number register 180 is loadablefrom the CI 36 during initialization and one bit of thiscontrol word is allocated to boundary mode B. The twomodes selectable via this bit are wrap around and zero fill .Each invokes different system responses when the currentindex is out of bound indicated by the boundary statusbits . In zero fill mode an out of bounds index is valid but the data obtained from memory will be substituted byzero. In a write port the data would simply not be writtento memory. In wrap around mode indices outside the boundaryare regarded as invalid. It is a requirement in this modethat if a single displacement results in an index outsidethe input shape matrix it must be adjusted to point to anindex inside the input shape. For index adjustment of theexample shown in FIG. 17 to go from 24 to 19, it is requiredthat the row length be subtracted from the column index. Togo from 4 to 40 requires column length to be subtracted fromthe row index. In order to support this adjustment requirement,the MAC 110, 112 architecture allows the selectivesubtraction of the content of the boundary length registers144, 145 in each level of the MAC 110, 112. Referring now to FIG. 10, the MAC 110, 112 devices producerow and column indices representing offsets from an initial reference or starting point 0 as specified in anarray transformation. The Address Translator AT 114 togetherwith the multiplier 118 converts this offset into a 30bit address 130. In order to calculate this address, theAT 114 must know the base address, 0 initial startingpoint , the row length L1 L4 number of elements in a row ,and the packing factor of the data element number of bitsthat comprise the data element . These values are loadedinto the AT 114 prior to current instruction execution bythe command interpreter 36 via the A BUS 30. The AT 114registers are double banked, allowing the command interpreter36 to set up for the next instruction while the AT 114 isexecuting the current instruction. The address translator 114 essentially converts a rowindex and column index identifying a location of data to alinear address to identify the location of the element ofdata. The AT 114 supplies the row length 139 to the multiplier118, which then multiplies the row index 137 offset bythe row length 139 and supplies the result back to the AT114. The AT 114 adds this product with the column index 138offset to obtain the total index offset from the initialstarting point. The AT 114 converts this index offset to aphysical offset by shifting the index offset by an amountequal to the packing factor effectively multiplying by thenumber of bits in the data element. This address offset is then added to the base address to obtain the 30 bit address130 for the data element. This 30 bit address 130 now pointsto the most significant bit of the data element to be accessed.An alternate path exists for generating Fast Fourier Transform FFT coefficient addresses. This path replaces row lengthby a column index multiplier 167 and the sum of the productand column index by the product itself which is the productof the row and column index . The product of the row andcolumn index represents a linear offset into the lineartable of complex exponentials stored in the ROM memory bank60. The Digital Fourier Transform DFT coefficient matrixis shown in FIG. 18 it illustrates that the exponent of wis the product of the row and column index. Referring now to FIG. 3, the data formatter DF 104may be implemented with two identical 180 pin, 2500 gate,CMOS gate arrays, each having a 32 bit slice and may beconfigured either as. Read or Write data formatters. Thisconfiguration is controlled by hardwired connections. As a Read formatter, the data formatter 104 reads 64bit packed data from the Memory banks 59, unpacks the dataelement, shifts and masks all unnecessary bits to zero, andpresents to the AU 38 a left justified data element. Shiftamounts and mask parameters i.e. packing factor etc. werepreviously loaded into the data formatter 104 by the commandinterpreter 36. As in the address translator 114, data formatter 104 control registers are also double banked. Allnormalization calculations are performed by the command interpreter36, which in turn informs the DF 104 of the resultsvia the shift amount. As a Write formatter, the data formatter 104 is presentedleft justified data elements from the arithmetic unit 38.The data formatter 104 must perform a read modify writeoperation, packing this new data element among the unchangeddata elements of the 64 bit word in intelligent memory 12.The control circuitry of intelligent memory 12 is such thata read for the Read modify write occurs only if the 64 bitboundary has been crossed. This eliminates unnecessary memoryreads by the write port. Still referring to FIG. 3 there is shown the MemoryController MC 102 which may be implemented with a 144 pin,3500 gate, CMOS gate array and provides overall centralcontrol for the intelligent memory 12 pipeline. Inaddition, it provides interfaces to the command interpreter36, arithmetic unit 38 and the arbitration and switchingnetwork 62. The A BUS 30 interface of the memory controller 102decodes the A BUS address, providing chip selects as required,and acts upon or distributes all A BUS control signals asrequired. The memory controller 102 also controls bidirectionalbuffers for the A BUS 30 data path. This method allows each intelligent memory 16 20 port to present onlyone load to the A BUS 30, and allows all decode circuitry toreside in one central location for each of said ports 16 20. The AU interface supplies data ready and data requestcontrol lines to the arithmetic unit 38. These lines areused to control data flow between the AU 38 and an intelligentport 16, 18, 20. Based on the state of these control lines,the memory controller 102 has the ability to selectivelystart and stop the intelligent port pipeline as required. The memory controller 102 also provides the intelligentports interface to the arbitration and switching network 62.The memory controller 102 receives the 30 bit address 130from the address generator 100, and decides if a memoryaccess is necessary if the 64 bit word boundary has beencrossed . If a memory access is required, the memory controller102 generates a 3 bit BANK REQUEST 93 code to thearbitration and switching network 62. The memory controller102 then looks for the bank acknowledge 94 signal from thearbitration logic, stopping the intelligent port pipelineand notifying the arithmetic unit 38 if the port has lostmemory arbitration. Thus the memory controller 102 controlsthe overall flow of data through the intelligent port pipeline,and between the intelligent port 16 20, the arithmetic unit38 and the memory banks 52 60. This concludes the description of the preferred embodiment. However, many modifications and alterations would be obviousto one of ordinary skill in the art without departing fromthe spirit and the scope of the inventive concept. Forexample, the number of RAM or ROM storage locations in theintelligent memory 12 may vary and the number of intelligentports may vary depending on system applications. Also, themultiplier 118 in the address generator 100 could be removedif memory chips with two dimensional structures were availableexternally for row and column indices to index into directlyinstead of the current approach of producing a linear addressdisplacement first and then breaking it down inside memorychips into row and column addresses. In this case, FFTcoefficients could be generated by using variable deltas as provided for in duplex mode. In addition, the parametersof the array. transformation and supporting hardware embodimentcan be expanded to specify additional displacement sequencesfor arrays of higher rank.