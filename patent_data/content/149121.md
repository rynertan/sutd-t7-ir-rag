# A METHOD FOR CONVERTING AN IMAGE FROM A RUN END OR RUN LENGTH REPRESENTATION TO A BIT MAP

## Claims
Verfahren zum Umwandeln ein bin√§res Bild darstellender Daten von einer Laufdarstellungsform in eine Bitkartenform, gekennzeichnet durch die Schritte

## Description
The present invention relates to digital image processing methods and more particularly to methods for converting an image from a run end or run length representation to a bit map. There are many image manipulation methods in the prior art. As examples US Patent 4,297,727 to Ogawa et al Facsimile Apparatus and US Patent 4,233,601 to Hankins et al Display System may be cited. In these patents methods for converting run representations of an image to a bit map form are mentioned. According to these methods all of the pixture elements,black as well as white pels, are generated. None of the prior art teach or suggest the method of the present invention in which only black bits are stored during conversion, thereby obtaining a clear improvement in efficiency. According to the present invention data representing a binary image is converted from run representations to bit map form by a method comprising the steps of initializing to a first binary value all the bits in an output area formed by lines and where the bit map is to be formed, storing data comprising a plurality of pairs of run representations of said image in a butter, each of said pairs defining the beginmng and the end of a run of image bits of a second binary value, converting each of said pairs of run representations stored in said buffer successively to strings of image bits of said second binary value, each string corresponding to a said run of image bits of a second binary value and transferring said strings of image bits of said second binary value to said output area into positions offset in accordance with the respective beginning positions of said strings as indicated by said pairs of run representations, such that said image data is converted to a bit map representation in said output without the need for creating and transfering strings of image bits of said first binary value. The foregoing and other objects, features and advantages of the invention, which is defined in the attached claims, will be apparent from the more particular description of the preferred embodiments of the invention, as illustrated in the accompanying drawing. FIG. 1 is a chart showing run end representation of image data in accordance with the present invention. FIG. 2 is a chart showing the conversion formats and variables according to the present invention. FIG. 3 is a flow chart showing the conversion algorithm according to the present invention. FIG. 4.1, 4.2, 4.3, 4.4 and 4.5 is a flow chart of line initialization and pel data generation in accordance with the method of the present invention. In the drawing, like elements are designated with similar reference numbers, and identical elements in different specific embodiments are designated by identical reference numbers. The problem addressed by the present invention is that of quickly converting a binary image represented as a series of vectors of run ends or run lengths one vector for each line for image data into a bit image. A run end is the displacement in bits i.e. pels from the left edge of the image to the last pel in a run. The term run representation will be used in the description which follows to include run length and run end . The present invention uses a combination of techniques to produce code which is significantly faster than current methods. These techniques include The method is structured so that data on either or both edges of the coded input image may be ignored if desired, and either or both edges of the output image may be padded with pels which are either black or white, or are taken from the location where the output image is to be stored permitting insertion of a converted image which is not on byte boundaries into a larger image . This method has general application. This method may be used to generate an image from either run ends or run lengths. The description which follows will assume that run ends are supplied. To convert run lengths, a cumulative total of the run lengths processed would be kept. The bits making up the reconstructed image are assumed to be stored packed eight to a byte, with each line beginning and ending on a byte boundary. The lines are to be arranged sequentially in storage. Since it is possible to convert the image as if it were padded on either the right and or left edges with either zero or one bits or with the data which already exists in the output image, the reconstructed image actually does not have to start or stop on byte boundaries. It is also possible to skip coded data representing pels at the beginning and or end of the line by appropriate initializations. Referring to Figure 1, the structure of the run representation of image data will be described. A preferred embodiment uses a run end buffer for each line which contains a series of halfwords. The 16 bits in the halfword are adequate to represent images with widths up to 32K as positive displacements. The first halfword in each line buffer gives the number of bytes of run end data plus two bytes for the count i.e. the total number of bytes of data in the buffer this is followed by three zero run ends, an arbitrary number of pairs of white black run ends, and two additional copies of the last black run end. If the image row begins with a black run, the first white run end must be specified as zero. If the image row ends with a white run, the last black run end will be the same as the last white run end, so that we in fact have three copies of the last real run end. For example, if no skipping or padding is specified, and an output size of three lines of 32 pels each is specified, then the run end buffer containing the halfword entries Our implementation assumes that run end buffers for successive lines of image data are stored sequentially, with no intervening space. The procedure for converting a run end representation of a line of image data may be summarized as follows. The variables used in the conversion algorithm are listed in Table 1 below some of them are illustrated in Figure 2. For the purposes of this discussion, the most important variables are the byte of image data which is currently being constructed referred to as CUM the pointer to the run end data INPT the pointer to the run end data describing the right edge of the image ENDPT the pointer to the location where the output image line is to be stored OBUF the number of pels in the trimmed and padded output image line NCOL the number of pels which will have been accounted for in the run end buffer when all of the required input data has been processed DATEND the bit address such that when a run end is added to the address, the result is the bit address in storage where the run end is to occur START the number of bits represented in the run end buffer which are to be omitted from the right edge of the output image XSKIP the number of padding bits to be inserted on the left and right LFTPAD and RTPAD and the color of the padding bits to be inserted. In the case where the padding bits are to be taken from the preexisting output image, the color of the padding bits is referred to as DND , for do not disturb . Thus the color of the padding bits may be white, black, or DND. The width of an element of the run end buffer, expressed in bytes, is referred to as W. The conversion process makes use of two lookup tables, shown as SBLAK and EBLAK in the illustrations. Each of these tables con tains eight entries, one for each possible value of the number of leftover bits in a byte. The table entries in hexadecimal are SBLAk is used to start a black run by setting the bits beyond a white run end to one EBLAK is used to end a black run by clearing all bits beyond a black run end. It is possible to use the SBLAK table for both purposes, since if all of the low order bits in a byte are set, subtracting an SBLAK value would have the same effect as ANDing an EBLAK value. However, the EBLAK table is useful in the initializations, and since it does not require very much storage to keep the extra table, our implementation uses both tables. Note that it is possible to eliminate both tables by calculating the SBLAK values when they are needed via a logical right shift of the value 1 by the appropriate number of bits this is also a practical approach, particularly if the algorithm is altered so that the unit of image reconstruction i.e. the size of CUM is larger than a single byte. Figure 3 shows the basic procedure used to convert one or more lines of run end data. Note that if the padding is DND, then decoding NCOL bits of data with the last RTPAD of those bits being taken from the preexisting output image is equivalent to decoding NCOL RTPAD bits of data with no right padding this adjustment can be made before the loop to process lines. Ensuring that RTPAD is zero if the padding is DND simplifies the line initialization by eliminating tests for DND padding on all paths except one. The pointers to the run end buffer and the output image buffer are set up, and a loop is entered to process the lines one at a time. The address of the next run end buffer is saved, since INPT is mo dified during processing. Some initializations are performed, and then an inner loop is used to convert the run end data into pels. After that, if there are more lines to be converted, INPT is set to point to the next run end buffer and OBUF is incremented to point to the location where the next line of the output image is to be stored. Control then returns to the top of the loop. The initialization required before decoding one buffer of run end data is illustrated in Figures 4.1, 4.2, 4.3, and 4.4. Referring first to Figure 4.1, the initialization will be described. First, ENDPT is set to point to the byte beyond the end of the buffer. INPT is incremented to skip over the unit giving the length of the buffer and the three zeroes at the beginning of the buffer. CUM is set to zero. START is then set to contain a bit address such that when a run end is added to START, the result will be the bit address in the output buffer where the run ends. DATEND is set to the bit offset in the line described by the run end buffer where decoding is to stop. The value of RTPAD is later added to DATEND, so that a comparison of a run end with DATEND will indicate whether the end of the line has been reached. Next, ENDPT is moved so that it points to the first white run end whose succeeding black run end is less than DATEND. To do this, we decrement ENDPT so that ENDPT 2W points to the last white run end. We then determine whether the last black run end at ENDPT 3W is greater than or equal so DATEND. If so, we step ENDPT backwards two run ends at a time until it points to a white run end whose succeeding black run end is less than DATEND. Otherwise, the run end buffer represents a line which contains fewer pels than are needed to convert the image as requested. We therefore reset DATEND and RTPAD to convert all available runs and then fill in the additional space with pad bits of whatever color was specified for padding. If the pad color is DND, we decrement NCOL by the number of additional pad bits reset RTPAD to zero, just as we did before the loop to process the lines began. If it is possible to have lines of varying lengths in the run end buffers to be converted, it is advisable to restore the values of NCOL and RTPAD to what they were before the loop was entered before processing additional lines otherwise no converted line can contain more information than the shortest line previously converted. Note that at this point ENDPT points to the first white run end whose succeeding black run end is less than DATEND. We are now ready to clear storage in the output image for the converted data, and to modify the run end data so that the loop to convert the run ends will terminate correctly. This is done differently for the three cases where RTPAD is zero which is always true for DND padding , the padding is white, or the padding is black. Figure 4.2 shows the processing required for the first case, Figure 4.3 for the other two cases. Following this step is some additional processing described in Figure 4.4. In all cases we will save three run end values, to be restored after the inner loop is executed to reconstruct the pel data. The saving and restoring of run end data is not necessary for the algorithm if the calling function does not care if the run end data are modified, saving and restoring the data may be omitted. Note that at this point ENDPT points to the first white run end whose succeeding black run end is less than DATEND. The first two run ends indicated by ENDPT will therefore not be altered. The white run end at ENDPT 2W may or may not be less than DATEND the black run end at ENDPT 3W must be greater than or equal to DATEND. Figure 4.2 shows the steps required when there is no right padding. We first save the three run ends beginning at ENDPT 2W. Next we determine whether the black run end at ENDPT 3W is greater than DATEND If so, the run end is reset to DATEND i.e. the im age line described by the run end buffer is truncated and the preceding white run is tested against DATEND and reset to DATEND if it is greater. This completes the necessary modification of the input data. Slightly different procedures are required to set up the output buffer depending on whether the padding is DND or not. If not, then we must zero the number of bits indicated by NCOL beginning at the first bit of the byte pointed to by OBUF. This is done by zeroing as many whole bytes as necessary and then reading in the next byte which contains the bit following the last bit to be cleared and masking out as many bits as necessary. This modified byte is stored both in its original location and in a save area for use after the line has been converted. For DND padding, only NCOL LFTPAD RTPAD bits must be cleared, since the padding bits must be left intact. The first byte as well as the last byte containing bits to be cleared may contain bits which must be preserved. We begin by addressing the byte containing the first bit to be cleared. This byte is read into GUM, and the required number of low order bits are cleared. GUM will be stored back into the output image at the beginning of the first iteration of the inner loop. We then address the byte containing the bit beyond the last bit to be cleared. If it is the same byte that was read into CUM i.e. we have a very short line of real data to convert , we read in the original byte, clear the necessary number of high order bits, and perform a logical OR of the byte with CUM without altering CUM . The resulting byte has the middle bits where the converted data is to be inserted clear and the high and low order bits intact. This byte is stored into its original place in the output image and into the save area. If the first bit to be cleared and the first bit beyond the end of the bits to be cleared are in different bytes, we mask out the re quired number of high order bits in the second byte, storing the result into the output image and into the save area. We then zero any bytes between the two bytes already modified. Figure 4.3 shows the steps required to clear storage and modify the run end buffer for white or black padding. In either case, we must zero the number of bits indicated by NCOL beginning at the first bit of the byte pointed to by OBUF. As for the case when RTPAD 0 and the padding is not DND, this is done by zeroing as many whole bytes as necessary and then reading in the next byte which contains the bit following the last bit to be cleared and masking out as many bits as necessary. The modified byte is then stored both in its original location and in the save area. For white padding, we must determine whether the white run end at ENDPT 2W is less than DATEND. If it is, then the run end buffer represents a line which ends with a black run. We increment ENDPT by W so that END 2W will point to the data to be modified, and then save the three run ends beginning at ENDPT 2W. We truncate the black run end which describes the last black run in the line to DATEND i.e. to the beginning of the padding and then increment DATEND by RTPAD so that it gives the bit offset in the image line represented by the run end buffer of the right edge of the output line. This new value of DATEND is saved in place of the succeeding white and black run ends. If the white run end at ENDPT 2W is not less than DATEND, the the line ends with a white run. The three run ends at ENDPT 2W are saved. DATEND is increased by RTPAD and the resulting value replaces the last white run end and the succeeding black run end. If the padding is black, three run ends beginning at ENDPT 2W are saved. We then test to see whether the white run at ENDPT 2W is greater than DATEND. If so, it is replaced by DATEND the white run is truncated to the edge of the padding if not, it is not disturbed. DATEND is then increased by RTPAD. The new value of DATEND replaces the black run end at ENDPT 3W. This completes the clearing of the output buffer and the modification of the input buffer for all cases. Figure 4.4 illustrates the remaining initialization procedures. First, we determine whether the left edge is to be padded with black. If the left edge is to be padded with white or DND, the necessary work has already been done. If so, we fill the required number of complete bytes with X FF and load a byte into CUM which has the appropriate number of high order bits set. In all cases, LAST the pointer to the byte in the output image where CUM is to be stored is set to point to the byte containing the first bit following the left pad. We next skip over any unwanted data in the run end buffer. As long as the first black run end examined is less than the number of pels to be skipped, we can increment INPT to skip a white black run pair and go on to test the next black run end. When a black run end which is greater than XSKIP is found, the preceding white run end is examined. If it is also greater than XSKIP, we can proceed directly to the top of the inner loop. If the white run end is not greater than XSKIP, then the converted image data begins with a black run. All of the bits beyond the end of the left pad are set to one, and control passes to the section of the inner loop which processes a black run. Figure 4.5 illustrates the inner loop in the conversion process, which handles one white run and the succeeding black run. CUM is first stored in the proper place in the output image. The byte which contains the first bit of the black run following the white run being converted which may be the same byte is then read from its place in the output image, and the number of bits in the white run being converted which must appear in that byte is used to index into a lookup table. The result of the table lookup is added to CUM, setting all bits beyond the end of the white run to black. The storage of CUM on entry to the loop may be omitted if the byte to be read comes from the same address at which CUM is stored, but testing for this case and performing the branch saves very little time if the branch is taken and loses the time required for the test in the more common case where the test fails. To process the succeeding black run, we first determine whether that run ends within the byte currently being constructed. If so, we use the number of bits which come before the end of the black run in the byte to index into a lookup table and obtain a mask which clears all of the bits beyond the end of the run. We then test for the end of the line by comparing the black run end with DATEND. If the end of the line has been reached, we leave the loop otherwise we repeat to process another white run. If the black run does not end within the current byte, we store the current byte in its proper place in the output image, fill as many bytes with ones as necessary to get to the byte which contains the first bit beyond the end of the run, and use the lookup table from which the mask was obtained in the other case to get a byte with the required number of bits to get to the run end set to one and the remainder of the bits zeroed. We then test for the end of the line, leaving the loop if it has been reached or repeating the loop if it has not. After leaving the inner loop, we replace the byte containing the first bit beyond the end of the reconstructed image line by the logical OR of the value of that byte saved before the inner loop with the byte currently being reconstructed. The three saved run end values are restored to the run end buffer beginning at ENDPT 2W. Many variations on the basic conversion algorithm are possible. The processing may be simplified by requiring that some combination of the variables XSKIP, LFTPAD, and RTPAD are zero for example, if XSKIP is zero then the loop to skip run end data at the beginning of a line could be omitted , or by eliminating the option of DND padding. The precise format of the input run end buffer supplied affects some of the details of the implementation. Many of the operations outside of the inner loop are controlled by the assumptions made about the format of the input run end buffer and the output data required. The inner loop is relatively independent of these considerations the major variations within this loop would be the use of a different size unit of image data in place of CUM and or the use of a different procedure to reassemble the image data i.e. a shift procedure instead of a table lookup . Features of this method include the following By zeroing the output lines before processing begins, we avoid having to clear bytes in long white runs during the processing of those runs. Since a typical image contains large regions of all white pels, and since on most processors it is most efficient to clear large areas of storage, we reduce the complexity of processing a white run within the loop and clear the storage more efficiently by zeroing the lines before entering the loop. By adjusting the input data describing the end of the line, we eliminate the need for special tests during the processing of each run to see whether the run end extends beyond the end of the image line we are reconstructing, or whether we have run out of data. Elimination of these tests simplifies processing of the runs and allows the code to execute more rapidly. By adjusting the input data so that there will be a black run end at the end of every line, we eliminate the test for the end of the line for all white runs i.e. half of the time . This reduces the amount of testing required, resulting in fast code. By processing runs in pairs, we know at any point in the processing what color run we are working on. We can take advantage of that information in processing long white runs, by omitting any processing for white bytes since the output image has been cleared . Having separate paths for white and black runs also makes it convenient to test for the end of a line for only one color. By appropriate initializations, the input image can be trimmed and or padded during the conversion using this algorithm. It is possible to pad using previously existing data in the output image if desired, so that an image whose lines do not begin and end on byte boundaries may be inserted into a larger image without destroying data around the inserted image. This is done by ORing the edge bytes of the reconstructed image with the previously existing data. Table lookup of the black bits to be added to or removed from a byte of image data being reconstructed allows fast calculation of the reconstructed image. An alternate procedure for generating the black bits, using shifts of the hexadecimal value FFFFFFFF, may be as fast or faster on some machines. For long black runs, it is convenient to take advantage of the instructions available on many processors which fill a field of contiguous bytes rapidly. These factors are helpful in obtaining fast code. This function creates an image from runends. For each line, the runend buffer contains a series of halfwords the number of bytes of data two bytes for the count and two bytes for each runend , three zeroes, a number of pairs of white black runends, and two additional copies of the last black runend. The program embodying the present invention requires an area of storage to contain its variables. These variables are as follows The lookup tables sblacks and eblacks are initialized with the following hexadecimal values Since the language in which this program is written employs forward Polish notation, an end of statement symbol such as the in PL I is unnecessary in most cases. All array indices are expressed as offsets in bytes from the beginning of the array. The following subroutines is assumed to be available