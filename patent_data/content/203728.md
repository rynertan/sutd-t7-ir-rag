# GRAPHICS PICTURE ELEMENT DATA BYTE PROCESSOR

## Claims
Ein Prozessor 10 zur Bildverarbeitung, wobei die genannten Bilder durch Pixel, Bildelement Datenbytes, dargestellt sind, der folgendes umfa√üt

## Description
The present invention relates to a processor for processing picture element data bytes in a graphics processing system The primary consideration in graphical applications is execution of a screen update. When a single or host processor handles all graphic computations, the result typically is unacceptably long execution times. Distributed processing helps resolve this problem. The graphics processor is typically an array of processing elements controlled by the host processor. Prior art graphics processors have used either bit slice micro programmable machines or conventional microprocessors. The prior art architectures, however, had relatively arbitrarily limited the pixel picture element data byte length. An improvement in this architecture was effected by incorporating arithmetic logic units ALU in the frame buffer data stream, see Crow et al A Frame Buffer System with Enhanced Functionality in The SUN workstation architecture see Bechtolsheim et al High Performance Raster Graphics for Microcomputer Systems appearing in Both the architectures mentioned above have a constraint of predefined operation sets and pixel data format. These constraints are important. For example pixel data may contain red, green, blue and depth Z components of different length for some applications and may represent several bit planes for others. The operation set and data format can be different depending on the particular application. EP A 0 071 727 describes a data processor comprising a plurality of processor units including reconfigurable connections through a status bus, a microprogramming capability with dynamic logic array interpretation, and a multi level flexible interrupt management system. The processor units can be reconfigured programmably to operate independently, in lock step, or as pipelined processor units. The processor units are connected to data, control and status busses. In addition, external control, data and status interfaces are provided, connected through the respective corresponding busses to each of the processor units. These external interfaces are connected to all of the interconnections so to permit reconfiguration of the processor units. EP A 0 095 618 describes a memory system used in a display or printing system for displaying or printing a picture pattern by processing picture data obtained from a function generator. The memory system comprises memory planes for storing picture data, registers provided in one to one relationship with the memory planes for latching the picture data read from the memory planes, and arithmetic logic units provided in one to one relationship with the memory planes. The arithmetic logic units perform logical operations on the picture data latched in the register on the one hand and on the picture data obtained by the function generator on the other hand. The memory system further comprises an operation mode register storing operation mode data. The arithmetic logic units perform logical operations according to the operation mode data supplied from the operation mode register. The results of the operations are simultaneously written into the respective memory planes. The object of the present invention is to provide an improved processor for picture element data bytes in a graphics processing system. The present invention relates to a processor for image processing, the images being represented by pixels picture element data bytes , which processor comprises a plurality of unit processors, a first data bus connected to all the unit processors, a control memory with outputs connected to all the unit processors, and a frame buffer with a bidirectional data path to and from each of the unit processors. According to the invention the processor is characterised in that each unit processor handles data in units of n bits and comprises n bit processing means, source and destination operand registers each of n bit length and each coupled to the bidirectional data path, processing means with an input from each of the operand registers for processing data derived from the operand registers to produce n bit output data, a data latch responsive to the n bit output data of the processing means, and connecting means coupling the data latch to the bidirectional data path and to the first data bus, whereby with m unit processors either a single pixel having m x n bits or m pixels each having n bits can be processed simultaneously. The invention also relates to a graphic processor for single instruction multiple data operations on k pixels picture element data bytes simultaneously, where k is an integer greater than one, which processor is also easily expandable in terms of pixel length and can efficiently handle conditional operations requiring efficient interpixel communications. According to the invention the processor is characterised in that it comprises a plurality n of frame buffers, each buffer storing data of k bit width, the plurality of frame buffers being arranged in groups of i frame buffers per group, where n and i are each integers greater than one and i is an integer less than n to provide n i groups of frame buffers, and a plurality of pixel slice processors, each operating on data of i bit width, the plurality of pixel slice processors being arranged in n i groups of k processors per group where each frame buffer group has a corresponding pixel slice processor group, and each pixel slice processor in a group handles a portion of a different pixel. The processor also comprises data path means to provide for According to one embodiment of the invention an n bit pixel slice processor or unit processor has the following characteristics. An ALU is implemented in the form of a random access memory RAM See figures in the accompanying drawings . The first n address bits of the RAM represent the first operand, and the next n bits represent a second operand. Additional address bits provide for operation control. The unit processor includes a transceiver for coupling the n input and output bits of the RAM to a latch LA. The particular functions to be implemented by the ALU are represented as a function table which is loaded into the RAM from data lines through the transceiver, and thus the transceiver is bi directional. The output data residing in the latch LA can be written into a frame buffer FB or put on a PSP bus using a second or bus transceiver BT . The FB and LA data can also be loaded into a source mask register SMR , a source register SR , a destination mask register DMR and a destination register DR . By controlling the data flow direction through BT, the PSP bus can be used to load the FB or one or more of the four registers specified above. The SR, SMR, DR and DMR registers serve as either a store of source and destination data or as a condition code. In the latter case a logical AND of the SR and SMR data is implemented by a SAND gate and correspondingly the logical AND of the DR and DMR data is provided by a DAND gate. A source multiplexer SM selects one of its four n bit inputs as an operand for the ALU. Thus, one operand for the ALU can be chosen among SR, SMR, SAND and either the LA or FB data. Because the LA output is also connected to the PSP bus through BT , the PSP data bus can also be used as an ALU operand so as to provide data communication between cascaded pixel slice or unit processors. The destination multiplexer DM similarly selects between DMR, DR, DAND, LA, FB or the PSP bus to provide the other operand for the ALU. Control signals from a microprogrammed control enable clocking input of the corresponding devices providing the ability of pipeline data flow as well . Since unit processors can communicate on the PSP bus, the number of unit processors can be changed, if necessary, to accommodate larger pixel lengths. Accordingly, pixels with lengths greater than n can be processed. In a second embodiment of the invention, the pixel slice processor need not be capable of processing data as wide as the pixel length. Rather, a group of pixel slice processors are used selectively to handle each pixel. At the same time, however, execution is not limited to a single pixel, e.g. single instruction, multiple data SIMD processing is employed. This is effected, for an n bit pixel, by using n frame buffer planes. Multiple data stream processing is provided by selecting each frame buffer plane to provide a k bit word, so as to allow the processing of k pixels simultaneously. The pixel slice processors are each capable of processing i bits of data where n, k and i are independent integers each greater than 1 and i is less than or equal to n . The n frame buffer planes are divided into a plurality of groups, wherein each group of frame buffer planes includes i planes. Similarly, the pixel slice processors are grouped, so that there is a group of pixel slice processors for each group of frame buffer planes. Since each of the pixel slice processors can simultaneously process data i bits in width, there are k pixel slice processors per group. In order to overcome the prior art problems in operating with pixels whose length is greater than the processing capability of a single processor,intrapixel carries are provided via a data path interconnecting pixel slice processors in different groups. On the other hand, in order to avoid prior art problems in providing for conditional computations, a data path is provided for communicating between the pixel slice processors in a group. For efficiently implementing the invention in accordance with this second embodiment, each group of pixel slice processors can be located on a different circuit board and therefore a data path , providing communications between the pixel slice processors in a group, is located wholly within a single circuit board. A bus is provided for intrapixel communication, coupling the different circuit boards. The intrapixel bus need only as many conductor groups as there are pixels being processed simultaneously, k. There are i conductors per group so the intrapixel bus requires a total of k i conductors. Since the interboard bus is not related to n the bit length of the pixel extensions of the pixel length being handled merely require adding an additional circuit board or boards. Thus this aspect of the invention provides apparatus such as recited above which includes In order that the invention may be more readily understood an embodiment will now be described with reference to the accompanying drawings, in which Fig. 1 is a block diagram of a pixel picture element data byte processor 10 constructed in accordance with the invention. Fig. 1 shows the processor 10 in association with a frame buffer 30, amicroprogram control memory 20, transceiver 40 and host data bus 50. The pixel processor 10 includes a number of PSP or unit processors, Fig. 1 shows pixel slice processor 11 PSP1 , PSP2 12 , through PSP k 13 . In the embodiment of Fig. 1, each PSP processor handles data in units of n bits, the pixel length may be larger than n as will be described. The number of unit processors is arbitrary, and its selection will depend on the chosen pixel length and the bit capacity n of each of the unit processors. For example, for a 32 bit pixel, four unit processors, each handling eight bits , would suffice. On the other hand, the pixel processor architecture is capable of simultaneously handling multiple pixels. Thus for example with an 8 bit pixel, four unit processors, each of 8 bit width, could simultaneously process four pixels. Each unit processor has a dedicated bi directional data path to and from the frame buffer 30. Thus processor 11 has a dedicated path 1B, processor 12 has a dedicated path 2B and processor 13 has a dedicated path KB. The transceiver 40 also provides a bi directional data path connecting each of the unit processors to the host data bus 50. A PSP bus is connected to each of the unit processors via paths 1P KP, and the PSP bus is connected to transceiver 40. Each of the unit processors is also capable of accepting or transmitting data to the host data bus 50 via the paths 51, 52, . . . 5K. The microprogram control memory 20 is coupled to each of the unit processors. The control signals provided by the microprogram memory 20 can be broken down into a first group of control signals which are coupled in common to all the unit processors, e.g. a Y group of control signals including individual signals Figs. 2A and 2B form a block diagram of a typical unit processor. The ALU function is implemented in the form of a RAM 200. RAM 200 is coupled to three data input paths, at the ports 200A, 200B and 200C, and one input output path at the port 200D. The input port 200A is coupled over an n bit path to the output of a source multiplexer SMUX. SMUX has four different n bit inputs, and control signals Y3 and Y4 determine which of the four inputs is effective. A first input is provided by the output of the SAND gate. The SAND gate has two n bit inputs, a first derived from an n bit register SMR, and a second derived from an n bit register SR. Two of the other three inputs of SMUX are provided respectively by the outputs of the registers SMR and SR, directly. The fourth input to the SMUX multiplexer is provided by the B bus which is the unit processor s dedicated bi directional path to the frame buffer 30. The input to the SMR and SR registers is also provided by the B bus and gated respectively by control signals Y2 and Y1. The data path coupled to the input port 200B is derived from a similar destination arrangement. More particularly, the input port 200B is coupled to the output of a destination multiplexer DMUX which has four n bit inputs. A first input is provided by the gate DAND. Inputs to the gate DAND are provided by registers DMR and DR, which also provide two of the other three inputs to the DMUX. The fourth input to the DMUX is derived from the B bus, and control signals Y7 and Y8 select the effective input to DMUX. The input to the registers DMR and DR respectively are also provided by the B bus gated by control signals Y5 and Y6. The X control signal clocks the registers SMR, SR, DMR and DR. The input port 200C, which is L bits wide, is provided in common to all unit processors with the control signals In view of the foregoing it should be apparent that the output data of any unit processor can be transmitted selectively to other unit processors, so that for example only selected SR, SMR, DR and DMR registers will be loaded with the data from the PSP bus. As an example, if Z2, X1, XK, Y2 and Y6 are active, the ALU output data from the RAM 200 of the unit processor 2 control signal Z2 will be loaded into the SMR control signal Y2 and DMR control signal Y6 registers of the unit processors 1 control signal X1 and K control signal XK . The contents of the RAM 200 can be written from the host processor data bus 50. Upper address bits are provided by the control signals The registers SR, SMR, DR and DMR can be loaded from the host processor data bus 50 through the transceiver 40 which provides an output on the PSP bus. The same data path is used for reading or writing the frame buffer 30 by the host. This accommodates the fact that the host data bus length can be shorter than the pixel and thus several cycles would be needed for the data transfer between the host and frame buffer or pixel processor. On the other hand, a memory clear of the frame buffer can be effected simultaneously by making all the bi directional transceivers BT operate to receive zero or null data from the host through the PSP bus. Concatenated operation of the several unit processors as shown for example in Fig. 1 is not the only mode of operation of the pixel processor. Rather, the several unit processors can be operated in parallel so as to handle multiple pixels, simultaneously. In this event the connectivity of the pixel processor is shown in Fig. 3. Fig. 3 shows that each of the unit processors 11 13 are coupled over their dedicated bi directional frame buffer paths 1B NB to different frame buffers 300 302, although frame buffers 300 302 may be different portions of the same frame buffer 30. Each unit processor 11 13 is coupled to the host data bus 50 over the same path 51 5N. The connectivity of the microprogram control memory 20 is slightly altered. As was the case with Fig. 1, the Y control signals are coupled in common to all unit processors 11 13. Different from Fig. 1 is the fact that the X and Z control signals can be common to all unit processors 11 13. Also different from Fig. 1 is the form of a PSP bus. Whereas in Fig. 1 the PSP bus was commonly connected between an input output of the transceiver BT and all unit processors, as shown in Fig. 3, the input output of the transceiver BT is coupled over paths 1P NP, each dedicated to a different unit processor, to the transceiver 45, and through the transceiver 45 to the host data bus 50. As an alternative to changing the connectivity between the microprogram control memory 20 and the unit processors 11 13 when going from the arrangement of Fig. 1 to Fig. 3, the connectivity can remain as in Fig. 1, but the contents of the microprogram control memory 20 is arranged such that each of the X control signals X1 XK are identical, and similarly, each of the Z control signals Z1 ZK would be identical. This alternative is illustrated in Fig. 3 by the dotted conductors X1 X3 and Z1 Z3. Fig. 4 is an illustration of how the pixel slice processor of Fig. 1 can implement the Z buffer algorithm which has been applied in three dimensional computer graphics for hidden surface elimination. Using the Z buffer algorithm, one pixel value S or D can be overwritten by the other pixel value D or S if its corresponding depth D.Z or S.Z is greater than the other depth. More formally stated In describing the example we will assume that each unit processor is four bits wide n 4 and there are three unit processors K 3 , that is a 12 bit processor is built using three 4 bit unit processors. The 12 bit pixel has four bits of intensity bits 0 3 and eight bits of depth information bits 4 11 . Fig. 4 is used to illustrate execution of the algorithm using the pixel processor of the invention. The figure shows, at the left, SMR, SR, DMR and DR registers of the three processors used to implement execution of the algorithm for ease of explanation all common registers across the three processors are grouped together. Thus the block at the upper lefthand corner of Fig. 4 shows the three SMR registers of processors 11, 12 and 13, one directly below the other. The time axis to illustrate the process is horizontal, time progressing from left to right. Where significant information changes occur in the contents of one or more of the registers, the registers are reproduced and the source of the new information is reproduced. Identification of the registers is simplified by maintaining their vertical position, such that the three SMR registers are depicted as the top row of the figure, the three SR registers are the second row, the three DMR registers the third row and the DR registers are the fourth and last row. The time axis is divided into five logical cycles, and an operation code ALUOP is assigned to each of the five cycles. The logical cycle may take one or more clock cycles for execution. We assume at the initiation of the process data corresponding to a source pixel is written into the SR register of the three processors, and data corresponding to another pixel a destination pixel is written into the DR registers of the three unit processors. The low order four bits are written into unit processor 11 and represent intensity information. The next four bits represent the low order depth information and are written into unit processor 12. The high order four bits represent high order depth information and are written into unit processor 13. In the first cycle CMP , a comparison is effected in unit processor 2 of the low order depth information from both source and destination pixels. Simultaneously the high order depth information is compared in the ALU of unit processor 3. Each comparison produces one of three results, 00 for equality, 01 if DR SR and 10 if DR SR. These three possibilities require only two bits, the other two bits may remain null the upper two bits, for example . This leaves 0000, 0001 or 0010 in the latches LA of unit processors 2 and 3. The results are written back to the DMR registers of processor 2 and 3. With the two resulting operands from the two comparison operations now available, they are used at the third processor. The second logical cycle is a non standard graphical operation wherein the effective four bits of the two result operands are used to address the RAM 200 of processor 13. More particularly, data from the DMR register of PSP3 and data from the latch LA of PSP2 transferred by the PSP bus to BT of PSP3, the bus B and SMUX are applied to RAM 200 of PSP3 to produce a resulting byte which is 0 if S.Z is greater than D.Z or F otherwise. The result is loaded back into the DMR register in processor 3. That concludes the second logical cycle. The third logical cycle is merely a transfer from the DMR register of processor 13 to the SMR register of each of the processors. That concludes the third logical cycle. At this time the result of the comparison is located both in the DMR register of processor 13 as well as the SMR register of each of the processors. The fourth logical cycle is a NOT function performed, at processor 13, on the contents of the DMR register. The result of the NOT operation is written into the DMR register of each of the three processors. At this point in time, if the source depth was not greater than the destination depth, then as shown in Fig. 4, this is indicated by the quantity F hex in the SMR register of each processor and the quantity 0 as a result of the NOT operation in the DMR register of each of the three processors. On the other hand, if the source depth was greater than the destination depth, then the result produced in the third cycle would not be as shown in Fig. 4 but instead would be a 0. This 0 would have been transferred and appear in each of the SMR registers whereas the quantity in the DMR register in each processor would not be 0, but would be F hex . This is the conclusion of the fourth logical cycle and sets the stage for the fifth logical cycle which produces the desired result. The fifth logical cycle is effected in each of the three processors and employs as the input to the port 200A of each RAM 200 the SAND output logical AND of the SR and SMR register contents and input to the port 200B is the DAND output the logical AND of the contents of DR and DMR . If as shown in Fig. 4 the source depth is not greater than the destination depth, then the desired result is the source pixel. This is the result produced in the SAND which is provided to the port 200A of each RAM 200. The output of the DAND register is 0 since one of the inputs to the DAND gate is the 0 contents of the DMR register . The result from the RAM 200 is the source pixel which is then loaded into the latch LA four bits in each processor and then transferred to the frame buffer. On the other hand, if the source depth was greater than the destination depth, then the DMR registers would contain the quantity F hex and the SMR register would contain the quantity 0. Accordingly, the output of the SAND gate would be 0 and the output of the DAND gate would be the D pixel and thus the resulting data in the latch LA would be the D pixel which is then transferred to the frame buffer. Implementation of the Z buffer algorithm as shown in Fig. 4 is not limited to eight bits of depth data. Rather, for depth data greater than eight bits, several sequential CMP COD cycles are concatenated to produce a single result, again in the DMR register, which is then used as shown in logical cycles 3, 4 and 5 of Fig. 4. Fig. 5 is a similar diagram used to represent a copy operation with antialiasing. This is to avoid a problem in graphical processing, variously called jaggies or staircasing , in which an edge of an image is represented by the edges of sets of picture elements and not by an exact straight line and has a number of different solutions. In one solution a prefiltered source image is stored in the cache part of the frame buffer or host memory and then directly copied into the visible portion of the frame buffer. The intermediate gray scale levels of the intensity cannot be used directly for colour images because they depend on the foreground and background colours chosen for the destination image. If a RGB colour model is adopted, the colour intensities can be calculated based on the source intensity I, foreground colours R1, G1 and B1 and background colours R2, G2 and B2. If we again assume a 12 bit pixel value with four bits for each of the RGB components, and the intensity I varying from 0 to 15 another four bits . The red component R of the destination pixel can be calculated as Implementation of this algorithm is illustrated in Fig. 5 using the same convention, e.g. the SMR, SR, DMR and DR registers of the three processors PSP 1 3 are illustrated adjacent each other. The logical cycles of this process are shown horizontally extending from left to right. As information in the various registers changes, the register is reproduced without changing its vertical position and the new information as well as the source of that information is represented. To initiate execution of the algorithm, the R1, G1 and B1 foreground data is loaded into the SR registers of the three processors, the R2, G2 and B2 background data is loaded into the DR registers, and the intensity I is loaded into the DMR register of PSP 1. In the first logical cycle, the intensity data I is copied into all DMR registers. Referring briefly to Fig. 2, Y7 and Y8 control signals are enabled so that the DMUX selects as its input the output of the DMR register. This will provide an effective input for the port 200B of the RAM 200 in PSP 1, in PSP 2 3 the input will be blank as the DMR register in these processors is empty. Control signals Y3, Y4 can be enabled so as to select the output of the SMR register to provide input to the port 200A of the RAM 200. This is null information and the RAM 200 is arranged to copy the port 200B under these circumstances to the latch LA. The BT transceiver in PSP 1 is enabled to place the contents of the latch LA on the PSP bus. The registers in PSP 1 are not clocked and thus they remain unchanged. The registers in the PSP 2 and PSP 3 processors are clocked and their BT transceivers are enabled to place the contents of the PSP bus on the B bus and control signal Y6 is enabled so that in PSP 2 and PSP 3 the contents of the B bus are loaded in the DMR register. Although Y6 is common to PSP 1, the lack of clocking PSP 1 will prevent it from responding to the Y6 control signal. Thus the intensity data I has been copied into the DMR register of each of PSP 1 3. That concludes the first logical cycle. The second logical cycle executes a NOT function in each processor using the DMR data, the results of the NOT operation being placed in the SMR register. Thus at the conclusion of the second logical cycle, the DMR registers in each of PSP 1 3 include the I intensity, and the SMR registers in each of PSP 1 3 include the quantity 15 I the complement of I . In logical cycle 3, each RAM 200 is controlled to effect the operation In logical cycle 4 the same operation is performed using the SMR and DR data. Thus the DR register on PSP 1, at the conclusion has the quantity In the fifth and final cycle, each of the processors effects the sum of the contents in their SR and DR registers. The result is loaded into the latch LA in each processor and from there coupled to the destination location in the frame buffer. It should be apparent that the latch LA in each processor holds data representing the expression 1 . Finally, the last example is an example of a general arithmetic operation on data which is not aligned with the PSP word boundaries as those boundaries were chosen for an example such as one of the two described above. Fig. 6 is set up as was Figs. 4 and 5 in that all like registers of the different processors PSP 1 3 are shown adjacent each other, time progresses horizontally left to right and , where information in a register changes significantly, the register is reproduced in the same vertical position and the source of the changed information is explicitly shown. As shown in Fig. 6, the contents of the SR register includes some S1 data, partially in the SR register of PSP 1, and partially in a register in PSP 2 specifically PSP 1 includes the lower bits of the S1 data, S1A, whereas a portion of the SR register in PSP 2 contains the upper bits, S1B . The SR register in PSP 2 also includes the lower bits of S2 data, S2A, whereas the SR register in PSP 3 includes the upper bits of S2 data, S2B. The DR register holds corresponding destination data in the same format. The desire is to add S1 and D1 data and S2 and D2 data the result is achieved in four sequential logical cycles. In the first logical cycle, the RAM 200 of PSP 1 performs a sum of S1A and D1A, but retains solely the carry bit C1 which is stored in the SMR register in necessarily the high bit position. The same operation occurs in PSP 2 using the high order bits of S2A and D2A. The contents of RAM 200 in effect ignore S1B and D1B in this operation. The carry bit of this operation is stored in the SMR register of PSP 2 and again necessarily in the high bit position. That concludes logical cycle 1. In logical cycle 2 each of the RAMs 200 perform s a sum of the SR and the DR registers, placing the result in the DR register. Thus in PSP 1 the result is the sum In logical cycle 3 operation occurs only in the PSP 2 processor. In this processor the contents of the DR register are summed with the SMR register in PSP 1. This provides us with the true result of Logical cycle 4 occurs solely in the PSP 3 processor wherein the contents of the DR register are summed with the contents of the SMR register from PSP 2 with the carry bit from the sum of Figs. 1 and 3 respectively illustrate a pixel processor wherein the connectivity between pixel slice processors was changed so as either to process a pixel of length larger than the processing capability of each of the pixel slice processors Fig. 1 or else to process simultaneously a number of pixels, wherein the pixel length was equal to the capacity of each pixel slice processor Fig. 3 . However, the invention is not so limited, and can instead provide for SIMD processing parallel processing of pixels even though the pixel length exceeds the bit capacity of each of the pixel slice processors. This is the subject of a second embodiment of the invention illustrated in Figs. 9 11. Before describing this embodiment of the invention in detail, reference is first made to Figs. 7 and 8 to illustrate prior art graphic processors and their shortcomings which are overcome by the invention. Fig. 7 shows an arrangement of n memory planes FB0 FBn 1 wherein each memory plane has a k bit word. Thus a single access provides us with k n bit pixels, which are accessed in parallel by the k processing elements P0 Pk 1. The n bit bus shown interconnecting each of the pixel processors P0 Pk 1 at the right provides interpixel communication for the n bit pixels. Fig. 7 requires Fig. 8 shows the SUN display architecture. This architecture is oriented for images comprising single bit pixels, providing parallel computations of data stored in different bit planes, or in the same bit plane. By simultaneously operating the processors P0 Pn 1, calculations can be effected on several pixels simultaneously, and because of the single bit nature of the pixels, simultaneous pixel operations can be effected by a single one of the processors. On the other hand, image modifications which require pixel value calculations must be done by the host processor in the slow sequential mode. Extending bit length, in this architecture is not restricted, and can be increased by simply adding extra bit plane memories and processing elements. The pixel processor shown in Fig. 9, however, provides a graphic processor which can be easily expanded in pixel length but at the same time array processing of pixel data as well as parallel interplane calculations can be provided. Referring now to Fig. 9, the frame buffer is represented by n memory planes FB0 FBn 1 with a k bit word in each memory plane. The n memory planes are grouped including i planes per group. A plurality of pixel slice processors PSP0, PSP1, etc. is also provided which are also grouped, so that there is a group of pixel slice processors for each group of frame buffer planes. Each of the pixel slice processors can handle i bit words and there are k pixel slice processors per group. Each processor in a group handles a portion of a different pixel. With n bits per pixel, and each processor handling i bits, n i processors per pixel are needed, and since k pixels in parallel are processed, a total of To provide for bidirectional data flow between the pixel slice processors and frame buffer planes in the associated group, a bidirectional data path is provided which has, for each group, In order to provide for intrapixel and interpixel communications, so as to handle conditional processing and carries within a pixel, the pixel slice processors are interconnected, one with another through two additional data paths. Each group includes a data path AB for intragroup communication . Thus there is an AB1 data path, an AB2 data path and an AB n i data path. Each of these data paths is i bits in width and is coupled to the pixel slice processor through a B port. Each of the pixel slice processors also include a C port. A different data path EB is provided for intergroup communications. The EB data path interconnects corresponding pixel slice processors in different groups. Thus, for example data path EB0 interconnects the 0 order pixel slice processor of each group PSP0, PSPk, PSP2k, etc. . This data path comprises a group of i conductors, one conductor for each bit. A similar data path EB1 connects the unit order pixel slice processors PSP1, PSP k 1, PSP 2k 1, etc. through corresponding C ports on each of these pixel slice processors. Similar i bit data paths, EB2, etc. through EB k 1 are provided. Since corresponding pixel slice processors in different groups are operating on different portions of a common pixel, the data paths EB0 EB k 1 provide for intra pixel carries. On the other hand, different pixel slice processors in the same group are operating on different pixels and thus the data paths AB1 AB n i provide for inter pixel communication. An efficient implementation of the architecture of Fig. 9 is provided by placing each different group of pixel slice processors and perhaps the corresponding frame buffers on a separate circuit board. In accordance with this implementation the intragroup buses do not cross circuit board boundaries. The intergroup buses EB0 EB k 1 are connected to each board, however, the number of conductors in this bus and their connection to the boards is independent of the pixel length n and therefore extending the bit length of a pixel can be effected by simply adding a new board or boards. The architecture in Fig. 9 does not pay a speed penalty for inter or intrapixel calculations. The architecture of Fig. 9 also has an advantage over the architectures of Figs. 7 or 8 especially if the pixel length n is greater than the data path in Fig. 7 or 8, since in that case the architecture of Fig. 7 or 8 requires repetitive memory accesses, whereas the architecture of Fig. 9 need never operate with a pixel length which requires more than a single memory access. The architecture of Fig. 9 can be implemented with any bit slice processor, e.g. Am2901. The pixel slice processor shown in Fig. 9 can alternatively take the form of that shown in Fig. 2. More particularly, the ports B and C of Fig. 9 are connected to a tridirectional transceiver in lieu of the bidirectional transceiver BT of Fig. 2 . Fig. 10 is an implementation of the intra and intergroup communication network. Fig. 10 identifies 8 different circuit boards groups . If each group handles four bits i 4 , then a 32 bit pixel can be handled. In one embodiment of the invention 16 pixels were handled in parallel k 16 . Fig. 10 omits the frame buffers and the pixel slice processors and the associated interconnections, but does illustrate implementation of the buses EB0 EB k 1 and AB1 AB n i . More particularly, to implement the two bus intra group and inter group buses structure, the processor of Figs. 9 10 uses tridirectional but transceivers TR0, TR1, etc. which can be 74 LS 442. The A port of each transceiver, TR1, etc. is connected to the associated pixel slice processor, e.g. the bus B and latch LA Fig. 2 . In other words, the tri directional transceivers TR replace the bidirectional transceivers BT of Fig. 2. The B port of each of the tridirectional transceivers on the board group is connected to the associated AB bus. The C port of each of the transceivers is connected to one of the external buses EB0, EB1, etc. and implements bus structure of the same designation in Fig. 9. A host data bus 50 is coupled to an additional transceiver on each board, e.g. T1, T2, etc. Each of the transceivers T1 T8 is connected to the associated AB bus on the board. Each board includes in addition a control . Thus we have control C1 8, one for each of boards C1 8. A control bus eight bits wide provides control signals Y0 Y7 for each of the controls C1 C8. The control C can be implemented as field programmable logic arrays 8 2S 153. Thus as shown in Fig. 10, board 1 handles bits 0 3, board 2 handles bits 4 7, through board 8 handling bits 30 32. The low order position on each board handles a first pixel pixel 0 , the next order position on each board handles the next pixel pixel 1 through the last position on each board handling pixel k 1. Fig. 11 is one example of bit assignments for the controls C1 C8. The control signals establish four distinct conditions, e.g. both buses are disabled, bus AB is enabled to write from a specified pixel pixel j , bus AB is enabled to copy any or all pixels from the host data bus 50, or bus EB is enabled with a specified 4 bit pixel portion constituting the source. More particularly, in the condition 00 bits 8 and 7, respectively , all buses are disabled. In condition 01, the AB bus is enabled and bits 0 3 identify the pixel which is the source from which the other pixels are written. That is, in the condition 01, the transceiver associated with the source pixel acts as a transmitter through its B port and the other transceivers receive from the bus AB through their B port. In condition 10, the EB bus is enabled and bits 4 6 identify a 4 bit pixel portion which are the source from which the other pixel portions are written. That is, the transceiver associated with bits 4M to 4M 3 acts as a transmitter through its C port and the other transceivers coupled to the EB bus act as receivers through their ports. Finally, in the condition 11, the AB bus is enabled to receive from the host data bus. That is, all transceivers receive from the AB bus through their B ports. The arrangements of Figs. 9 and 10 are convenient if the pixel neighbourhood is along a scan line, for example, if the 16 pixels processed simultaneously are along a scan line. However, other neighbourhoods are also conventional. Assume the simultaneously processed 16 pixels are in the form of a 4 x 4 array. In this case the AB bus interpixel bus can be used to deliver pixel data to other selected pixels. If several pixels are to be transmitted, successive operations are required since there is only a single intragroup bus. The architecture of Figs. 9 and 10 can be expanded and improved for the 4 x 4 array in Fig. 13 illustrating a pixel processor 500. Here the tri directional transceivers TR1, etc. are replaced by five port transceivers, ETR0, etc. One port coupled to the EB bus is used for intra pixel communication. Up to four other ports are each dedicated to a different one of up to four buses which replace the AB bus. These buses are, for typical PSP 9, AAB connected to PSP 8 , BAB connected to PSP 5 , CAB connected to PSP 10 , and DAB connected to PSP 13 . Thus data transfer from PSP 9 to PSP 13 can be simultaneous with transfer from PSP 5 to PSP 9. Clearly, there are other arrangements for connecting the array which have different advantages and disadvantages.