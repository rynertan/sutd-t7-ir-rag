# Architecture for intelligent control of data communication adapters.

## Abstract
A communications system of the token passing, closed loop type for use as a local area network employs an adapter 10 at each station for coupling a host processor 12 to a one way signal path 11 . The host processor 12 includes a host CPU 31 , a main memory 32 , and a system bus 33, 34 . To transmit a message from one station to another, a frame of data is created in the main memory 32 by the host CPU . The adapter 10 is coupled to the main memory by the system bus, and includes a local CPU 21 , a local readwrite memory 22 , and a local bus 24 . The message frame to be transmitted is copied into the local read write memory by way of the system bus 34 and local bus 24 , when initiated by the host CPU 31 . A transmit and receive controller 16 is coupled to the local bus 24 to directly access the local read write memory 22 . When this station has access to the loop, i.e., receives a free token, the transmit and receive controller 16 copies the message frame from the local read write memory 22 to the outgoing signal path 11 , converting from parallel to serial. When the transmit and receive controller 16 receives a message addressed to this station, it converts it from serial to parallel, and copies the message frame into the local read write memory 22 via the local bus 24 , interrupting the local CPU 21 . The message frame is then copied from the local read write memory 22 to the main memory 32 . The local CPU executes instruc tions fetched from a ROM 27 accessed by the local bus 24 , so the instruction fetch for the local CPU, the direct memory access from the transmit receive controller 16 for transmit ting or receiving data frames, and the access from the host CPU for copying transmitted or received message frames, all contend for the local bus 24 . Thus, bus arbitration 26 with appropriate priorities is used to control access to the local bus 24 .

## Claims
WHAT IS CLAIMED 1. A digital data communications system comprising a a signal path, b a plurality of stations connected to said signal path, each station receiving digital data from the path and transmitting digital data to said path, each said station comprlsing I a main processor containing a main CPU, a main memory, and peripheral I O devices, and having system bus means Interconnecting said CPU, main memory, and peripheral I O devices a a communications processor containing a local CPU, a read only memory, and a local read write memory said communications processor having local bus means interconnecting said local CPU, read only memory, and local read write memory lli first access means connecting said system bus to said local bus means whereby said main CPU can transfer data to said local read write memory and said local CPU can transfer data to said main memory, iv receiving means having an input coupled to said signal path and an output coupled to a receive buffer memory and transmitting means having an output coupled to said signal path and an input coupled to a transmit buffer memory v transmit receive control means responsive to receipt of data from said signal path in said receiving means, vi second access means connecting said receive buffer memory and said transmit buffer memory to said local bus means, and responsive to said transmlt recelve control means to access said local read write memory for writing received data from the receive buffer memory to the local read write memory and reading transmit data from the local read write memory to the buffer memory. 2. A system according to claim I wherein said signal path is a closed, one way path, and each station receives data from an upstream direction in the path and transmits data to a downstream direction in the path, said access to said signal path is controlled by a token included in the transmitted data and passed from station to station around the closed path, date is transmitted on said signal path in bit serial format, said receiving means includes serial to parallel conversion means, said transmitting means includes parallel to serlal conversion means, a frame of a plurality of bytes of data to be transmitted is created in said main memory under control of said main CPU, and such frame is transferred by said first access means upon initiation by said main CPU via said system bus and said local bus into said local and said local read write memory, and subsequently such frame is transferred under control of said transmit receive control means via said local bus and said transmit buffer memory to said transmitting means, said frames of data created in said main memory and transmitted on said signal path by said stations include a destination address identifying a particular one of the stations, and a source address identifying the originating station, and said local CPU executes instructions fetched from a local ROM via said local bus means, and said mainCPU executes instructions fetched from said main memory via said memory bus. 3. A digital system comprising a a main processor containing a main CPU, a main memory, and peripheral I O devices, and having a system bus interconnecting said CPU, main memory, and peripheral I O devices b a local processor containing a local CPU, and a local read write memory said local processor having a local bidirectional address data bus interconnecting said local CPU and local read write memory c first direct memory access means connecting said system bus to said local bus whereby said main CPU can initiate access to said local read write memory and said local CPU can initiate access to said main memory, each said direct address being under control of said first direct memory access means, d second direct memory access means connected to said local bus means to directly access said local read write memory for writing received data from a remote data path to said local read write memory and reading data from the local read write memory to said remote data path. 4. A system according to claim 3 including bus arbitration means coupled to said local bus and receiving bus request signals individually from said first access means, said second access means, and said local CPU said bus arbitration means granting access to said local bus in the order of priority of 1 said second access means, 2 said first access means, and 3 said local CPU, said local CPU executes instructions fetched from a local ROM via said local bus, and said main CPU executes instructions fetched from said main memory via said system bus, the first access means includes memory mappedI O means by which the main CPU accesses control register means in the first access means, and wherein direct memory access of the local read write memory from the system bus is initiated by said control register means when written into by the maln CPU. 5. A data communications adapter connecting a processor system to a data communications signal path said processor system having a system CPU, a system memory, and a system bus said adapter comprising a a programmable processor device having a local CPU, a local memory, and a local bus connecting the local CPU and local memory b a system interface device coupling said local bus to said system bus for transferring data between said system memory and said local memory c a data communications interface device coupling said local bus to said signal path for transferring data between said signal path and saldtlocal memory d wherein said data communications interface device, said system interface device, and said local CPU all contend for control of said local bus. 6. An adapter according to claim 5 wherein said local read only memory is contained within said data communications interface device, said system interface device contains a memory mapped ISO channel by which said system CPU accesses said local memory to transfer command and status information, and contains a direct memory access channel by which data is transferred between the system memory and the local i memory under control of the system interface device after initiation of the transfer by the system CPU or the local CPU, said data communications interface device includes a direct memory access channel by which data is transferred betwee n said signal path and said local memory under control of the data communication interface device after initiation of the transfer by the local CPU or the data communications interface device. said programmable processor device includes bus arbitration means to control access to said local bus, and said data communications interface device has highest priority of such access, said system interface device has the next higher priority of such access, and said localCPU has the lower priority of such access. 7. A data communications adapter connecting a processor system to a data communications signal path said processor system having a system CPU, a system memory, and a system bus said adapter comprising a a programmable processor device having a local CPU, a local memory, and a local multiplexed address data bus connecting the local CPU and local memory said local memory including read only memory for storing program instructions executed by said local CPU and including read write memory for temporarily storing message data b a system interface device coupling said local address data bus to said system bus for transferring message data between said system memory and said local memory by direct memory access in both directions c a data communications interface device coupling said local bus to said signal path for transferring data between said signal path and said local memory byidrect memory access In both directions d wherein said data communications interface device, said system interface device, and said local CPU all contend for control of said local address data bus. 8. An adapter according to claim 7 wherein said system interface device contains a memory mapped I O channel by whtch said system CPU accesses said local memory to transfer command and status information, and contains a direct memory access channel by which data is transferred between the system memory and the local memory under control of the system interface device after initiation of the transfer by the system CPU or the localCPU wherein said data communications interface device includes a direct memory access channel by which data is transferred between said signal path and said local memory under control of the data transfer by the local CPU or the data communications interface device and wherein said programmable processor device includes bus arbitration means to control access to said local bus, and said data communications interface device has highest priority of such access, said system interface device has the next higher priority of such access, and said local CPU has the lower priority of such access. 9. A digital data communications system comprising a a signal path, b a plurality of stations connected to said signal path, each station receiving digital data from the path and transmitting digital data to said path, each said station comprising I a main processor containing a main CPU, a main memory, and peripheral I O devices, and having a system bus interconnecting said CPU, main memory, and peripheral I O devices if a single chlp microprocessor device containing a local CPU, a local read wr1te memory a local address data bus means interconnecting said local CPU and local read write memory, a timer having at least one count register accessed by said local bus means, and a bus arbiter coupled to and controlling access to said local bus lli coupling means connecting said system bus to said local bus means whereby said main CPU can access said local read write memory and said local CPU can access said main memory, iv receiving means having an input coupled to said signal path and an output coupled to said local bus means, and transmitting means having an output coupled to said signal path and an input coupled to said local bus means, v transmit receive control means responsive to receipt of data from said signal path in said receiving means to directly access said local read write memory for writing received data to the local read write memory and reading transmit data from the local read write memory. 10. A system according to claim 9 wherein said signal path is a closed, one way path, and each station receives data from an upstream direction in the path and transmits data to a downstream direction in the path, said access to said signal path is controlled by a token included in the transmitted data and passed from station to station around the closed path, data is transmitted on said signal path in bit serial format, said receiving means includes serlal to parallel conversion means, said transmitting means includes parallel to serial conversion means, and wherein said local address data bus means and said system bus are parallel busses, ìa frame of a plurality of bytes of data to be transmitted is created in said memory under control of said main CPU, and such frame is transferred upon initiation by said main CPU via said system bus and said local bus means into said local read write memory, and subsequently such frame is transferred under control of said transmit receive control means via said local bus to said transmitting means, said frames of data created in said main memory and transmitted on said signal path by said stations include a destination address identifying a particular one of the stations, and a source address identifying the originating station, said local CPU executes instructions fetched from a local ROM via said local bus means as controlled by said bus arbiter, and said main CPU executes instructions fetched from said main memory via said system bus, said timer interrupts execution of said instructions in said local CPU after a timer period determined by said count register. 11. A digital data communications system comprising a a closed, one way, bit serial signal path, b a plurality of independent stations connected in said signal path, each station receiving digital data including an access control token from the path and transmitting digital data including an access control token to said path, each said station comprising a main processor containing a main CPU, a main memory, and peripheral I O devices, and having a system bus interconnecting said CPU, main memory, and peripheral ISO devices ii a single chip microprocessor device containing a local CPU, a local read write memory, a timer having count register means and having means to interrupt said loqal CPU, local address data bus means interconnecting said local CPU local read write memory and count register of the timer, and bus arbiter means controlling access to said local bus means 11l first access control means including said bus arbiter means and connecting said system bus to said local bus means whereby said main CPU initiates direct access to said local read write memory via said system bus and said local bus means, and said local CPU initiates access to said main memory, iv receiving means having a serial input coupled to said signal path and a parallel output coupled to said local address data bus means, and transmitting means having s serial output coupled to said signal path and a parallel input coupled to said local address data bus means, v second access means including said bus arbiter means and connecting said output of said transmit timing means to said local bus means, and responsive to said transmit receive control means to initiate access to said local read write memory via said local bus means for writing data received from the signal path to the local read write memory and reading transmit data from the local read write memory for coupling to the signal path. 12. A system according to claim 1I wherein said receiving means includes sertal to parallel conversion means, said transmitting means includes parallel to serial conversion means, and wherein each of said local address data bus means and system bus includes a parallel bus, a frame of a plurality of bytes of data to be transmitted is created in said main memory under control of said main CPU, and such frame is transferred upon initiation by said main CPU and control by said first access means via said system bus and said local bus means into said local read write memory, and subsequently such frame Is transferred under control of said second access means via said local bus means to aid transmitting means, said local CPU executes instructions fetched from a local read only memory extended to said microprocessor device via said local bus means, and said main CPU executes instructions fetched from said main memory via said system bus, said local bus means is a bidirectional, multiplexed address data bus, and said bus arbiter means controls access to said local bus means for an outgoing address and an incoming instruction for said fetch of instructions for said local CPU. 13. A digital data communications system comprising a a signal path, b a plurality of stations connected in said signal path, each station receiving digital data from the path and transmitting digital data to said path, each said station comprising 1 a main processor containing a main CPU, a main memory, and peripheral I O devices, and having a system bus interconnecting said CPU, main memory, and peripheral I O devices a a single chip microprocessor device containing a local CPU, local address data bus means, a timer having a count register, a clocked decrement input for said count register, a latch register means for interrupting said local CPU when said count register decrements to zero, and means for loading said count register from said latch register when said count register decrements to zero, a a local read write memory coupled to said local bus means, iv coupling means connecting said system bus to said local bus means whereby said main CPU can access said local read write memory and said local CPU can access said main memory, v receiving means having an input coupled to said signal path and an output coupled to said local bus means, and transmitting means having an output coupled to said signal path and an input coupled to said local bus means, vi transmit receive control means responsive to receipt of data from said signal path in said receiving means to directly access said local read write memory for writing received data to the local read write memory and reading transmit data from the local read write memory. 14. A system according to claim 13 wherein said signal path is a closed, one way path, and each station receives data from an upstream direction in the path and transmits data to a downstream direction in the path, said access to said signal path is controlled by a token included in the transmitted data and passed from station to station around the closed path, data is transmitted on said signal path in bit serial format, said receiving means includes serial to parallel conversion means, said transmitting means includes parallel to serial conversion means, and wherein said local address data bus means and said system bus are parallel busses, a frame of a plurality of bytes of data to be transmitted is created In said main memory under control of said main CPU, and such frame is transferred upon initiation by said main CPU via said system bus and said local bus means into said local read write memory, and subsequena,tly such frame is transferred under control of said transmit receive control means via said local bus to said transmitting means, said frames of data created in said main memory and transmitted on said signal path by said stations include a destination address identifying a particular one of the stations, and a source address identifying the origination station.

## Description
PROCESSOR ARCHITECTURE FORINTELLIGENT CONTROL OF DATA COMMUNCATIONS ADAPTERSBACKGROUND OF THE INVENTION This invention relates to loop communications systems and more particularly to an adapter for coupling a host processor to a data communications loop, in which the adapter contains a local processor. The token ring local area network is a data communications system functioning to transfer data among a number of stations coupled to a one way signal path. Each station has a host processor with memory and various peripheral devices to function as an independent workstation. Access to the ring is controlled by token passing wherein a free or busy token is passed from one station to the next around the ring. An early example of the token ring is shown in U.S. Patent 3,597,549 issued toFarmer Newhall and assigned to Bell TelephoneLaboratories. In further refinement, the so ealled Munich ring has evolved from developments by IBM, reported atProceedings of the National Telecommunications Conference,Nov. 1981, pp. A.2.2.1 A.2.2.6.Standard protocols for these communcations methods have been published by theIEEE as the 802.5 token ring proposal, and a similar report by the European Computer Manufacturers organization. The present invention is concerned with an adapter for connection between the host processor and the signal path of the ring. The adapter must operate relatively independent of the CPU of the host processor so that a minimum of interference with the functions of the host CPU is needed. The adapter must accomodate a variety of different types of host CPU, so that a special adapter need not be manufactured for each different type of construction of the workstations. It is expected that entire office buildings or manufacturing facilities will be permanently wired to implement loop communications of this type between all computer terminals, word processors, telephones, bulk data storage stations, and the like.Thus, the adapters must be of relatively low cost, must be reliable and require little maintenance, must be of small size and dissipate little Rower, and above all must interface with a variety of differing systems. It is the principal object of this invention to provide an improved data communca tions system, particularly a communications adapter for coupling a host processor system to a token passing communications loop.Another object is to provide a communications adapter which has processing and control facility independent of the host system, and which operates with a variety of different host systems. A further object is to provide a low cost, low power, reliable and versitile communications adapter for token ring local area network systems or the like.SUMMARY OF THE INVENTION According to one embodiment of the invention, a communications loop of the token passing local area network type is used for communction among a number of stations coupled to a closed one way signal path. Each station has a host processor of conventional form including a host CPU, a main memory, and a system bus. In order to transmit a message from one station to another, a frame of data is created in the main memory by the hostCPU. A communications processor operating relatively independent of teh host CPU is coupled to the main memory by the system bus and includes a local CPU, a local read write memory, and a local bus. The message frame to be transmitted is copied into the local read write memory by way of the system bus and local bus, under initiation by the host CPU.A transmit and receive controller is coupled to the local bus to directly access the local read write memory, and so when this station has access to the loop, i.e., receives a free token, the transmit and receive controller copies the message frame from the local reSd write memory to the outgoing signal path, converting from parallel to serial. In like manner, when the transmit and receive controller receives a message addressed to this station, it converts it from serial to parallel, and copies the message frame into the local read write memory via the local bus, interrupting the local CPU. The message frame is then copied from the local read write memory to the main memory.The local CPU executes instructions fetched from a ROM accessed by the local bus, so the localCPU instruction fetch, the direct memory access from the transmit receive controller for transmitting or receiving data frames, and the access from the host CPU for copying transmitted or received message frames, all contend for the local bus. Thus bus arbitration with appropriate priorities is needed to control access to the local bus. BRIEF DESCRIPTION OF THE DRAWINGS The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as other features and advantages thereof, will be best understood by reference to the detailed description which follows, read in conjunction with the accompanying drawings, wherein Figure 1 is an electrical diagram in block form of a one way communications loop of the token passing type which may employ a microprocessor device having features of the invention Figures 1a and 1b are timing diagrams of data frame formats used in the communications loop of Figure 1 Figure 2 is an electrical block diagram of one of the stations in the communications loop of Figure 1, including a microprocessor CPU having features of the invention Figure 2a is a diagram of the word, byte and bit definitions of the 16 bit data word used in the local CPU in the microprocessor device 20 of Figure 2 Figure 2b is a memory map for the local memory including local RAM 22 and ROM memory 27 of the local CPU device of Figure 2, and Figure 2c is a diagram of a number of adjacent memory locations in the general memory area referred to as a workspace Figure 2c is a timing diagram showing voltage vs.time for operations in the local CPU of the microprocessor device 20 of Figure 2 Figure 3 is an electrical diagram in block form of aMOS LSI microprocessor chip includingthe local CPU or central processor unit employed as the microprocessor device 20 of Figure 2 and utilizing features of the invention Figure 4 is a greatly enlarged plan view of the semiconductor chip 20 containing the local CPU 21 ofFigure 3 showing the physical layout of the various parts of the device Figure 4a is an enlarged detail view of a part of the layout of Figure 4 showing the register strip Figures 5a 5g are electrical schematic diagrams of various parts of the ALU and register strip within the microprocessor of Figures 3 and Figure 6 is a schematic diagram of a control ROM used in the local 21 CPU of Figures 2, 3 and Figure 7 is a state diagram showing conditions in the local CPU device of Figures 3 and 4 for an add operation Figure 7a is a diagram of a sixteen bit instruction word for the add operation of Figure 7 Figure 8 is a schematic diagram of an example of a circuit within Figs. 3 or 5a 5g to be tested by microcode EMI5.1 ThETAIL.E DE IPTI O N OF SPECIFIC EMBODIMENT TOKEN RING LOCAL AREA NETWORK SYSTEM Referring to Fig. 1, a communications loop of the token ring type is illustrated. A plurality of nodes or stations 10 are interconnected by a one way signal path 11. A host processor system 12 is connected to each station 10. Each one of these systems 12 may be a computer workstation with a CPU, keyboard, disk memory, CRT display, and printer, for example. Signals on the loop propagate in one direction, as indicated by arrows, either bit serial as will be described herein, or byte serial, depending upon the requirements of the system. The purpose of this communications loop is to provide high speed data transfer between processing systems. There is no central or master station in the loop instead the loop operates on a peer to peer basis. .T he communiations loop of Fig. 1 is a local area network interconnecting stations 10 within a single office building, a building complex, or a campus, with the length of the signal path 11 being no more than a few kilometers.Using twisted pair conductors for the signal path 11, data rates of about one to ten Mb sec. are possible, and up to one or two hundred stations 10 may be connected in a single loop. A control scheme based upon token passing is used for granting access to the ring of Fig. 1. A unique bit sequence, called a token, is passed from one station to the next. If a station has no data to transmit, the token is simply passed on to the next node. A station having data to transmit to another station 10 in the loop waits until the token is received, changes the token from free to busy and retransmits it, and transmits its data.After this transmitting station receives the message.back at its input, confirming that its message has propagated around the loop, it retransmits the free token. The communications loop of Fig. 1 operates according to the IEEE 802.5 standard for token ring local area networks. This type of system is described by Dixon,Strole and Markov in IBM Systems Journal, Vo. 22, Nos. 1 and 2, 1983, pp. 47 62 also, the system is described byN.C. Strole in IBM J. Res. Develop, Vol. 27, No. 5, Sept. 1983, pp. 81 96. Each of the stations 10 has the capability of receiving data from the signal path 11 at its input 13, and transmitting data at its output 14. The data is transmitted on the twisted pair signal path in the format of differential Manchester encoding. The data consists of a sequence of 8 bit groups or octets as illustrated inFigs. la and ib. A free token consists of a one octet starting delimiter, a physical control field which is two octets long, followed by an ending delimiter, as seen inFig. 1a. The physical control field contains priority codes which allow levels of priority it granting access, as well as the token , which is 1 for busy and 0 for free.The starting and ending delivers contain bits which are code violations in Manchester encoding so that the delimiters will not occur in any address or data fields. A data frame is shown in Fig. ib, and consists of a starting delimiter, a two octet physical control field containing a busy token in this case. The next field is the destination address, six bytes in length a single loop would need only one byte for a maximum of 256 stations 10, but provision is made in the protocol for a much larger number of unique addresses. A source address field of six bytes follows, representing the address of the transmitting station. The information field is.next, and this field. is ot variable length, depending upon the number of bytes of data to be transmitted an average message is perhaps two or three hundred bytes of ASCII code, but thousands of bytes may be sent In one frame.The data is followed by a four octet frame check sequence which contains a CRC code for checking he addresses and data for errors the receiving station performs this check. The frame concludes in an ending delimiter, followed by a one octet physical control field which contains bits modified by the receiving station as the frame passes through to indicate that the address was recognized and the frame was copied, and also whether errors were detected in the transmitted data. A transmitting station does not reinsert the free token onto the loop until it has received the beginning of its transmitted frame back at its input. Ls soon as it has recognized the starting delimiter, physical control field, destination address, and source address, it transmits the free token and strips the remainder of its transmitted frame. Each of the stations 10 other than the transmitting and receiving stations merely passes the frame on, but does not copy it.A station 10 can perform the following operations on the data stream a if the destination address is not that of the station, it retransmits the data frame without copying it b if the destination address is that of the station, it retransmits the data frame and also copies it c the station can change the state of single bits in the received data such as token or physical control fields before retransmitting d a station can originate the transmission of data to another station e the originating station removes or strips a message frame from the ring that this station has previously trÅansmittedE after the message has gone all the way around the ring this originating station retransmits a free token after it has passed on the starting delimiter, physical control field including busy token , and addresses. Referrring to Fig. 2, each of the stations 10 includes a ring interface 15 which converts the incoming signal on line 13 to the voltage level for internal processing, and recovers the. signal clock fs from the loop signals. The ring interface also produces the outgoing signal on the output line 14 at the proper voltage current level, based upon a transmit signal on line lug . The incoming serial data on line 13 applied to a protocol handler device 16 which is a single chip integrated circuit which implements the functions a f listed above. The serial data is converted to parallel data in a register 17, and if the data is to be copied to parallel data in a register 17, and if the data is to be copied the bytes of incoming data are coupled by a FIFO bufer 18 to a data bus 19. A essage processor chip 25, another single chip integrated circuit contair.ng a local CPU 21 and a local RAM memory 22, receives the nco ng data by DMA to RAM22 via local aPdress data bus 23 and local control bus 24 The 2message processor also contains a general purpose timer 25 and a bus arbitrator 26, both coupled to the local bus 23 and control bus 24. The programming for the local CPU 21 of the message processor 20 is contained within a ROM 27 which is accessed by address bus 28 and data bus 19 extensions of the local bus 23 the ROM 27 is located on the protocol handler chip 16. The incoming data, copied into the local RAM 22 byDMA, is then copied into the host processor 12 by DMA through a system interface chip 30, which is another single chip integrated circuit. The host processor 12 contains the host CPU 31, a main memory 32, and varions peripheral devices 33 which would couple to the CRT, keyboard, disk drive, etc. A main address data bus t4, and control bus 35, interconnect these elements. The host CPU 31 may be a part number 68000, or a 8086 device, as the interface device 30 accomodates the control and data formats of either. The host processor 12 sends a message to another host processor 12 of the communications loop by first forming a message frame in its RAM 32 with destination address, its own address, and the bytes of data to be sent as the message. This frame is copied into the local RAM 22 by DYZ or memory mapped I O through the system interface 30 and local bus 23. The message frame stays in the local RAM 22 until a free token is received and recognized by a decoder 36 in the protocol handler 16 when this occurs controllers in the protocol handler begin to fetch the frame from the local RAM 22 by DMA through local bus 23, data bus 29, and a FIFO 37, from which the data is seriÅallized in a shift register 38 and goes out through a multiplex 39 to the output line 1 . If the incoming data on the line 13 is not to be copied in this station, it does not reach the busses 29 or 23, nor the local RAM memory 22, but instead is applied through multiplexer 32 to the line 14 . THE LOCAL CPU Microprocessor devices with internal test of the invention to be described herein may be of various configurations in this embodiment the microprocessor device takes the form of the chip 20 containing the localCPU 21 used in the system shown in Figure 2. The microprocessor device 20 is a single chip MOS LSI device having the local CPU or central processing unit 21 as will be described indetail, along with local a read write static random access memory 22. The CPU 21 and memory 22 communicate with one another by a 16 bit, parallel, bidirectional, multiplexed, address data bus 23, along with the control bus 24. Suitable supply voltage and clock terminals are included for example the device may employ a single 5V Vcc supply and ground or Vss, and a crystal may be connected to terminals of the device to control the frequency of an on chip oscillator which will then define the I local timing.It is understood that concepts of the invention may be used in various single chip microcomputer or micrporocessor devices with on chip memory or off chip memory, as well as in a microprocessor having separate address and data busses instead of the bidirectional bus 23. In general terms, the local CPU 21 of Figure 2 functions in traditional manner. The CPU 21 fetches an instruction by sending out an address on the bus 23 and bus 28 to the ROM memory 27 then receiving the instructon via the bus 19 and bus 23 from the addressed location in the ROM memory. The CPU 21 then executes this instruction, which usually requires several machine cycles as defined by the clock or crystal including sending out via bus 23 addresses for the operands stored in the RAM memory 22, and receiving this data back on bus 23, as well as writing a result into RAM memory 22 by applying an address followed by data in successive cycles on the bus 23. In the example to be described in detail, a 15 bit address is applied to the bus 23 from the a will dir 16th bit is hardwired 0 for k words of me which will directly address seen bytes or 32K words of memory in the RAM 22 andROM 27 as seen in the memory map of Fig. 2b. Each 16 bit word in memory includes two 8 bit bytes, so the CPU addreses 64k bytes. The local CPU 21 of Figure 2 employs a memory to memory architecture in which the register files or working registers used by the CPU reside in the RAM memory 22. The RAM memory 22 is avaible for program or data storage, or for workspaces as seen Figure 2c.The first word of a workspace is addressed by a workspace pointer always an even he works and the remaining fifteen words are addressed by the workspace pointer plus 02 up to 1E a 4 bit binary address . Definitions of the functions of the control lines 24, the status bits for a sixteen bit status register ST, and interrupt levels are similar to Tables of U.S. Pat. this spec incorporated is herein by reference. Of course, this specific microprocessor is merely illustrative of contemporary microprocessors or microcomputers in which features of the invention may be used. The CPU 21 of Figure 2 executes the instruction set described in Table A and listed in Table B, although it is understood that other instructions could be the defined for execution in addition to or in place of the particular ones described. Most of the instruction set of Tables A and B is the same as that of a microprocessor sold b ye Texas Instruments under the part number TMS9900 and described in a book entitled 9900 Family Systems Design , published in 1978 by Texas Instruments Incorporated, P.O.Box 1443, MJS 6404, Houston, Texas 77001, Library ofCongress Catalog No. 78 058005 such book is incorporated herein by reference. The processor architecture within the CPU 21 is shown in block diagram form in Figure 3, in chip layout form inFigures 4 and Ila, and in logic diagram form in Figure 5 and 6. Generally, the CPU includes an ALU or arithmetic logic unit 40 along with its associated registers, controls, data paths and related logic circuitry. The ALU 40 consists of sixteen parallel binary adder logic stages which function as the computational component of. proee ssor. The ALU 40 receives a 16 bit input 10A and a 16 bit input lOB to produce a 16 bit parallel output 10C. The input 1OA of the ALU is from a 16 bit parallel A bus. The data on these internal busses is active low the indicators A, A , or NA should be used in referring to the bus data to be technically accurate. The A bus may receive data from any one of several sources, with selection of inputs being made by microcode control inputs 41. Similarly, the input 10B is from a 16 bit parallel B bus which may receive data from any one of several sources as defined by control inputs 111. The output 10c from the ALU 10 goes to either a P bus or an E bus under control of microcode bits on lines 41. The ALU performs all the arithmetic and logic functions required to execute microinstructions in the CPU such as the functions of addition, subtraction, AND, OR, exclusive OR, complement, etc., as needed to execute the instructions ofTable A. The CPU 21 has a number of registers associated with the ALU 110, only three of which are accessable to the programmer. These three are a program counter or PC register, a workspace pointer or WP register, and a status register ST. Other internal registers which are used during the acquisition or executon of instructions are inaccessable to the programmer. The program counter PC is a 15 bit counter that contains the word address of the next instruction following the instruction currently executing. The fifteen stages are left justified with the 16th bit hardwired to 0 instructions in the memory 27 are constrained to word boundries, so a single byte is not accessed only even addresses words can be used. The CPU 21 uses the address in PC to fetch the next instruction from ROM memory, then program counter PC increments while the new instruction is executing. If the current instruction in the CPU 21 alters the contents of.the program counter PC, tben a program branch occurs to the location in ROM memory specified by the altered contents of the program counter.All context switching operations, such as interrupts, plus simple branch and jump instructions, change the contents of the program counter. The program counter can be loaded from the E bus by lines EPC, or its contents applied to the B bus via lines PCB, or alternatively to the P bus via lines PCP. All such transfers to or from the program counter are defined by microcode control inputs 41, of course.Internally, the program counter PC includes binary add circuitry to add one to the count contained in the 15 bit register at the proper time, again under control of an input 41. The status register ST is a 16 bit register that contains the results of comparisons, indicates status conditions, and supplies interrupt mask level to the interrupt priority circuits. Each of the sixteen bit positions in the status register signifies a particular function or condition that exists in the CPU 21 these bit position assignments are shown in the patent 4,402,044. Some instructions use the status register ST to check for a prerequisite condition others affect the values of the bits in the register and others load the entire status register with a new set of parameters. Interrupts also modify the status register. All sixteen bits of the status register ST may be loaded form the E bus via lines EST or loaded onto the E bus via lines STE, upon a command on the control lines 41. The CPU 21 uses blocks of words in its local RAM 22, called workspaces, for instruction operand manipulation instead of internal hardware registers. A workspace occupies sixteen contiguous memory words as inFigure 2c, in any part of local RAM 22 that is not reserved for other use. The individual workspace registers may con.tain.d2ta or addresses, and function as operand registers, accumulators, address registers, or index register, A large number of these 16 word workspaces may exist in the 32K words of the memory address space, providing a high degree of program flexibility. To locate the workspace in local RAM 22, the hardware register called the workspace pointer WP is used.The workspace pointer WP is a 15 bit register left justified with 16th or LSB hardwired to 0 that contains the memory address of the first word in the 16 word workspace as illustrated inFigure 2c. The CPU 21 accesses any register in the workspace ofFigure 2c by adding twice the register number R to the contents of the workspace pointer WP and initiating a memory fetch for that word. The 16th bit is zero so this is equivalent to adding two times the register number toWP. Figure 2c illustrates the.relationship between the workspace pointer and its corresponding workspace in memory. The WP register is loaded onto the B bus via lines SPB, or loaded from the 1 1 bus via lines DIWP, under command of dertain control lines 41 from the control ROM. This workspace concept is useful during operations that require a context switch, which is 2 change from one program to another, as in the case of a subroutine or an interrupt. In a conventional multi register CPU, executing a context switch requires that at least part of the contents of the registers file be stored and reloaded, requiring a memory cycle to store or fetch each word. TheCPU 21 accomplishes this operation merely by changing the contents of workspace pointer WP. A complete context switch requires only three store cycles and three fetch cycles, exchanging the program counter PC, status registerST, and workspace pointer WP. After the switch, the workspace pointer WP contains the starting address of a new 16 work workspace Figure 2c in local RAM 22 for use in the new routine.A correspnding time savings occurs when the original context is restored. As seen in Table A, instructions in the CPU 21 that result in 2 context switch include Branch and Load Workspace Poit er BLWP , Return from Subroutine RTWP , and an Extended Operation XOP instructions these are in addition to a ice interrupts, the arithmetic overflow interrupt, and others which also cause a context switch by forcing the CPU to trap to a service subroutine. The internal registers not accessable to the user programmer in the CPU 21 include a memory address or MA register, a data or D register, and a K register. The D register is connected as input to a swap bus S via parallel lines DS, and a swap bus output on lines SK may be applied to th K register, all under control of microcode commands on the lines 41 from the control ROM.The D register functions principally as a data output latch, and is loaded from the E bus via lines ED. The D register is applied to a DI bus by sixteen parallel linesDDI. The data path from the output 10C of the ALU to the E bus and thus to the D register via lines ED, then to theDI bus via lines DDI and the A input of the ALU via the A bus is useful in divide routwnes, for example. Priarily, however, CPU output data is loaded into the D register from the E bus, then to swap bus S via lines DS, and then to sixteen address data buffers 42 via lines 43, and thus to the local address data bus 23.Data can be transferred onto the swap bus S straight or swapped, depending upon factors like byte operations being performed these transfers. are of course under control of microcode commands on lines 111. The address data buffers 42 are sixteen bidirectional, tristate buffers of conventional form, each having an input output terminal connected to one of the local bus lines 23. These buffers usually receive addresses from the P bus via lines 1111, or data via lines 43, for output to the bus 23 for input to the CPU 21, program or data words are applied via lines 43 to the swap bus S, thence to the K register via lines SK. it is also possible to ipad the P bus from the K register via linesPK, under a microcode conmand on a line 41 , and thus output the K register via the P bus. The addresses to local memory 22 or the ROM 27 are usually sent out from the CPU 21 via the P bus which is loaded by sixteen lines MAP from the MA register. The bits in this register can also be transferred to the B bus via parallel lines MAB, thus to the B input lOB of the ALU alternatively the MA register may be loaded from the E bus via lines EHA or from the K latch via lines KMA, all as defined by microcode control lines 111. Another internal register transparent to a user is the temporary or T register. This register receives a 16 bit parallel output 70F from the ALU 110, and applies its output to the B bus in three ways either directly via lines TB, shifted left via path TLB or shifted right via path TRB. The T register can also recieve the B input lOB to the ALU delayed by 3 4 of a clock cycle by a path BT.The T register provides an important function in executing microcode for multiply and divide operations. A register also used in multiply and divide operations is referred to as the MQ shift register for multiplier quotient . This register has the capability of right shift or left shift by microcode commands on lines 41. The register may be loaded from the A bus or the DI bus by 16 bit parallel lines AMQ and DIMQ, or may be outputted to the E bus or the B bus via lines MQE or MQB. An instruction register IR provides the usual function of containing the current instruction, the instruction being executed during a given microcode state time machine cycle . The instruction register IR is loaded from the DI bus via lines DIIR, or may be loaded into the E bus via lines IRE, under microcode control via lines 41. Various fields of the instruction going to IR also can. go to A bus by 2 bit and 4 bit connections 1R2 and IR4. During each cycle, however, the contents of the instructions register IR are transferred via sixteen parallel lines IR0 IR15 to entry point and microcontrol generator circuits as well as miscellaneous control circuitry. The microcode control signals 41 are generated in a control ROM 45 which is in this case split into two halves, 45H for the high side and 45L for the low side of the ALU and registers. Since there are many controls 41 used on only part of the bits, high or low, rather than all sixteen, space is saved by splitting the control ROM 45 in this manner. Each half of the control ROM has an X array 45X and a Y select array 115Y.Buffers 45B for each of the lines 41 receive the select outputs from the Y array 115Y and introduce clocks or other logic as may be needed to produce the controls in the lines 111. The number of microcontrol lines Ul is about 130, depending upon the instruction set Table A to be implemented, well within the addressing range 256 of an 8 bit address on lines 46 that go to both sites 45H and 45H. The first of these 8 bit control ROM addresses on lines 46 is generated by entry point logic, and subsequent ones by a microjump circuit for executing a given instruction. Microjump addresses, produced on eight lines 47 which recieve outputs 41 from the control ROM, can generate a jump address for the next state.The microjump address on lines 47 is fed back to a logic array 48 that can also generate an entry point from inputs received from an execute entry point array 4 9E or a source destination address entry point array 49A. A group detect circuit 50 receives the 16 bit instruction word from IR as well as status bits from ST another controls and produces two inputs to the entry point arrays 49A z A and 49E, first a group identfiation and second a field. The group is determined by the left most 1 of the opcode as seen in Table B, and the field is three or four bits starting after the left most 1. The address to the control ROM 45 on the lines 46 may also be held in an 8 bit latch 51 so the same state is re executed as in multiply or. divide instructions to this end a 4 bit state counter SC is provided which counts microcode state times up to sixteen, and an overflow output of the state counter SC can control release of the holding latch 51. Thus, standard operation of the processor as distinguished from test mode as will be described is controlled by instructions loaded into the IR register to generate an entry point via group detect 50 and logic arrays 48, 49A, 49E the entry point is a starting address for the control ROM 45 entered on address lines 46. This address results in a specific set of microcode commands on the control lines 41 some lines 41 will be active and most not.The address may also produce a jump address on lines 47 to define the controlROM address for the next microcode state, or the next state may be another entry point, or may be the same state due to the holding latch 51. When the last state needed for the instruction is reached, the next instruction is loaded into register IR and another entry point derived. interrupt codes received by the CPU 21 are applied to interrupt control circuitry 43. Bits 12 15 from the status register ST are also applied to the circuitry 43 to provide the interrupt mask for comparison with a interrupt code from external. The control bus lines 24 are connected to control generator circutry 44 which responds to lines 41 from the control ROM as well as to other conditions within the chip, and to the lines 2, to produce the necessary controls internal to the CPU and external to the CPU on control bus 24 . 0 and its which aids in the test method is that theALU 110 and its associated registers K, D, MA, PC, WP, T, MQ, ST and IR as described above are laid out on anMOS LSI chip in a regular strip pattern as seen in Figure 4a. Each of these registers as well as the ALU contains sixteen bits or stages which are laid out the pattern like memory cells, the bits of the registers arranged in parallel lines, and the busses perpendicular to these lines.The A, B, DI, E and P busses of Figure 3 are each sixteen parallel metal strips on top of the cells of theALU 40 and registers rather than beside the registers aa depicted in Figure 3 , and all of the dozens of control lines 41 are perpendicular to the metal busses as and composed of polysilicon lines since they function as the control gates for transistors in the ALU 40 and registers of the CPU. The space needed in the control ROM 45 to generate the controls is about the same as the space needed for the controlled circuitry. This layout arrange ent is advantageous when used it the wide word control ROM or decoder of U.S. Pat. 4,402,043 because it fits alongside the control ROM with little wasted space for routing conductors.That is, almost all bus lines A,B, DI, E and P etc., and all control lines 41 are routed over or under functional regions or cells of the chip rather than over unused silicon, and almost all 90 degree turns are produced inherently at functional cells rather than in conductor routing. The enlarged view of Figure 4a shows a small part of the ALU 40 and registers, illustrztng the regular pattern of metal bus lines and the polysilicon control lines 41 for an N channel silicon gate MOS device made generally according to U.S. patent 4,055,444, assigned to Texas Instruments. It is significant to note that most of the connecting lines such as KDI, ED, EMA, MAB, DIMP etc. as mentioned above are not physically lines or elongated conductors at all but instead are merely metal to silicon contact areas along the metal bus lines of Figure llz. That is, routing of 16 bit parallel conductors is minimized by the strip feature.THE ALU AND REGISTER CIRCUITS The detailed circuits employed in the ALU 40 and its associated registers will be described with reference toFigures 5a 5g. These circuits fit together as seen inFigure 3. Generally, only one bit of the sixteen bits is shown in a strip. For the most part the remaining fifteen bits are the same as the one shown in detail, with some exceptions. The ALU Referring to Figure 5e, one Of the bits of the ALU 40 consists of a complex logic circuit having its input ICA connected to the A bus and its inputs 10B connected to the B bus while its output 1 OC is connected by transistors 10a and 10b to the E and P busses.respectively. The transistors 10a and 7 Ob have connected to their gates control lines rll labelled R1ALtE and 1ALtF, respectively. In this description, the convention used for labelling commands or control lines 41 is a clock phase such as Hl or half 1 , then b the source such as AL for ALU , and c t or f for to or from, followed by d the destination such as P or E bus.The half and quarter clocks are shown in the timing diagram of Figure 2d. Using this convention, H1ALtP means this control 41 occurs during the H1 or hair l clock and defines the connection from ALU to the P bus. An input to the A bus from the DI bus by line DIA and transistor 10c is controlled by an HlDItA command on a line 41, translating as DI to A, on H1 clock . Carry in and carry out for this bit are on lines Cout and Cin respectively, which are connected to adjacent stages of the ALU. The carry out line is precharged to 1 or Vcc on Q1 by transistor 10d, then conditionally discharged afterQ1 goes low by a transistor lOe. A NOR gate 10f drives the gate of the transistor 10e based upon a S1STOPG input on one of the control lines 41 meaning stop generate, on S1 , and the voltage on a node 10g. The output of gate 10f is the carry generate condition, and is made unconditionally 0 if STOPG is active. The node 10g, precharged to 1 on Q1, is connected to 2 node 10h by a transistor 10i which has the inverted A input on its gate.Similarly in the carry propagate circuit a node 10j is precharged to 1 on Q1 and is connected by a transistor 10k also receiving inverted A input to a node 1Om. The nodes 10h and 10n, precharged to 1 on Q1, are conditionally discharged by complex NAND NOR logic circuit including transitors lOo driven by the B and B input inverted and twice inverted , along with transistors 10p driven by the four control lines 11 labelled ALU1 to ALU4 all valid onH2 . The four controls ALU1 ALU4 define the operation performed in the ALU as set forth in Table C.The H3Logic control on a line 41 is the arithmetic logic control when this line is high the ALU performs logic functions by unconditionally grounding the Cin line by transistors i0q, but when low Cwn is applied to, an input of an exclusive NOR circuit 10p, the other input being the inverted propogate signal from node 10j, The propagate signal also drives the gate of a transistor 709 in conventional manner. A 8 carry input to the LSB of the ALU 110 is produced by microcode controls 41. A CIfCO or carry in from carry out control applies the carry out from the MSB of the prior state to the carry in at the LSB for the current state. A STCIN control applies the status bit 3 to the carry in. A CIN control produces an unconditional carry in to the LSB. The Workspace Pointer Register A detailed circuit diagram of the workspace pointer register WP is shown in the lower part of Figure 5c. This register includes two static inverter stages WPa with an input node W b connected to the output for feedback during H2. The input node can be loaded from the DI bus by a transistor WPc having an H4WPfDI WP from DI, on H11 command on its gate. An intermediate node WPd is connected to the B bus via an inverter WPe and a transitor WPf which hasa command H1WPTB WP to B on H1 on its gate. Fifteen bits are exactly the same, and bit sixteen is a hardwired o or Vss. In addition to functioning as the workspace pointer, the register WP is used as the B input to the ALU 40 when gene rating the source arid des t i nat ion addresses for typical instructions of Table A. In a context switch, WP is saved by writing into memory 22, and the path for this operation is the B input of the ALU 40 and the P bus. WP is loaded from off chip by the DI bus.The Program Counter and Incrementer Also seen in Figure 5c, the program counter PC consists of a pair of static inverters PCa having an output node PCb connected to an input node PCc on Q2 by a transistor PCd. The input node PCc may be loaded from the vertical E bus by a transistor PCe having H4PCfE PC fromE, on H4 on its gate this signal is on one of the control lines 41 running horizontally through the register matrix. The output of the program counter at an intermediate node PCf is connected to the gate of a transistor PCg, from which the program counter contents may be read out onto the vertical P or B busses by transistors PCh or PCi and lines PCP or PCB.The signals to control these transfers are H1PCtP PC to P, on H1 and F1PCtB PC to B, on H1 on separate horizontal control lines 41. The program counter is incremented when an 3 INC signal appears on one of the control lines 41, turning on 2 transistor PC on H1 a transistor PCk turns on, loading the contents of this bit of the program counter onto the gate of a transitor PCm in series with a carry line PCn from the prior bit. Each bit of the carry path is precharged to 1 on Q1 by a transitors PCp. The carry in for each bit on line PCn is connected by a NOR gate to the gate of a transistor PCq the NOR gate also has the H4 PCfE signal as one input.This circuit causes a carry to be propogated if the bit is 1 and carry in is 1 or causes the bit to go from 0 to 7 if the carry in is 1.The LBS stage is a hardwired 0 because only the 15 bit word address is send out on the bus 4 the 16th bit is the byte address which is not used for access. For byte operation using the odd numbered byte, the next lower even number is the address then the byte swap circuitry S is activated. Thus, the 16th bit of the address is always 0All the other fifteen bits are identical to that shown inFigure 5c. The carry out from the last bit is truncated as it would represent address FFFF in hex .The Memory Address Register One bit of the MA register is seen in detail in the upper part of Figure 5c. This register includes a pair of standard inverters MAa and MAb in each of the sixteen bits with feedback by a transistor MAc clocked on H2. The register is loaded from the E bus via sixteen separate lines EMA and a transisto r MAd in each line. The gates of the sixteen transistors MAd are driven by a signal H4MAfE MA from E, on H4 on one of the horizontal control lines 41. Likewise, each MA register bit is loaded from the K latch by a lines KMA and a transistor MAe which has H4MAfK on its gate. Output from the MA register is taken at an intermediate node between the two inverters which is connected by a transistor MAf to two output transistorsMAg and MAh.An H1MAtP command on one of the control lines 11 turns on the transistor MAg and connects the output to the P bus via line MAP. An H7MAtB command turns on the transistor MAh and connects the output to the B bus via the line MAB. Of course, it is understood that there are sixteen of each of the input and output lines to or from the busses, as is true for the other registers. The MA register is usually loaded via P bus to theA D buffers 12 as a basic part of most instruction sequences. It is usually loaded from the ALU output 10C via the E bus when an address is generated by adding WP 2S, for example, which is usually done for most instructions.The Data Register The D register or data register contains sixteen bits constructed as shown in detail i n Figure Sb, This register stage consists of a pair of inverters Da and Db with a feedback path via transistor Dc clocked on H2. The input of this register is from the E bus via transistor Dd and a line E one of sixteen lines ED , with the transistor Dd being controlled by an Y4DSE D from E command on one of the lines 41. One Or the outputs is from an intermediate node De and a transistor Df which connects to the DI bus by a transistor Dg and one of the sixteen lines DDI. This output is controlled by an H1DtDI D to DI command on a control line 41 which is connected to the gates of all sixteen of. the transistors Dg. The other output from the D register is by sixteen lines DS, each going to he gate of z transistor Sa in the swap circuit S. The output of this transistor inverter is connected to the swap bus Sb by a transistor Sc having a straight command on its gate or a transistor Sd having a swap command on its ga.e. The line 41 connected to the gates of each of the sixteen transistors Sc carries the H2DtSS D to swap straight command, while the line 41 carrying the H2DtSW D to S, swapped is connected to the gates of the transistors Sd.E bus is precharged to Vcc via Dh and Dd. The D register most often functions to receive the data output from the ALU 40 via the E bus. Also, it functions as the source of an ALU operand input to the A side via the DI bus and the A bus. The D register is used mainly for data output, and also in ready and hold conditions and in divide operations, for example.The K Latch The K register or K latch contains sixteen identical stages, one Of which is shown in Figure ith The K register uses two standard inverters Ka s connected feedback on HI by a transistor Ke The output is connected to the gate of an inverter transistor Ke which is connected to output transistors turns on A he transistor K to P on one he the lines 41 turns on the transistor to and connects the output of the K register to the P bus via line of A transistors Kg a Kg to DI turns on each of the sixteen transistors Kg and connectes the output to the DI bus by sixteen lines KDI. The K register is loaded from the swap bus S in either straight or swapped condition by transistors Ki and Kj. The command H3KfSS on one of the control lines 11 connects the swap bus to the input of theK register via sixteen transistors Ki while a command transistors Kj the swap bus to the input of K byte sixteen transistors Kj for swap or byte operations. The Swap Circuit The swap circuit S shown in Figure Sa functions to connect the 16 bit D register to, or the K register from, the A D buffers 42 via lines 43, either straight or with the high and low bytes swapped. Addresses are usually transferred in or out via the P bus that is connected to the A D buffers without going through the swap bus, since addresses need not be swapped in byte operations, only data. Thus, data comes in via the K register and goes out via the D register, both using the swap bus S.The Temporary Register In Figure 5d one stage of the sixteen stages of the T register or temporary register is seen in detail. This register consist of two standard inverter stages Ta andTb with feedback on H2 via transistor Tc. Output from theT register is from a node Td at the output of the inverters, via an inverting transistor Te to a node Tf precharged to Vcc on Q3 via transistor Tg. A H1NLDI command on one of the lines 11 controls a transistor Th in series with transistor Te. Output from the node Tf directly to the B bus is by a line TB and a transistor Ti controlled by a HlTt B T to B command on a horizontal line 41. To shift left, the node Tf is connected by a transistor Tj to the B bus in the next more significant bit, to the left, via line TLB.To shift right, the nodeTf is connected by a transistor Tk to the B bus in the next lower significant bit, to the right, via line TRB. The transistors T and Tk are controlled by commandsH1TSLB and H1TSRB on two of the horizontal lines 41. The T register is loaded from the B bus by a line BT and a transistor Tm clocked on Q3 along with an inverter Tn and a transistor Tp which has H1TfB on its gate. This input is delayed by 3 4 of a clock cycle. The transistor Tp at the inverter output has its output to the input node Tq to load the T register. The transistor Tr at the inverter output and a transistors Ts with H1TfB on its gate goes to node Tf as a path for replacing the 3 bus information on the B bus after a delay. Thus, B1TfB followed by HlTtB is a quicker path than loading T register then reading it out onto the B bus in the next cycle.The F output from the ALU 10 is connected to the input Tq through a transistor Tt, and to the gate of a transistor Tu. The transistor Tu is in series with a transistor Tv, and bothTu and Tv are controlled by B1T F. The output of the transistor Tv goes to the node Tf as an output from F to the B bus, which may be either straight, left shifted, or right shifted.The MQ Shift Register The is register consists of sixteen bits, one of which is shown in Figure 5f. This register may be shifted left or right by controls 41 and so is used in multiply and divide instructions. Also, the register can be used as a general purpose working register. To this end, an input node MQa may be loaded from the E bus via transistor MQb and line EMQ by control H4MQfE, or loaded from the DI bus via transistor MQc and line DIMQ by control H1MQfDI.Feedback on Qe is provided by a transistor MQd, and the output of the first stage is connected to the input of the second is during id by a transistor MQf The left shift function is provided a a transistor the connecting the input node MQa to a node MQg in the next lesser significant bit Of the register, this occurring when a command r this appears on one of the lines 41. The HD4 prefix for this control means that it occurs at H4 in the next state time, or delayed one clock ontrol from the time this microcode is generated in the control ROM 45.The right shift function is produced when an 94MQSR control occurs on a line 41 turning on a transistor Qh to connect the node MQa to the input node, MQa Or the next more significant bit of the register. The contents of the MQ register are applied to the E, P or B busses by a circuit consisting of an inverter MQi and inverter transistor MQj connecting input node MQa twice invertec to output nodeMQk. The output node MQk is connected by transistors MQm to the B, P and E busses when H1MQtB, E1HQtP or ED1HQtE commands occur. The output MQn of the first inverter MQp is connected to the input of the second stage by a transistor MQq on H4MQfE, when MQb is actvated.The Status Register One bit of the sixteen bit status register ST is shown in Figure 5g. This stages consists of a pair or inverters STa and STb, with feedback on Ql by a transistor STc. An input node STd may be loaded from the E bus through a transistor STe when a commanc H1STfE occurs. Several other input transistors STf may set or load the input node from other sources, such as other controls 111 from the control ROM 45, etc. The output of the status register is taken at an intermediate node STg by an inverting transistor STh with a transfer transistor STI going to the E bus, under control of an HDlSTtE command on a line 41. Among the controls 41 from the CROM 115 are twelve control status signals CS1 to C12 and two set status signals SSO and SS2. These control various transistors STf to set or conditionally set the status bits according to the instruction set of Table A and the status bit definitions. The Instruction Register The instruction register IR is a sixteen bit register, one bit of which is shown in Figure 5g, containing two inverter stages IRE and IRb with feed back via transistor IRe on H2. The instruction register is loaded from the DI bus at input node IRd through transistor IRe on an HVIRLD command. Also, the instruction register may be cleared by a transistor IRf connecting the input node IRd to Vcc on an H1IRCLR command. True a nd complement outputs from the inst ruction register IR are taken at nodes IRg and IRh these outputs go to the group detect 50 as the IRO IR15 and IRO IR1S signals, and are of course used to generate entry point addresses, etc.Coming in, bits which define the addresses of registers in the workspace are fed directly to the A inputs of the ALU for source and destination address generation, under control of eommands 41 before reaching IR. Certain ones of the IR outputs and ST outputs are used in a jump detect circuit 56 Figure 3 to detect any of the jump instructions and or conditions as defined by the instruction set of Table A. The bits received by the jump detect circuit are STO ST3, ST5, STO ST4, IR4 IR7, and IR4 iR7. The group detect 50 receives all fifteen IR bits and complements and determines which of the eleven groups the instruction word falls in. This is based on the position of the leading 1 . Then, the following four bit or in some cases three bit or two bit field of the instruction is used to generate the entry point address in a PLA. The Compressed Control ROM The microcode control signals on, the lines 41 which define the operation of the CPU are generated in a controlROM 45 as seen in Figure 6. According to U.S. Pat. 4,402,043, the control ROM is compressed so that it uses much less space on the chip, and is wide word format so control bits are easily added, such as those used for the test modes. The control ROM 45 generates a different set of microcontrol signals on the lines 41 for each individual address applied to the eight input address lines 46 the address input is split into a four bit X address on lines 46a and a four bit Y address on the lines 46b.For each of the 256 possible address inputs, a unique combination of outputs could be produced, but in a typical embodiment less than 256 are required because an instruction set can be implemented with fewer than 256 states. In CP U which executes, the instruction set ofTable A , for example, ,about 150 addresses or microcode states are. used to selecively activate about 120 to 130 controls 41 including eight microjump addresses for lines 47 . The control ROM 45 is split into an X select portion 45x and a select portion 45Y. The X select portion contains sixteen X lines 45a and a variable number of Y lines, depending upon the degree of compression. The X address on the lines 46a selects one of sixteen of the lines using a standard decoder.MICROCODE STATES FOR REGISTER TO REGISTER ADD OPERATION One of the most common instructions in any processor is add . In the CPU described herein, the add instruction uses workspace addressing. The two operands are obtained from registers in the local RAM 22 via bus 23 and the result is stored in a register in the local RAM 22.Various addressing modes may be used, including direct, indirect, automatic incrementing, indexed, immediate or relative, as explained in Pat. 4,402,044. The example uses register direct addressing for one operand located in the workspace, and register indirect addressing for the other operand which is in a register whose address is located in the workspace the result is stored in the same register which is directly accessed for an operand. This instruction is referred to as ADD R, R in assembly language for programming purposes. Execution of the add instruction of the example uses parts of seven state times or clock cycles. A different set of microcode controls is produced by the control ROM during each microcode state time. The timing sequence of clocks used in the CPR 21 is shown in Figure 2d .and includes four overlapping half cycle clocks B1, H2, Ht andH4. The c lock H4 of course occupies part of the state time after the one in question. Also, a state time contains four quarter cycle clocks Q1, Q2, Q3 and Q4. The device is built using N channel technology, so the clocks are positive going.Typically, the state time is 200 nsec., or the repetition rate is, 5 MHZ. The clock input O to the chip or the crystal frequency is four times the state frequency or about 20 MHZ. The local RAM 22 can be accessed within a state time of the CPU 21, so when an address is sent out on the bus 23 during Q2 of a given state time the contents of the addressed location will appear on the bus 23 for input to the CPU 21 during Q4 or H4 in the same state time. The add instruction of the example requires five memory access operations one to fetch the instruction, one to fetch the address of the source operand, two for the source and destination operands, and one to store the result in the local RAM 22 at the destination location. The instruction for the add operation of this example is fetched before the previous instruction .25 completed execution. This pre fetch increases operating speed. It will be assumed that the prior instruction also used anALU cycle and a destination write, like an add operation, and that the next instruction following the one of the example is also similar to the add operation, to illustrate the pre fetch and overlap of operations. Of the seven microcode state times partially occupied by the a dd operation of this example, the first two are shared with the prior instruction and the last two are shared with the following instruction execution thus only the central three are exclusively used by this add pperation. Referring now to Figure 7 a chart of microcode states for execution of the ADD R, R instruction is illustrated.The seven state, tines to be discussed are designated S1 thr6ug h 37. Briefly, uring 1 which overlaps the prior add instruction the instruction word in question is pre fetched by sending out the address which is in the P register onto the bus 23 to access a location in the memory space ordinarily the ROM 27 which contains program rather than the RAM 22 which is used for workspaces and data then the contents of this location are received back on the bus 23 and loaded into the instruciton register IR, During S2, the result of the prior operation is written into the location in the memory 22 which is in the memory address register Mk the contents of MA register are sent out on the bus 23 followed by the result of the previous add operation.Meanwhile, during S2, the contents of the WP register are added in the ALU Ilo to a number derived from the instruction word pre fetched during S1 this number is two times the source register number, or 25. So, the address of the source register is calculated during S2 and is stored in the MA register, then during S3 this address is sent out on the bus 23 to access the source address contained in the selected register of the workspace, this source address is read from the local RAM 22 and returns.via bus 23 to be stored in MA and K registers in CPU 21. During S4 state time the address of the source operand is sent out from the K register onto bus 23 and the contents at this address in memory 22 returned via bus 23 to the K register. Also during S4 the destination address is calculated in ALU O by adding the contents of the WP register to two times the D field of the instruction word and storing the result in the MA register. Next, during S5, this calculated D address within the workspace, thus direct is sent out from MA register on bus 23 while the operand in the K register is moved to the T register. Then, the contents of the addressed register in memory 22 is returned via bus 23 to be stored in the K register of the CPU 24, stili during S5 Now the add operation is ready to be implemented the S operand is in the T register and theD operand is in the K register.Thus, during state S6 the add operation is executed by adding the contents of K andT and put,ti.nt the result in the D register. Meanwile, however, during S6 the instruction for the next operation is pre fetched by sending out the address in the program counter PC which has been incremented onto local bus 23 and receiving the contents of this address from ROM 27 back via bus 23 to be loaded during S7 in the instruction register IR in CPU 21. Also, during S7 state time, the result of this example add operation is written into memory 2 2 by first sending out the address in the MA register which is the D or destination address calculated during Sol1 onto bus 23, followed by the contents of the D register, completing execution of the ADD R, R instruction.During S7, incidentially, the source address for the next instruction is calculated in the ALU 40 by adding the contents of the workspace pointer WP to two times the S field of the instruction word accessed in S6, so another add operation is already two state times into its execution sequence. Accordingly, the states 56 and S7 correspond to the states S1 and S2 of Figure 7. The instruction word for ADD Rf, R is shown inFigure 7a. This is the sixteen bit word which is read during S1 state time in Figure 7, i.e., the contents of the location addressed by the PC register, in this example. The first 3 bit field 010 says add . The B field, bit 3, defines whether this is a byte operation or 2 word operation in this example it is 2 word operation.If B 1, the operands are bytes and the operand addresses are byte addresses. With B O, the operands are words.The TD and TS fields, bits 4, 5 and 10, 11, determine the addressing mode of that operand. In the example, TS is 00 so the S field bits 12 15 contains the register number in tbe workspace which has the source operand. TD is 01, meaning indirect workspace register addressing mode, so the D field bits 6 9 contains the register number in the workspace which has the address of the destination operand in it. Considering the execution of the ADD R, R instruction example in more detail, it will be noted thatFigure 7 also shows the contents of the various registers and busses as a function of time, as well as other features. Each of the register and bus operations will be examined for each microcode state time, along with the control signals produced on the lines 41 to produce these operations. IN the S1 state time of Figure 7, the control line 41 for H1PCtP see Figure 5c is high during H1, turning on transistors PCi and placing the contents of the PC register on P bus. Then the DEN command goes high on H1, so the P bus is loaded into the output bufferes 42 and thus to the bus 23. The program counter PC is incremented during n.3 time by the H3PCINC command on a line 41, turning on trarsistors PC znd PCm of Figure fc, so later at S6 the next instruction in sequence will be accessed.ADEN signal coxes up on H2 on a control line 41 to produce a DEN co and at H3 on one of the lines 24 to enable the memory 22 to put data on the bus 23 beginning at Q4. The instruction word fetched here is valid on the bus 23 beginning at Q4, and is loaded into the K register via lines SK by a control H3 KfSS generated every H3 except when blanked this control turns on the sixteen transistors Ki of Figure 5b. During this state time S1 an add operation for the prior instruction occurs just as will be described for S6, directing the result to the E bus. A control SAMPI on one of the lines 41 causes the interrupt input to be sampled so that if an interrupt is present, a context swl t,c h will occur. Turning no A t the S 2 state time of Figure 7 , the instruction which is in the K register is connected to theDI bus at Q1 when the Q1KtDI command goes high and turns on the sixteen transistors Kg this command occurs everyQ1 unless blanked by 2 control line 41.A command 2StA at H1 causes the S field of the instruction word on the DI bus to be left shifted and connected by four transistorsCa to bit 11 through bit 14 of the A bus as seen in Figure fe. The contents of the workspace pointer register WP are transferred to the B bus at H1 by the HlWPtB command on a line 41 turning on the transistors WPf of Figure 5c. Thus, with WP on the B bus and 2S on the A bus, when the ALU 40 operates at H2 and H3 an output will be produced at node 10C during B3 which is the sum WP 2S . A command ALtE on a line 41 occurs at delayed H1 time, meaning delayed one state time, so at H1 of the next cycle the ALU output is connected by transistors 10a to the E bus. As will be described below with reference to the S7 state, the result of the previous operation is written, into memory 22 from D register which was loaded from the E bus at u4 the ALU 40 loaded the E bus at S2, H1 , the same as F. 1 tor S1 . During the 53 state time of Figure 7, the address of the register which will contain the source address is generated by an ALU operation. In this operation the contents of the workspace pointer register WP are applied to the B bus by an H7WPtB command turning on transistorsWPf and an IR2D command at H1 which applies bit 6 through bit 9 of the instruction register IR to bit 11 throngh bit 14 of the DI bus via the transistors IRe of Figure 5g. The IR2D command in effect left shifts the D field of the instruction word see Figure 7a by one bit to multiply by binary two, then applies it to the A input of the adder via the DI bus.The ALU 40 is in the add condition by default, none of the ALU1 ALU4 commands being present, and the input 10c is applied to the E bus at Hi of the next state time by the HD1ALtE command on the line 41 to the gates of transistors 10a Figure 5d . TESTING OF CPU As thus far described, the normal operation of theCPU 21 in executing the instruction set of Table A has been illustrated. For testing the chip containing the CPU 21, however, it is necessary to add some further capabilities. It is too time consuming, and not totally conclusive, to test a one chip CPU device by executing all of the instructions, because some faults are data dependent. Also, stuck faults, i.e. internal nodes stuck at logic 1 or logic 0, may cause an erroneous result only under conditions occurring rarely. So, as in testing a dynamic memory device, all of the data bits in the registers of the CPU, and nodes in the ALU, must be tested for various patterns of data and controls. This testing is accomplished in the CPU 21 by employing additional microcode in the control ROM 45 which has no function other than test, a d ic is not used in the execution of the standard instruction set of Table A.This test microcode may use unique control lines 41, and microstates, and also will use sets of signals 41 like many existing microcode states for the standard instruction set, but different microjump addresses will be needed because the sequences will always be different from the standard sequences like Figure 7. Each of the register bits of the registers in the CPU may be thought of as a memory element ME of Fig. 8, with an input MEi and an output MEo. The input MEi can receive a data bit from two sources, IN A or IN B, and these input paths are controlled by the control nodes IN 1 and IN 2 which connect to gates of transistors. The output MEo may also be connected to more than one output bus, as seen for the MQ register which can go to P bus or B bus, or theK latch to the P bus or DI bus. However, for simplicity in explanation of the fault flushing concept, only the inputs will be treated. For example, the general form of Fig. 8 correspond s to the two inputs MAfDI and MAfE via transistors MAe and MAd to one bit of the MA register ofFig. Sc, where bits of the Di bus and E bus would correspond to the sources IN A and IN B. A truth table for the circuit of Fig. 8 is shown inTable D. The patterns T to Z are various combinations of inputs data bits IN A and IN B with controls IN 1 andIN 2, showing the memory output MEo for the initialization cycle I T and for the test cycle M T 1 for a good circuit and for a faulted circuit. Each of the fault poss ibli ties are shown for each input these are stuck at one SE1 and stuck at zero SE0. Note that all of these patterns are needed to find all of the possible faults. Pattern T finds stuck at one for either control,IN 1 SE1 or IN 2 S1 . Pattern U and pattern W find stuck at zero for the control bits, IN 1 and IN 2.Pattern X and pattern Z f ind stuck at one for the data bits IN A and IN B. Pattern V and Pattern Y finds stuck at zero for the data bits, IN A and IN B. To implement the test of Table D in the registers of the CPU 21, algorithms are written in microcode, for each register. For example, in the first state the memory element actually all ,sixteen bits of a register at once is initiallized by providing a condition of all input data high this is done by inputting FFFF via the bus 23 withDEN active, and selecting microcode which places this data on the two busses or sources for the selected register, e.g. K register and E bus for MA register, or DI bus and E bus for MQ register bits. The controls for the two inputs are held high at this point, e.g. by KtMA and EtMA microcode pits 41, or DItMQ and EtMQ microcode bits 41.The memory contents are, verified to be high by either 1 outputting this register via P bus and bus 23 for external check by the test machine, or by an ALU operation and jump or interrupt on status depending upon the results. This completes the initiallization cycle I T .Next the pattern T is produced all controls are held off by the appropriate microcode bits 41, and the input data the busses, etc. are held low by microcode controls or data input of zeros. The memory content is checked at this point, as before, and the result interpreted as in TableD, detecting if either control is stuck at one. This sequence can be repeated for each of the registers, and indeed for the A,B, DI or P busses themselves. The difference from ordinary operation is that two inputs are simultaneously trying to drive a node in the test microcode, whereas this would not be used in executing the standard instruction set, and indeed would be highly undesirable.However, this condition is needed for stuck fault detection. errors would certainly turn up in ordinary operation if stuck faults existed but these would be data dependent and ma y require exhaustive and ti e c2nsuin5 patterns on the test machine. Por the other patterns U,V,W,X,Y,Z, tests are made by first initiallizing as described above, and verifying that al memory bits are high. Then the selected pattern is produced by inputting data to the two selected inputs for the selected register according to the values given in the troth table, and also defining the two controls according to tn e truth table, and verifying that the memory is low or tldh as set forth. This is iterated until all possible co tnations are checked. Generally all bits at an input are one or zero, at a given time.Doing this same sequence for all registers of the CPU increases the number of iterations in the loop at this point, but does not add to the number of microcode states since merely the input data, is changed. These patterns check for controls stuck on zero, or data bits stuck on one, or data bits stuck dn zero. One additional test of the CPU 21 is a check of the outputs 41 from the control ROM 45. For this test a shift register SR is included on the chip at the control ROM output, and this shift register is loaded in parallel by the control ROM 45 output by a particular microcode bit fLDCR. In standard operation the outputs 41 are not loaded into SR, but for this test the IrLDSR bit occurs and all 130 or whatever number bits are loaded into SR in one cycle, then for the next 130 cycles the bits are clocked out serially on one of the output pins, such as an address data I O pin of the bus 23. If there are 256 possible addresses for the control ROM 45, then this entire sequence must be repeated 256 times. Addresses for the control ROM are applied to lines 46 from a counter TC, which is an eight bit shift counter, for example, zeroed at reset and incremented every time the microcode bit LDSR is produced. Thus, a selected code input on the four test pins TEST , TESTO, TEST1 and TEST2 as defined inTable E causes the test control circuit to produce the control num LDSR which increments the counter TC, applies the counter output to the address bus 46, producing a set of microcode outputs 41 from the control RÇM 45, which is loaded into the shift register SR rather than executed in the CPU then during the next 130 or so clock cycles this microcode word is shifted out serially one bit at a time, to be compared with the known value in an external test machine. ON CHIP TIMER Referring to Fig, the timer 25 is shown in block diagram form. The timer includes a fixed 512 bit prescale counter 25a which receives the local clock at its input 25b and produces a decrement signal at its output 25c. The prescale counter 25a may be constructed as a pseudorandom shift counter with exclusive OR feedback, as is well known. The output 25e is produced about every 170 microsec, and goes to a timer data register 25d which may be loaded with any 8 bit value by an irput 25e from a timer latch 25f. The latch 25f may be loaded from the local bus 23, and it appears in the memory space accessed by the local bus.The latch 25f can also be read by the CPU 21 via the local bus 23 through path 25g. In li ke manner, the contents of the timer data register 25d can be read by the local CPU 21 via the local bus 23 through path 25h, as this register also appears in te memory space accessed by the local bus. Every time tçe prescaler 25a decrements to zero and produces an output 25c, the register 25d is decremented, so when a count of the value loaded into this register 25d from the latch 25f and local bus has been reached, the register 25d will reach through an all zero condition. This condition is detected by a zero detector circuit 251, which is a NOR gate arrangement of conventional form.An output 25j from the zero detector circuit is connected to the set input of a set reset flip flop 25k, which receives its reset input 25m from 2 certain bit of the MPSTS control register. If the flip flop 25k has been reset, then when it is set by input 25j it produces an output 25n which is used to indicate a timer interrupt to the CPU 21. An AND gate. 25p receives this interrupt signal as one input, and receives a bit from the MPCTL register on input 25q which determines enable or disenable of the timer interrupt. A timer interrupt active signal is thus produced on the line 25r going to the CPU 21, if all conditions are met. The GPTIEN bit in the MPCTL register arid on line 25q is set or reset by the CPU 21 by writing a word to MPCTL.When sets this GPTIEN general purpose timer interrupt enable bit enables a interrupt priority level ten when and if the GPTINT general purpose timer interrupt bit is also set in the MPSTS register on line 25m. if GPTIEN is zero, then GPTINT may be set, but no interrupt is generated. The GPTINT bit is set on the local bus cycle following the decrement pulse of register 25d from a count of one to a count of all zeros. This bit is automatically set by the circuitry, and is reset by the CPU 21 under its program control. It is set when the timer decrements past zero, then is cleared when the CPU 21 writes a word toMPSTS register containing a zero in this bit position.Thus, after an interrupt from the timer, the CPU 21 will not accept another such interrupt unless its program causes this reset. The counter data register 25d is loaded with the contents of the latch 25f via input 25e when either of the following ocurrs the GPTSTART bit of the MPCTL register is toggled from 0 to 1 by writing a word to MPCTL by theCPU 21 or the register 25d decrements to zero. The decrement of register 25d starts when the CPU 21 writes a one to the timer start bit of MPCTL and the previous value of this bit was zero. The local clock at 25b, nominally 3 MHz, is divided by 512 by prescaler 25a and forms a decrement pulse on input 25c of the register 25d. When register 25d decrements to zero, the OPTING bit 25j is set, and if GPTIEN is set at input 25q, an interrupt is asserted to CPU 21 in line 25r. On the local bus cycle following the one which decremented register 25d to zero, the register 25d is immediately reloaded with the value in latch 25f. Hence, the period of the general purpose timer interrupts is 512x cycle time x latch,25 value . In a typical situation, this interrupt should be about ten millisec., i.e. about every thirty thousand maine cycles for the CPU 21. Using registers, in RAM 22 , the CPU 21 generate a number of different timeouts under its program control, based on this hardware timeout.For example, if no free token or starting delimiter appears on the ring 11 for d given time, then it is assumed that a fault condition has occured, and fault detector or corrector signals are sent.BUS ARBITRATION The bus arbiter 26 in the chip 20 is provided to allow the protocol handler chip 16, the system interface chip 30, or another external DMA device to arbitrate for control of the local bus 23. Immediately following system reset by SRESET , the CPU 21 of chip 20 has control of the bus 23, but the chip 16 and the chip 30 can request and gain control of the bus 23 to perform DMA transfers.Following completion of the DMA cycle or cycles, bus control is returned to the chip 20. In order to maintain axi um utilization of the bandwidth of the local bus 23, the request and grant sequences for future bus cycles are overlapped with the bus cycle currently in progress. Arbitration and control of the local bus 23 of the arbiter 26 is coordinated by a bus request bus grant ha.dshake using the LBRQ1 , LBGR1, and LBRQ2, LBGR2handshake pairs on the chip 20, as illustrated in FiguresXa and Xb. The LBRQ1 input from the chip 16 has priority over the LBRQ2 input from the system interface chip 30. The external bus master chip 16 or chip 30 assertsLBRQ1 or LBRQ2 to request the bus, and the arbiter 26 responds to the bus request by asserting L8GR1 or LBGR2 , then floating the address data, LEN , LAL, LI D , LR Wlines from the chip 20 at the completion of the bus cycle. In order of priority, the masters of the local bus 23, as determined by the arbiter 26, are 1 External master on L3EQ1 , the protocol handler chip 16 ,2 External master on LBRQ2 the system interface chip 30 3 internal master from the CPU 21 for microprocessor instruction and data access. W i t h i n t h e s y s t e m i n t e r f a c e c h i p 3 0, t h e memory mapped ISO bus controller has priority over the system DMA bus controller. st the local b that a higher priority bus master may request the local bus 23 while one of the external bus masters has control. That is, the protocol handler chip 16 may request the bus 23 while the an system interface chip 30 has control. This could occur when an incoming message is detected at a time when an outgoing message frame is being copied from memory 32 to memory 22 by DMA.In this case, the following occurs 1 the bus arbiter 26 deasserts LBGR2 in Q3 of the current bus cycle 2 the system interface chip 30 copletes the current cycle possibly with wait states , and tristates its bus signals, leaving LBRQ2 asserted during this time 3 LBGR1 is asserted 4 when the higher priority master, chip 16, has accomplished its DMA task, such as copying an incoming message frame into the RAM 22, it deasserts LBRQ1 , and the bus arbiter 26 then reasserts LBGR2 5 the system interface chip 30 then reassumes control of the bus 23, and completes copying the outgoing data frame.SYSTEM INTERFAGE CHIP Referring to Fig. 2, the system interface chip 30 implements two complete bus interfaces, one to the system data bus 34 and its control bus 35 , and the other to the local address data bus 23. The input and output pins of the chip 30 are described in Table F. Of course, some of the pins are the same as iS Table E since some go to the chip 20. The chip 30 contains two separate controllers. First, a memory mapped I O controller with the MMIO register which manages the references by the host system 12 the host CPU 31 to the memory mapped registers presented by the adapter 10. The second is a DMA controller which performs DMA transfers between the host system bus 34 and the adapter 5 local bus 23. With these mechanisms, a variety of different logical interfaces between the host system 12 and the adapter 10 may be implemented with the code executed in local CPU 21 code stored in ROM 27 . The terms memory mapped I O and system DMA refer to the data transfer mechanisms as seen from the host system 12 side.This is different from registers in the memory space of local bus 23 on the local side of the chip 30. For memory mapped I O, the adapter 10 appears to the host system 12 as a set of eight consecutive byte addresses. Two registers are dedicated to bit level status and control information the program code in ROM 27 executed by the CPU 21 defines the meaning of these bits.The memory ma pped I O unit 61 also maintains an address register into the local data space of the adapter 10, and the host system 12 may indirectly access any RAM 22 or ROM 27 byte in the memory on the local bus. During system 12 or CPU 31 reads or writes to local memory 22 or the local data space, the CPU 21 is locked out of the local RAM 22.With this approach, command and status task blocks maybe writtenby th host CPU ,31 and asynchronously examined by the CPU 21. The memory mapped I 0 unit also places a programma ble interrupt vector on the system bus 34 during system bus interrupt acknowledge cycles. The system interface chip 30 also ,allows for the local CPU 21 to initiate direct memory access between the on chip RAM 22 and the system memory 32 for incoming frame data or command status interchange. This DMA is completely under control of the program for CPU 21 stored in the ROM 27.SYSTEM TRANSMIT To transmit a message, the host system 12 first creates a data frame in its memory 32, under control of the host CPU 31. Then, the CPU 31 writes to the MMIO register of system interface chip 30, which causes an interrupt of the CPU 21, and indicates in the MMIO register the starting address on the system bus 34 of the data frame. The CPU 21 then sets up a system DMA for system to local transfer. This is accomplished by executing program code from the ROM 27 starting at the vector address used for the interrupt. The CPU 21 sets up the following registers LDMA ADR to contain the system bus 34 address for the data frame SDMA ADR to contain the local RAM 22 address via local address data bus 23 for the frame a SDMA CTL control bit is set to start SDMA LEN gives the length of the frame.A system DMA through the chip 30 then transfers the data frame from the system RAM memory 32 to the local RAM 22, using a FIFO in the chip 30 so that transfers of data words from the bus 34 to theFIFO are under control of the system control 64 in the chip 30 and synched to the system clock SBCLK, while transfers from the FIFO to the local RAM 22 via bus 23 are under control, of the DMA controller in the chip 30 and synched to. the locÅal bus clock LB CLK. A cycle on the system control side, if the FIFO is. not full, is as follows . the system side controller requests the system bus 30 the host system 12 sends a bus grant to the chip 30 a word or byte of data is sent from the system memory 32 into the FIFO SDMA LEN register is decremented.These cycles continue until the SDMA LEN register is zero, or until the SBERR system bus error pin is asserted, or the DMAHALT bit of the SIFCTL register is set. A cycle on the local control side, if there is data in the FIFO is the local side controller requests the local bus 23 by a LBRQ1 signal the LBGR1 is asserted by the chip 20 one word of data is written into the local RAM 22 from theFIFO. When the entire frame has been copied from the RAM 32 to the RAM 22 in this manner, the system interface chip 30 again interrupts the CPU 21 to indicate that the DMA is complete. The CPU 21 can then operate on the data in localRAM 22 for checking, reformatting, encrypting, etc. When ready to transmit, the CPU 21 sets up the chip 16 for transmit by writing the local starting address and length of the data frame into two registers of the chip 16. The control of transmit now switches to the chip 16. First the transmit FIFO 37 is filled by DMA from chip 16 into RAM 22 of chip 20, using L3RQ2 and LBGR2 controls. The chip 16 then waits for a free token on the input 13 and 13 from the signal line 11.When 2 free token comes in, the chip 16 changes it to a busy token sets bit to one , and starts sending data from the FIFO 37 through seriallizing register 38 and multiplexer 35 to the output 14 and 14.Whenever the FIFO 37 is not full, the chip 16 asserts a request for the local bus by line LBRQ2 and when it gets a LBGR2 from the bus a,rbiter 26 or the chip 20, a word of data is read from the local RAM 22 to the FIFO 37 the length register is decremented for each word transmitted this continues until the length register is zero. The data rate on the ring 11 may be about four M bit per second or 0.5 M byte per second, in a typical example.The tranfer rate from the local RAM 22 to the FIFO 37 is at a maximum rate defined by the local bus clock or the cycle time of the CPU 21, which is about 333 nsec, for example, meaning 16 bits are transferred every 333 nsec, which is six M bytes per sec. Thus, the FIFO 37 can be kept filled during this transfer using only about 0.5 6 or one twelfth of the cycles of the CPU 21. So the CPU 21 can be doing other operations, merely loosing a cycle now and then for the data transfer to the chip 16 for transmit. Likewise, the host system 12 typically has a system clock of 8 MHz, providing a data transfer rate on the system bus 34 of two M byte per sec, which is four times that on the signal line 11. Thus, the DMA to transfer the frame from the system RAM 32 to the local RAM 22 is,at a higher rate than the off loading transfer from RAM 22 to the FIFO 37 in chip 16 for transmitting. Accordingly, it is possible to interleave DMA from host system 12 to local RAM 22 with DAM by chip 16 to local RAM 22, although this would not be necessary in most of the transmit operations. TABLE A THE INSTRUCTION SETDATA TRANSFER INSTRUCTIONS The MOV instructions are used to transfer data from one part of the memory 2 to another part, or from one location in the memory map to any other. The LOAD instructions are used to initialize registers to desired values. The STORE instructions provide for saving the status register ST or the workspace pointer WP in a specified workspace register.Load Immediate LI Operation The 16 bit data value located at the address given in the word into the immediately following the instruction LI is loaded into the workspace register R specified by the 4 bit field of bits 12 15 of this LI instruction. Applications The LI instruction is used to initialize a selected workspace register with a program constant such Load counter value or data mask.Load Interrupt Mask Immediate LIMI Operation The low order 4 bit value bits 12 15 in the word immediately following this instruction is loaded into the interrupt mask portion of the status register bits 12 15 . Application The LIMI instruction is used to initialize the interrupt mask to control which system interrupts will be recognized.Load Workspace Pointer Immediate LWPI Operation The 16 bit value contai ed in the word immediately following the instruction is loaded into the workspace pointer WP. Application LWPI is used to establish the workspace memory area for a section of the program.MOVE Word MOV Operation The word in the source lo 2tion specified by bits 10 15 of the instruction is transferred to the destination location. specified by bits 4 9,, without affecting the data stored in the sour,ce loc,ation. During the transfer, the word source data is co pared to 0 with the result of the comparison stored n the status register. Applicati on MOV is used to transfer data from one part of the system to another part.MOVE Byte MOVB Operation Like MOV except operates on bytes. Application MOVB is used to transfer 8 bit bytes from one byte location to another.Swap Bytes SWPB Operation The most significant byte and the least significant byte of the wordat the memory location specified by bits 10 15 of the instruction are exchanged. Application Used to interchange bytes if needed for subsequent byte operations. Store Status STST Operation The contents of the status register ST are stored in the workspace register specified by bits 12 15 of the instruction. Application STST is used to save the contents of status register ST for later reference.Store Workspace Pointer STWP Operation The contents of the workspace pointer WP are stored in the workspace register specified by bits 12 15 or the instruction. Application STWP,is used to save the contents of the workspace pointer register WP for later reference. ARITHMETIC INSTRUCTIONS These instructions perform the following basic arithmetic operations , addition byte or word , subtraction byte or word , multiplication, division, negation, and absolute value.Add A Operation The data located at the source address specified by bits 10 15 of the instruction is added to the data located at the destination address specified by bits 4 9. The resulting sum is placed in the destination location, and is compared to zero for setting status bits. Application Binary addition is the basic arithmetic operation required to generate many mathematical functions. It functions as pass when one input is zerc. This instruction can be used to develop programs to do multiword addition, decimal addition, code conversion, and so on.Add Bytes AB Operation Like Add but for bytes instead of words.The source byte addressed by bits 12 15 is added to the destination byte addressed by bits 4 9 and the sum byte is placed in the destination byte location. Useful when dealing with subsystems or data that use 8 bit units, such as ASCII codes.Add Immediate AI Operation The 16 bit value contained in the to word immediately following the instruction is added to the contents of the workspace register specified by bits 12 15 of the AI instruction. Application Used to add a constant to a workspace register. Useful for adding a constant ster. to an address contained in the workspace register.Subtract Words S Operation The 16 bit source data location specified by bits 10 15 is subtracted from the desitination data the desti specified by bits 4 9 with the result is placed in the destination location. The result is compared to 0. Application Provides 16 bit binary subtraction.Subtract Bytes SB Operation Like S except for bytes instead of words. increment INC Operation The data located at the source address indicated by bits 10 15 of the INC instruction is incremented and the result is placed in the source location and compared to 0. Application INC is used to increment byte addresses and to increment byte counters.Increment by Two INCT Operation Two is added to the data at the location specified by the source address in bits 10 15 and the result is stored at the same source location and is compared to O to set status ST. Similar to INC. Application This can be used to increment word addresses, though autoincrementing on word instructions does this automatically.Decrement DEC Operation One is subtracted from the data at the location specified by bits 10 15, the result is stored at that location and is compared to 0. Similar to INC. Application Most often used to decrement byte counters or to work through byte addresses in descending order.Decrement by Two DECT Operation Two is subtracted from the data at the location specified by bits 10 15 and the result is stored at that location and is compared to O. Similar to INC. Application This instruction is used to decrement word counters and to work through wcrd addresses in descending order.Negate NEG Operation The data at the address specified by bits 10 15 of the Instruction is replaced by its two s c,o plement, and the result is compared to zero for setting status ST. Application NEG is used to form the two s complement of 16 bit numbers.Absolute Value ABS Operation The data at the address specified by bits 10 15,,of ,t,he inst,r,u ction, is compared to zera, to set statusST. Then the absolute value of this data is placed in the same location. Application Used to test the data in the specified location and then replace the data by its absolute value.This could be used for unsigned arithmetic algorithms such as multiplication.Multiply MPT Operation The 16 bit data at the source address designated by bits 10 15 is multiplied by the 16 bit data contained in the destination workspace register R specified by bits 6 9. The unsigned binary product 32 bits is placed in workspace registers R and R 1. Application MPI can be used to perform 16 bit by 16 bit binary multiplication. Several such 32 bit subproducts can be combined in such a way to perform multiplication involving larger multipl iers and multiplicands such as a 32 bit by 32 bit multiplication. Divide DIV Operation The 32 bit number contained in workspace registers R and R 1. where R is a destination address specified at bits 6 9 is divided by the 16 bit divisor contained at the source address specified by bits 10 15.The workspace register R then contains the quotient and workspace R ffi 1 contains the 16 bit remainder. The division will occur only if the devisor at the source address is greater than the data contained in R. Application DIV provides basic binary division of a 32 bit number by a 16 bit number.Signed Multiply MPYS Operatidn The signed two s complement integer in workspace register RO is multiplied by the signed two s complement in.teger specified by the source address bits 10 15 . The result is a signed 3 bit product which is placed in workspace register RO for the 16 MSB s and workspace register R1 the 16 LSB s . The result is compared to zero. Application Provides signed multiplication for the system.Signed Divide DIVS Operation The signed 32 bit two s complement integer dividend in workspace registers 0 and 1 is divided by the signed 16 bit two s complement integer divisor specified by the source address bits 10 15 . The signed quotient is placed in workspace register RO and the signed remainder is placed in workspace register R1. COMPARISON INSTRUCTIONS These instructions are used to test words or bytes by comparing them with a reference constant or with another word or byte. Such operations are used in certain types of division algorithms, number conversion, and in recognition of input command or limit conditions.Compare Words C Operation The two s complement 16 bit data specified by the source address at bits 10 15 is compared to the two s complement 16 bit data specified by the destination at bits h 9, and appropriate status ST b its are set baaed upon the resuits ,The co ntents of both locations remain unchange d. Application The need to compare two words occurs in such system functions as division, number conversion, and pattern recogn ition.Compare Bytes CB Operation The two s complement 8 bit byte at the source address bits 10 15 is compared to the two s complement 8 bit byte at the destination address bits 4 9 . and status ST is set.Compare Immediate CI Operation CI compares the contents of the specified workspace register R defined by bits 12 15 to the value contained in the word immediately following the instruction, and sets status bits accordingly. Application CI is used to test data to see if system or program limits have been met or exceeded or to recognize command words.Compare Ones Corresponding COC Operation The data in the source location addressed by bits 10 15 acts as a mask for the bits to be tested in workspace register R specified by bits 6 9. That is, only the bit position that contain ones in the source data will be checked in R. Then, if R contains ones in all the bit positions selected by the source data, the equal EQ status bit will be set to 1. Application COC is used to selectively test groups or bits toXcheck ,the status or certain sub ,systems or to examine.certain aspects pf data words.Compare Zeroes Corresponding CZC Operation The data located in the source address specified by bits 10 15 act as a mask for the bits to be tested in the workspace register R specified by bits 6 9.That is, only the bit positions that contain ones in the source data are the bit positions to be checked in R. Then if R contains zeroes in all the selected bit positions, the equal EQ status bit will be set to 1. Application Similar to the COC instruction. 4 4 4 4 4 4 LOGIC INSTRUCTIONS The Logic instructions allow the processor to perform boolean logic for the system. Since AND, OR, INVERT, andExclusive OR XOR are available, any boolean functions can be performed on system data.AND Immediate ANDI Operation The bits of the workspace register specified by bits 12 15 are logically 1NDed with the corresponding bits of the 16 bit binary constant value contained in the word immediately following the instruction. The 16 bit result is compared to zero and is placed in the register R. Application ANDI is used to zero all bits that are not of interest and leave the selected bits those with ones in value unchanged. This can be used to test single bits or isolate portions of the word, such as a four bit group.OR Immediate ORI Operation The bits of the specified workspace register R are ORed with the corresponding bits of the 16 bit binary constant contained in the word immediately following instruction. The 16 bit result is placed in R and is compared to zero. Application Used to implement the OR logic in the system.Exclusive OR XOR Operation The exclusive OR function is performed between corresponding bits of the source data addressed by bits 10 15 and the contents of workspace register specified by bits 6 9. The result is placed in workspace register R and is compared to zero to set status ST. Invert INV Operation The bits of the data addressed by the source address bits 10 15 are replaced by their complement. The result is compared to zero and is stored at the source location. Application INV is used to form the one s complement of 16 bit binary numbers, or to invert system data.Clear CLR Operation Zeroes are placed in the memory locatin specified by bits 10 15 of the instruction. Application CLR is used to set problem arguments to zero and to ini tialize memory locations to zero during system starting operates. Set to One SETO Operation All ones or hex FFFF are placed in the memory location specified by bits 10 15 of the instruction.Set Ones Corresponding SOC Operation This instruction performs the OR operation between corresponding bits of the source data address defined by bits 0 15 and the destination data addressed defined by bits 4 9. The result is compared to zero and is placed in the destination location. Application Provides the OR function between any two words in memory. Set Ones Corresponding Byte SOCB Operation Like SOC except used for bytes instead of words. The logical OR is performed between corresponding bits of the byte addresed by source address bits 10 15 and the byte addressed by the destination address of bits 4 9 with the result compared to zero and placed in destination location.Set to Zeroes Corresponding SZC Operation The source data addressed by bits 10 15 forms a mask for this operation. The bits in the destination data addressed by bits 4 9 that correspond to the one bits of the source data addressed by 10 15 are cleared. The result is compared to zero and is stored in the destination lc,ation., pplication SZC allows the programmer to selectively clear bits of data, words. For example, when an interrupt has been serviced, the interrupt request bit can be cleared by using the SCZ instruction.Set to Zeroes Corresponding, Bytes SZCB Operation Like SZC except for bytes instead of words. The byte addressed by the source address bits 10 15 will provide a mask for clearing certain bits of the byte addressed by the destination address bits 4 9. The bits in the destination byte that will be cleared are the bits that are one in the source byte. The result is compared to zero and is placed in the destination byte.SHIFT INSTRUCTIONS These instructions ate used to perform simple binary multiplication and division on wards in memory and to rearrange the location of bits in the word in order to examine a given bit with the carry C status bit.Shift Right Arithmetic SRA Operation The contents of the workspace register R specified by bits 12 15 are shifted right by a number of times specified by bits 8 11, referred to asCnt, filling the vacated bit position with the sign most significant bit bit. The shifted number is compared to zero and status bits set. Number of Shifts Cnt number from 0 to 15 contained in the instruction specifies the number of bits shifted, unless Cnt is zero in which case the shift count is taken from the four least significant bits of workspace register ition shift Cnt and these four bits are 0, aApplicati shift is performed o defined by SRA provides binary division by a power of two defined by Cnt.Shift Left Arithmetic SLA Operation The contents of workspace register R specified by bits of are shifted left Dnt times or if Dnt the number of times specified by the least four bits of RO filling the vacated positions with zeroes. Dnt is specified by bits 8 11. The carry contains the value of the last bit shifted out to the left and the shifted number is compared to zero and status bits set. Application SLA performs binary multiplication by a power of two defined by Cnt. Shift Right Logical SRL Operation The contents of the workspace register R specified by bits 12 15 are shifted right Cnt times, whereCnt is specified by its 8 11, or if Cnt 0, the number of times specified by the least four bits or RO filling in the vacated positions with zeroes. The carry contains the value of the last bit shifted out the right and the shifted number if compared to zero. Application Performs binary division by a power of two defined by Cnt.Shift Right Circular SRC Operation Workspace register R defined by bits 12 15 is right shifted Cnt,ti me defined by bits 8 11. On each shift the bit shifted and the shifted number is compared to 0. The,number of shifts to be performed is the numberCnt, or if Cnt 0, the number contained in the least significant four bits of RO. Application SRC can be u sed to examine a certain bit in the data word, change the location of 4 bit groups, or swap bytes. 4 4 4 4 UNCONDITIONAL BRANCH INSTRUCTIONS These instructions give the programmer the capability of choosing to perform the next instruction in sequence or to go to some other part of the memory to get the next instruction to be executed. The branch can be a subroutine type of branch, in which case the programmer can return to the point from which the branch occurred.Branch B Operation The source address, defined by bits 10 15, is placed in the program counter, causing the next instruction to be obtained from the location specified by this source address. Application This instruction is used to jump to another part ,of the program when the current task has been completed.Branch and Link BL Operation The source address defined at bits 10 15 is placed in the program counter and the address of the instruction fol lowing the. BL instruction is saved in workspace register R11. Application This is a shared worspace subroutine jump. Both the main program and the subroutine use the same workspace registers. To get back.to the main program at the branch point, a BL instruction can be used at the end of the subroutine which causes the R11 contents oldPC value to be loaded into the program counter.Unconditional Jump JMP Operation The signed displacement defined by bits 8 15 is added to the current contents of the program counter PC to generate the new value of the program counter. The location jumped to must be within 128 to ,127 words of the present location. Application If the subprogram to be jumped to is within 128 words of the JMP instruction location, the unconditional JMP is preferred over the unconditional branch since o n y one memory word and one memory reference is required fr the J.P while two memory words and two memory cycles are required for the B instruction.Thus, the JMP instruction can be implemeted faster and with less memory cost than can the B instruction.Execute Operation The instruction located at the source address specified by bits 10 15 is executed. Application X is useful when the instruction to be executed is dependent on a variable factor.Branch and Load Workspace Pointer BLWP Operation The word specified by the source address bits 10 15 is loaded into the workspace pointer WP and the next word, in memory source address 2 is loaded into the program counter PC to cause the branch. The old workspace. pointer is stored in the new workspace registerR13, the ol d PC value is stored in th e new workspace register R14, and the status register is stored in new workspace register R15. Application This is a context switch subroutine jump with the transfer vector location specified by the source address. It uses a new workspace to save the old values of WP, PC, and ST in the last three registers . The advantage of this subroutine jump over the BL jump is that the subroutine gets its own workspace and the main program workspace contents are not distributed by subroutine operations.Extended Operation XOP Operation Bits 6 9 specify which extended operation transfer vector is to be used in the context switch branch from XOP to the corresponding subprogrzz. The effective source address, bits 10 15, is placed in R11 of the subprogram workspace in order to pass an augment or data location to the subprogram. Application This can be used to define 2 subprogram that can be called by a single instruction. As a result, the programmer can define special purpose instructions to a augment the standard instruction set for the processor.Return with Workspace Pointer RTWP Operation This is a return from a context switch subroutine. It occurs by restoring the WP, PC, and ST register contents by transferring the contents of subroutine workspace registers R13, R14 and R15, into theWP, PC and ST registers , respectively. Application This is used to return from subprograms that were reached by a transfer vector operation such as an.interrupt, extended operation, or BLWP instruction.CONDITIONAL JUMP INTRUCTIONS JH, JL, JE, JLE, JGT, JLT, JEQ, JNE, JOC, JNC, JNO, JOP These instructions perform a branching operation to a location defined by bits 8 15 only if certain status bits meet the conditions required by the jump. These instructions allow decision making to be i corporated into the program. The conditional jump instruction mnemonics are summarized below along with the status bit conditions that are tested by these instructions. Operation If the condition indicated by the branch mnemonic specified by bits 4 7 is true, the jump will occur using relative addressing as was used in the unconditional JMP instruction. That is, the bits 8 15 define a displacement that is added to the current value of the program counter to determine the location of the next instruction, which must be within 128 words of the jump instruction. Status Bits Tested by instructionsMnemonic L A EQ C OV OP Jump if CODE JH X X L EQ 1 B JL X X L EQ O A JHE X x L EQ 1 4 JLE X X L EQ 1 2 JGT X A 1 5 JLT X. X 8 A EO O 1 JEQ X EQ 1 3 JNE X EQ O 6 JOC X C 1 8 JNC X C O 7 JNO x OV O 9 JOP X OP 1 C CODE is the CODE field bits 4 7 of the OPCODE to generate the machine coce for the instruction. Application Most algorithms and programs with loop counters require these instructions to decide which sequence of instructions to do next. TABLE BINSTRUCTION OPCODE INSTRUCTION OPCODE SOCB 1111XXXXXXXXXXXX SRA 00001000XXXXXXXXSOC 1110XXXXXXXXXXXX ABS 0000011101XXXXXXMOVB 1101XXXXXXXXXXXX SETO 0000011100XXXXXXMOV 1100XXXXXXXXXXXX SWPB 0000011011XXXXXXAB 101 1XXXXXXXXXXXX BL 0000011 010XXXXXXXA 1010XXXXXXXXXXXX DECT 0000011001XXXXXXCB 1001XXXXXXXXXXXX DEC 0000011000XXXXXXC 1000XXXXXXXXXXXX INCT 0000010111XXXXXXSB 0111XXXXXXXXXXX INC 0000010110XXXXXXS O11OXXXXXXXXXXXX INV 0000010101XXXXXX S ZCB 0101XXXXXXXXXXXX NEG 0000010100XXXXXSZC 0100XXXXXXXXXXXX CLR 0000010011XXXXXXDIV 001111XXXXXXXXXX X 0000010010XXXXXXMPY 001110XXXXXXXXXX B 0000010001XXXXXXXOP 001011XXXXXXXXXX BLWP 0000010000XXXXXXXOR 001010XXXXXXXXXX RTWP 00000011100XXXXXCZC OO1OOOXXXXXXXXXX RSET 00000011011XXXXXCOC 001000XXXXXXXXXX IDLE 00000011010XXXXXJOP 00011100XXXXXXXX LIMI 00000011000XXXXXJH 00011011XXXXXXXX LWPI 0000001011100000JL 00011010XXXXXXXX STST 00000010110XXXXXJNO 00011001XXXXXXXX STWP 00000010101XXXXXJOC 00011000XXXXXXXX CI 00000010100XXXXXJNC 00010111XXXXXXXX ORI 00000010011XXXXXJNE 00010110XXXXXXXX ANDI 00000010010XXXXXJGT 0010101XXXXXXXXX AI 00000010000XXXXXJHE 00010100XXXXXXXX LI 0000000111XXXXXX JEQ 0010011XXXXXXXXX MPYS 00000000111XXXXX JLE 00010010XXXXXXXX DIVS 0000000110XXXXXX JLT 00010001XXXXXXXX JMP 00010000XXXXXXXX SRC 00001011XXXXXXXX SLA 00001010XXXXXXXX TABLE CALU FUNCTIONSEMI68.1 tb CONTROL SEP LINES SEP TO SEP ALU SEP ALU SEP FUNCTION tb SEP ALU SEP 1 SEP ALU SEP 2 SEP ALU SEP 3 SEP ALU SEP 4 SEP H3 SEP Logic SEP SEP 1 SEP H3 SEP Logic SEP tb SEP 0 SEP 0 SEP 0 SEP o SEP 1 SEP 1 tb SEP 0 SEP 0 SEP 0 SEP 1 SEP A SEP SEP B tb SEP 0 SEP 0 SEP 1 SEP 0 SEP A SEP SEP B tb 0 SEP 0 SEP 1 SEP 1 SEP A tb SEP 0 SEP 1 SEP 0 SEP 0 SEP A SEP SEP B tb SEP 0 SEP 1 SEP 0 SEP 1 SEP B tb 0 SEP 1 SEP 1 SEP 0 SEP A SEP SEP SEP B SEP ADD tb SEP 0 SEP 1 SEP 1 SEP 1 SEP A SEP SEP B tb SEP 1 SEP 0 SEP 0 SEP 0 SEP A SEP SEP B tb SEP 1 SEP 0 SEP 0 SEP 1 SEP A SEP SEP SEP B SEP A SEP sub SEP B tb SEP 1 SEP 0 SEP 1 SEP O SEP SEP B tb SEP 1 SEP 0 SEP 1 SEP 1 SEP A SEP SEP SEP B tb SEP 1 SEP 1 SEP 0 SEP 0 SEP A tb 1 SEP 1 SEP 0 SEP 1 SEP A SEP RTI ID 68.5 SEP B tb SEP 1 SEP 1 SEP 1 SEP 0 SEP A SEP SEP B tb SEP 1 SEP 1 SEP 1 SEP 1 SEP 0 SEP tb TABLE D TRUTH TABLE FOR TEST MODE GOOD FAULTED M T 1 CONTROLS DATA MEMORY OUT IN A IN B IN 1 IN 2PATTERN IN 1 IN 2 IN A IN B 1 T M T 1 S commat 1 S commat 0 S commat 1 S commat 0 S commat 1 S commat 0 S commat 1 S commat 0 T 0 0 0 0 1 1 0 0 U 1 0 0 0 1 0 1 V 1 0 1 0 1 1 0 W 1 0 0 0 1 0 0 X 0 1 0 0 1 0 1 Y 0 1 0 1 1 1 0 Z 0 1 0 0 1 0 1 TABLE E PIN DEFINITIONS FOR MESSAGE PROCESSOR CHIPPIN FUNCTIONLAL Address Latch for Local Bus. When LAL goes active high the address appearing on the address data bus is latched. LAL can originate either within the chip 20 or from external to the chip 20. LENw Data Enable for Local Bus. When LEN goes active low, the data is valid on the local address data bus 23.LI D Instruction or Data on Local Bus. When high, LI D indicates that an instruction fetch is in progress. When low, a data fetch is in progress. Can be used to select between ROM 27 and RAM 22.LR W Read or Write for Local Bus. When high, LR W indicates that a read cycle is being implemented. When low, 2 write.cycle is being implemented.LNMI . Non Mascable Interrupt for Local Bus. When this goes active low, the CPU 21 executes a non maskable interrrupt, jumping to a vector address. LIRQ Interrupt Request for Local Bus. Three pins. Contain the incoming interrupt code. to define the interrupt level.LBRDY Local Bus Ready. External devices introduce wait states by holding LBRDY low. The CPU 21 continues wait states until LBRDY goes high.LBRQ1 Local Bus Request 1 and 2. These inputs to chipLBRQ2 20 are driven active low by the protocol handler chip 16 and the system interface chip 30, respectively, to request control of the local bus 23. LBRQ1 has priority over LBRO2 . The local bus arbiter 26 of the chip 20 samples both signals at a given clock phase, and asserts either LBGR1 or LBGR2 on the next phase.LBGR1 Local Bus Grant 1 and 2. These outputs from theLBGR2 chip 20 are driven active low by the local bus arbiter 26 of the chip 20 in response to a bus request LBRQ1 or L3RQ2 , respectively. It indicates that the requesting device 16 or 20 may use the following cycle, if LBRDY is also asserted high . LBSYNC Local Bus Synchronization. Used only for test of chip 20. When active low this pin forces the CPU 21 clock generator into the 4 state.TEST For normal operation, TEST and TEST 0 areTEST 0 held high. For test operations, the input testTEST 1 codes shown in the following list areTEST 2 implemented.TEST TESTO TEST1 TEST2 1 1 X X Normal Operation 1 0 X X RAM 22 disabled on the chip 20. When the chip 20 is local bus master, accesses to address in the range of the RAM 22 will be executed off chip. O 0 0 O Module in place test mode. All output pins of the chip 20 are floated. O 0 0 1 Entry point test mode. When MPRSET goes active then is deactivated, if this code is present an external tester has control of the address input 46 to the control ROM 45 of the local CPU 21. 0 0 1 0 Test mode for general purpose timer 25 in chip 20. A microcode sequence is executed for testing the timer. O 0 1 1 Not specified. O 1 0 X Dump for Control ROM 45. When MPRSET is deasserted, the CPU 21 enters a state that dumps the contents of the control ROM 45, shifting each 130 bit control word out serially on a pin such as L3GR2 pin . The TEST2 pin is toggled to increment the control ROM address register. O 1 1 X Refresh test node for RAM 22. When MPRSET is deasserted, the chip 20 enters a state that permits testing of the internal nodes in the RAM 22 refresh logic. TEST2 provides timing information. TABLE F PIN DEFINITION FOR SYSTEM INTERFACE CHIP PIN FUNCTION SI M System Mode select. Thfs input pin, if held high, at I mode, causes the chip 30 to be compatzble with an 8086 or 8088 microprocessor chip 31. IS held low, at Mode, SI M causes the chip 30 to operate in a format compatable with a 68000 microprocessor chip 31. S6 16 System 8 16 bit bus select. If held low, an interface mode with a 16 bit data bus 34 is selected the 8086 device . If held high, an 8 bit data bus 34 is selected for 8088 device, for example . SRSET System Reset. This input pin places the entire adapter 10 in a known initial state. The chip 30 passes this signal through to the chip 20 via the LRESET pin. SCS System Chip Select. An input pin to chip 30 from the host CPU,31 functioning as chip select to allow the host pr,ocessor. 12 to execute a memory ma pped t O to the chip 30 for read or write. SRSO System Register Select. These three inputs to SRS1 the chip 30 select the word or byte to be SRS2 addressed during a memory mapped I O access from host CPU 31 to the chip 30. SBHE SRNW System Byte High Enable or ReadiNot Write. In the I mode SI M 1 this pin serves as an active low byte high enable signal SBHE . In the M mode SI M 0 , serves as a control signal which is high to indicate a read cycle and low to indicate a write cycle. The chip 30 drives this pin as an output during DMA onto the system bus 34 it is an input during memory mapped I O cycles from host CPU 31 to chip 30. SWR SLDS System Write Strobe or Lower Data Strobe. In I mode, this pin serves as the active low write strobe. In M mode, serves as the active low lower data strobe. An input to chip 30 during memory mapped I O, and an output during DMA. SRD SUDS System Read Strobe or Upper Data Strobe indicator. In the I mode, this pin is an active low strobe indicating that a read cycle is performed on the system bus 34. in M mode, an active low strobe indicating that data is transferred on the most significant byte of the em DUS q e m us j4 . Rn n put to c nip 3u during memory mapped I O, and an output during DMA.SRAS SAS System Register Address Strobe or Memory Address Strobe. In I mode, this pin serves as the system register address strobe, by means of which SCS , SRSO to SRS2, and S3HE are latched. In I mode, the SBHE input is also latched. In a minimum chip system, SRAS is typically tied to the ALE output of the host CPU 31. This latching capability is easily defeated, as is usually desired in expanded 8086 8088 systems supporting non multiplexed address and data busses. The internal latch for these inputs remains transparent as long as SRAS remains high, permitting this pin to be strapped high and the signals at the SCS , SBHE , and SRSO to SRS2 inputs to be applied independent of an ALE strobe from the host CPU 31.In M mode, this pin is an active low address strobe, which is an input during memory mapped I O and an output during DMA.SRDY System Bus Ready or Data Transfer Acknowledge.SDTACK In I mode, this pin serves as an active low bus ready signal. In M mode, this pin serves as the active low dÅata transfer acknowledge signal. The purpose of the SRDYx and SDTACK signals is to indic,ate to the bus master that a data transfer is complete. SRDY SDTACK is internally synchronized to SBCLK it must be asserted before the falling edge of SBCLK in state T2 in order to prevent a wait state. SRDY SDTACK is an output when thesystem.interface chip 30 is selected for memory mapped I O, and, an input otherwise. SALE System Address Latch Enable. At the start of each DMA cycle, this output from chip 30 provides the enable pulse used to externally latch the sixteen LSBs of the address from the multiplexed address data lines.SXAL System Extended Address Latch. This output provides the enable pulse used to latch external to the chips 30 the eight address extension bits of the 24 bit system address during DMA. SXAL is activated prior to the first cycle of each block DMA transfer, and thereafter as necessary whenever an increment of the DAM address counter causes a carry out of the lower 16 bits . SDIR System Data Direction. This output provides to the external data buffers a signal indicating the direction in which the data is moving. During memory mapped I O writes and DMA reads, SDDIR is low input ode during MMIO reads and DMA writes, SDDIR is high output mode , as follows SDDIR DIRECTION MMIO DMA 0 input write read output read . write When the system interface chip 30 is not involved in a memory mapped I O or DMA operation, then SDDIR is high by default.SDBEN System Data Bus enable. This output provides to data buffers in system 12 external to the chip 30, the active low enable signal that causes them to leave the high impedance state and begin transmitting data. This output is activated during both memory mapped I O and DMA.SOWN System Bus Owned. This output goes active low during DMA cycles to indicate to external devices that the chip 30 has control of the system bus. SOWN drives the enable signal of the bus transceivers chips which drive the address and bus control signals.SBCLK. System Bus Clock. This is the external clock signal signÅalwit h which the chip 30 synchronizes its bus timing for both memory mapped IJQ and DMA ,transfers. SHRQ System Hold Request or Bus Request. This output.SBRQ is used to request control of the system bus 34 in. preparation for a DMA transfer. In I mode, it is an active high hold request, as defined in the standard 8086 8088 interface. In M mode, it is an active low bus request, as defined, in the standard 68000 interface. SHLDA System Hold Acknowledge or Bus Grant. In I mode,SBGR this active high pin indicates that the DMA hold request has been acknowledged, in accordance with the standard 8086 8088 interface. In M mode, this pin is an active low bus grant, as defined in the standard 68000 interface. In either mod e, it is internally synchronized, to SBCLLK.SBBSY System Bus Busy. This input signal samples the value of the 68000 style Bus Grant Acknowledge BGACK signal. The chip 30 must sample SBBSYI high before it drives the system bus 34. Its operation is defined for both I mode and M mode.SBRLS System Bus Release. This input is driven active low during DMA to indicate that a higher priority device requires the system bus 34 and the chip 30 to release the bus as soon as possible. When the chip 30 is not performing DMA, this input is ignored. Its operation is defined for both I and M des synchronized to SBCLK.SINTR System Interrupt Request. The chip 30 activates SISQ this output to signal an interrupt request to the host processor 12. In I mode, this pin is active high it is active low in M mode. SlACK System Interrupt Acknowledge. This input is driven active low by the host processor 12 to acknowledge the interrupt request from the chip 30. The chip 30 responds to this signal by gating its interrupt vector onto the system b us 34. System busses not requiring an interrupt cycle may strap SlACK high.SBERR Bus Error. This input is driven active low during a DMA cycle to indicate to the chip 30 that the cycle must be terminated abnormally. It corresponds to the Bus Error signal of the 68000 microprocessor. It is internally synchronized to SBCLK. It is sampled in both I and M modes. SADH , System Addres.s Dat a Bus. high byte . This is theO to 7 most significant byte of the 16 bit address, data bus 34. In I mode, it is attached to the host system address data bus 34 bits 15 8. In M mode, it is attached to the host system address data bus 34 bits 0 7 using 68000 standard bit numbering conventions .SAiL System Address Data Bus low byte . This is the O to 7 least significant byte of the 16 bit address data bus. In I mode, it is attached to the host system address data bits 7 0 using 8086 standard bit numbering conventions. SPH System Parity High. Contains an odd parity bit for each dat.a or addres byte transmitted over SADH O to 7. SPL System Parity Low. Contains an odd parity bit for each data or address byte transmitted over SADL O to 7.LBCLK1 Local Bus Clock 1 and Local Bus Clock 2. TheseLBCLK2 signals are the input clock for all local bus transfers. LBCLK1 follows LACK2 by 90 degrees. LAL Local Address Latch Enable. At the beginning of each local bus cycle, LAL is driven high and then low to strobe the address local bus 23 on and into an external latch. The LAL signal is an output of the chip 30 when the chip 30 controls the local bus 23 and input to the chip 30 otherwise.