# Arithmetic unit in a data processing system with rounding of floating point results.

## Abstract
A data processing system uses improved procedures for handling various arithmetic operations. Thus, in floating point arithmetic mantissa calculations the system uses a novel technique for inserting a round bit ROUND into the appropriate bit bit 23 of the floating point result wherein a look ahead carry bit generator stage 13 is used for such purpose to reduce the overall mantissa calculation time. Further, the system utilizes logic which operates in parallel with the floating point exponent calculation logic for effec tively predicting whether or not an overflow or underflow condition will be present in the final exponent result and for informing the system which such conditions have occurred. Moreover, the system utilizes a simplified technique for computing the extension bits which are required in multiply and divide computations, wherein a programmable array logic unit and a four bit adder unit are combined for such purposes.

## Claims
CLAIMS 1. A data processing system comprising an arithmetic logic unit for performing floating point arithmetic which requires unbiased rounding of the floating point arithmetic result, the said unit being characteristic by means for computing an unrounded floating point result comprising a plurality of bit groups, a first selected number of said bit groups being used to form the rounded floating point result and a second selected number of said bit groups being used to determine the round bit for said rounded result a plurality of look ahead logic means for generating carry bits, for insertion into selected ones of said bit groups of said unrounded floating point result, substantially simultaneously with the computation of said unrounded floating point result and means responsive to said second selected number of bit groups of said unrounded floating point result for determining said round bit a portion of a selected one of said look ahead logic means being responsive to said round bit for inserting said round bit into the least significant bit group of said first selected number of bit groups substantially simultaneously with the insertion of the carry bits into the remaining bit groups of said first selected number thereof to produce said rounded floating point result. 2. A data processing system in accordance with claim 1, characterised in that said round bit determining means includes means responsive to said second selected number of bit groups for producing a decoded bit and enable logic means responsive to said decoded bit for producing said round bit and for supplying said round bit to said portion of said selected one of said look ahead logic means. 3. A data processing system in accordance with claim 1 or 2, characterised in that said unrounded floating point result comprises thirty two bits, designated as bits 31, including twenty four bits, designated as bits 23, used to form said rounded floating point result and eight bits, designated as bits 24 31, used to determine said round bit. 4. A data processing system in accordance with claim 3, characterised in that said unrounded floating point result comprises eight four bit groups, said rounded floating point result having six four bit groups and said round bit determining bits having two four bit groups. 5. A data processing system in accordance with claim 4, characterised in that said carry bits are formed as carry bits CRY4 CRYS, CRY12, CRY16, CRY20, CRY24 and CRY28 for insertion into bits 3, 7, 11, 15, 19, 23 and 27, respectively, of said unrounded floating point result, said round bit being inserted as CRY24 into bit 23 to form said rounded floating point result. 6. A method for performing unbiased rounding of a floating point arithmetic result, characterised by the steps of computing an unrounded floating point result, a first portion of which is used to form a rounded floating point result and a second portion of which is used to determine a round bit for use in said rounded floating point result determining said round bit from said second portion of said unrounded floating point result and inserting said round bit directly as a carry bit at the least significant bit of said first portion of said unrounded floating point result substantially simultaneously with the computation of said unrounded floating point result to produce a rounded floating point result. 7. A method in accordance with claim 6, further characterised by computing a plurality of carry bits substantially simultaneously with the computation of said unrounded floating point result for insertion at selected bits thereof, the insertion of said round bit being performed substantially simultaneously with the insertion of said plurality of carry bit at the selected bits of said first portion of said unrounded floating point result. 8. A method in accordance with claim 6 or 7, characterised in that the said unrounded floating point result has thirty two bits, designated as bits 31, said first portion thereof having twenty four bits, designated as bits 23, and said second portion thereof having eight bits, designated as 24 31, said round bit being inserted at bit 23 of said first portion to form said rounded floating pointed result. 9. A data processing system comprising arithmetic computation means which includes means operating on a pair of exponent operands for providing an arithmetic exponent result which may be subject to the occurrence of overflow or underflow conditions, one of said operands having a value which is capable of lying in a middle range in which case no overflow or underflow condition exists, in upper or lower ranges in which cases an overflow or underflow condition exists, or in cross over ranges in which cases the existence of an overflow or an underflow condition depends on the value of the other of said exponent operands, characterised in that the arithmetic computation means comprises means operable in parallel with the computation of the final arithmetic exponent result for detecting in which of said ranges the first exponent value lies. 10. A data processing system in accordance with claim 9, characterised in that said detecting means includes means responsive to one of said operands to produce a pair of first exponent indicator bits means responsive to second selected bits of said one operand to produce a third exponent indicator bit and further means responsive to first selected bits of said one operand and to selected bits of the other of said operands to produce a second exponent indicator bit and means responsive to the status of said first exponent indicator bits, to the status of said second exponent indicator bit, to the status of said third exponent indicator bit, and to the status of a selected bit of said other operand for producing a first indication when an overflow condition exists and a second indication when an underflow condition exists in said final arithmetic exponent result. 11. A data processing system in accordance with claim 10, characterised in that said further means is an adder logic means. 12. A data processing system in accordance with claim 11, characterised in that said exponent operands each comprise eight bits and said means for providing said arithmetic exponent result includes two four bit slice logic means and said adder logic means is a four bit adder. 13. A data processing system in accordance with claim 9 further characterised by means operable in parallel with the computation of the final arithmetic exponent result for producing for said system a signal indicating whether or not an overflow or an underflow condition exists. 14. A data processing system in accordance with claim 13, characterised in that said indicating signal producing means includes means responsive to first selected bits of said one operand and to selected bits of the other of said operands to produce a first exponent indicator bit means responsive to said second selected bits of said one operand to produce a second exponent indicator bit and means responsive to the status of a pair of selected bits of said one operand, to the status of said first exponent indicator bit, to the status of said second exponent indicator bit, and to the status of a selected bit of the other of said operands for producing said indicating signal. 15. A data processing system in accordance with any of claims 9 to 14, characterised in that said final arithmetic exponent result may lie in a range of values from 128 to 129, an overflow condition existing if said result lies within a range from 64 to 126 for addition, subtraction and multiply operations and within a range from 64 to 128 for a divide operation and an underflow condition existing if said result lies within a range from 64 to 127 for addition, subtraction or divide operations and within a range from 64 to 129 for a multiply operation. 16. A data processing system having an arithmetic unit for performing multiplication or division operations requiring a plurality of computation cycles, each of which cycles requires the result thereof to be extended by a selected number of bits, characterised in that said arithmetic unit comprises programmable array logic means responsive to selected bits identifying selected characteristics of the computation being performed for providing operand extension bits and further logic means responsive to said operand extension bits for providing said selected number of extension bits for extending the computation result during the current computation cycle. 17. A data processing system having an arithmetic unit for performing multiplication operations requiring a plurality of computation cycles, each of which cycles requires a sign or a zero extension of the partial product operand and the multiplicand operand, characterised in that said arithmetic unit comprises programmable array logic means responsive to two selected bits each representing the most significant bit of each operand, to a selected bit identifying whether the current cycle is to be a sign extended or a zero extended operation, to a selected bit identifying whether the current multiply cycle is the first multiply cycle or other than the first multiply cycle, to a selected bit identifying whether the current cycle requires an addition or a subtraction operation, and to a selected pair of bits identifying the form of said multiplicand operand during said current cycle, said logic means providing a plurality of extension bits and further logic means responsive to said extension bits for providing a plurality of extension bits for extending the partial product result during the current multiply cycle. 18. A data processing system in accordance with claim 17, wherein said further logic ineans produces a pair of extension bits. 19. A data processing system in accordance with claim 17 or 18, characterised in that said multiply operation utilizes 32 bit operands for producing a partial product result during each multiply cycle, said further logic means producing two extension bits to provide a 34 bit result. 20. A data processing system in accordance with claim 19, characterised in that said multiplicand can be in the following forms pal, the multiplicand, or twice the multiplicand. 21. A data processing system in accordance with claim 17 or 18, characterised in that said multiply operation utilizes 64 bit operands for producing a partial product result during each multiply cycle, said further logic means producing two extension bits to provide a 66 bit result. 22. A data processing system having an arithmetic unit for performing divide operations requiring a plurality of computation cycles, each of which cycles requires an extension of the dividend operand, characterised in that said arithmetic unit comprises programmable array logic responsive in a current divide computation cycle to a first selected bit of the result of the previous divide computation cycle and to a second selected bit identifying whether an add or subtract operation is required for the current divide cycle for producing a plurality of extension bits and further logic means responsive to said extension bits for providing a quotient bit during the current divide cycle. 23. A data processing system in accordance with claim 22, characterised in that said divide operation utilizes 32 bit operands for producing said quotient bit during each divide cycle. 24. A data processing system in accordance with claim 23, characterised in that said first selected bit is the most signigicant bit of the result of the previous divide cycle. 25. A data processing system in accordance with claim 22, characterised in that said divide operation utilizes 64 bit operands for producing said quotient bit during each divide cycle.

## Description
ARITHMETIC UNIT IN DATA PROCESSING SYSTEM This invention relates generally to data processing systems which utilize fixed and floating point arithmetic units and, more particularly, to improved techniques for rounding floating point calculations, for handling overflow and underflow conditions therein, and for providing arithmetic words extension logic for use in performing multiplication and division operations. The representation of numbers in data processing systems, particularly non integer numbers, requires the introduction of a radix point into the notation. For example, data processing systems may employ fixed point notation wherein the radix point is placed immediately to the right of the least significant bit or placed immediately to the right of the sign bit before the first information bit. A further option is often referred to as floating point notation in which the numbers are represented by a sign, an exponent, and a mantissa. Such technique is described in many texts, one example being Computer Architecture , Caxton C Foster,Van Nostrand Reinhold Co, New York 1976, pages 16 et seq. Calculations upon the mantissa may be performed by operating on groups of bits i.e. bit slices of the mantissa words involved, the computation for each bit slice producing a carry bit to be added to the adjacent bit slice until the calculation is completed for the entire word. For example, overall mantissa words having 32 bits may use eight 4 bit slice logic units in such calculations. If each bit slice is permitted to produce its carry bit only after the operation for such bit slice has occurred and the carry bit is then added to the next bit slice, the overall calculation time is considerably longer than desired. In order to reduce the overall calculation time, techniques for effectively computing the carry bits ahead of time, i.e. so called look ahead carry bit techniques have been devised wherein the various carry bits are computed in parallel and simultaneously with the bit slice computation operations. Such techniques have been used for many years and are well known to those in the art. After the overall computation has been completed, a round bit is then computer and added to the last bit slice as discussed below, the round bit being determined by a plurality of bits, often referred to as guard bits, which form a particular coded word which must be suitably decoded to produce the round bit.The round bit is usually calculated following the overall computation and then added to the least significant bit of the unrounded floating point result at the appropriate carry bit location, an operation which can be thought of as an effective multiplexing operation, i.e. the round bit being inserted during the rounding cycle instead of the associated carry bit. For example, when using 32 bit words, the unrounded floating point result comprises 32 bits and is then rounded to a final result having 24 bits. In such case, the unbiased rounding algorithm uses the eight bits of least significance to determine how to round the final 24 bit result. However, the insertion of the round bit to the completed floating point computation result by effective multiplexing techniques adds additional time to all of the calculations required for the mantissa clauclations.It is desirable to devise techniques to save this time. Further, in calculating the exponent portion of a floating point result, if the calculation does not produce a value which falls within a particular exponent value range i.e. a value having a particular number of bits , an overflow or an underflow condition occurs. If either such condition occurs, the system must provide an indication thereof so that appropriate sub routines for handling such conditions can be invoked and the status of the floating point condition must be appropriately communicated to the overall system. In order to save time in the overall operation it is desirable to accelerate the detection and communication of exponent overflow and underflow conditions. Further, in a multiply or divide operation, conventional algorithms which are used for such operations require that certain operands be extended, i.e. that additional bits be added to the operand words. For example, in a particular multiply algorithm such operands must be extended by two bits, while in a particular divide algorithm such operands must be extended by one bit.Extension techniques which require the use of extra bit slice logic units add to the hardware complexity of the arithmetic units or floating point units. It is desirable to devise less cumbersome extension techniques for such purpose to avoid such hardware complexity. In order to achieve rounding of mantissa computations, a novel modification to the conventional look ahead carry technique is utilized in accordance with the invention, wherein a portion of an existing look ahead stage i.e. that stage normally used to generate the carry bit which is to be added to the least significant bit slice of the unrounded floating point result is used for the round bit calculation, the round bit then being added as the carry bit in the least significant bit of the unrounded floating point result in parallel with all the other carry bits calculated by the remaining parallel look ahead stages. Further, in order to provide relatively fast detection of overflow and underflow conditions during exponent calculations, rather than making a complete addition of the exponent value and then detecting the overflow and underflow conditions thereafter, the system in accordance with the invention utilizes overflow underflow logic which operates in parallel with the final exponent computation and in effect predicts whether or not an overflow or an underflow condition will exist in the final exponent calculation.In a preferred embodiment such logic uses an extra adder stage, together with associated logic to produce a signal which provides an indication to the system that an overflow or underflow condition exists. Further, the invention makes use of simplified arithmetic unit extension logic, using less complex programmable array logic and addition stages to provide a simpler technique for operand extensions during multiply and divide operations. The invention will be described in more detail, by way of example, with reference to the accompanying drawings, in which Fig 1 shows a block diagram of an arithmetic unit for performing arithmetic calculations Figs 2 to 2D show specific 4 bit microprocessor slice logic units used in mantissa calculations Fig 3 shows specific look ahead logic units for computing the carry bits for mantissa calculations Fig 4 shows specific logic units for use in computing the round bit for mantissa calculations in accordance with the invention Fig 5 shows specific 4 bit microprocessor slice logic units used in exponent calculations Fig 6 shows a chart useful in explaining the overflow underflow operation in accordance with the invention Fig 7 shows logic units used to detect overflow underflow conditions and to provide an indication thereof to the data processor system and Fig 8 shows logic units used to provide extension bits for use in multiply or divide operations in accordance with the invention. The invention disclosed herein can be best described in the context of a particular data processing system, such as that disclosed in EP 0 039 227. A broad block diagram of the arithmetic logic unit ALU used therein is shown in Fig 154 of the application which is reproduced herein in Fig 1. Specific logic diagrams required to understand the invention described herein are shown here inFigs 2 5 and Figs 7 and 8. In such system, as is conventional for 32 bit mantissa calculations, the computation is made in four bit slices as shown by the 3 bit microprocessor slice logic units lOAlOH. Two 4 bit values are operated on, and a 1 bit carry value is added to the result of this operation to produce the 4 bit output DS outputs . Thus the slice units produce an unrounded floating point result formed as the following 4 bit slices shown below EMI4.1 UNWOUNDED FLOATING POINT RESULT GUARD BITS As can be seen in the above diagram, in the 32 bit calculated word the 24 bits forming the six more significant 4 bit slices bit 23 produce the unrounded floating point result, while the eight bits forming the two less significant 4 bit groups bits 24 31 represent the bits which are used to determine the round bit, referred to as the guard bits.In each instance, each of the 4 bit slices effectiVely produces a carry CRY bit which is supplied to the next adjacent 4 bit slice, e.g. bit slice 3 is effectively supplied with the carry bit CRY4 frow the 4 bit slice 4 7, the latter slice is supplied with CRY8 from 4 bit slice 8 11, and so on. The CRY 31 bit is supplied from microcode, while the CRYÇ bit is the carry bit for the final overall floating point result.In order to save time in the computation the carry bits are actually generated in parallel with the 4 bit computations in each of the 4 bit microprocessor slice logic units, the parallel carry bit calculations being performed in the look ahead carry generator units llA, llB and 11C as shown in Fig 3. Thus, during such arithmetic operation cycle, the overall computation, is performed substantially simultaneously to form the unrounded 32 bit result. In conventional floating point computation techniques the round bit is then added during the next cycle the round cycle of the floating point computation, after the arithmetic operation has been completed, by appropriately decoding the guard bits to generate the round bit and then adding the round bit to bit 23 effectively as CRY24 bit , which latter process can be achieved by using effective multiplexing techniques, for example. A certian amount of time is required for performing the multiplexing operation, and such time increases the overall data processing time for all operations. It is desirable to avoid such added processing time by reducing the time needed to generate and insert the round bit, as described below, in accordance with the invention. The logic circuitry of the invention utilizes an additional section of look ahead generator stage 11A and associated circuitry 12, 13 and 14 for generating the round bit and for adding the round bit as an effective CRY24 bit in parallel with the generation and insertion of the other carry bits. Thus, the guard bits D24 31 are supplied to appropriate gating logic 13, shown in Fig 4 to produce the RNDB bit. Such bit is then utilized in the round enable logic 12 and 14, shown in Fig 4 which produce the ROUND bit, the latter being supplied to the CRY24 look ahead generator llA, and thence, to the specific 4 bit slice unit lOC which produces the least significant four bits bits 20 23 of the 24 bit floating point result as the final step in the arithmetic operation.Thus, the rounding of the floating point result is accomplished without adding a time inveral required for the effective multiplexing of the round bit into CRY24 as required when using conventional techniques. The techniques used in accordance with the invention for detecting overflow and underflow conditions during computation of the exponent value in a floating point operation is specifically described, for convenience, with reference to the generation of a 7 bit exponent. The generation of a computed exponent value involves the addition of a first exponent value AEXP representing an exponent value stored in a particular register and a second exponent value DEXP , representing an exponent value which is obtained, for example, from an external source. The AEXP and DEXP values are each defined by seven bits and their addition yields the desired exponent result BEXP , which can be stored in another specified register.The above operation can be represented in accordance with the following relation AEXP DEXP 4 BEXP If the original exponents are each represented by 7 bit values and the arithmetic operation is performed as shown above, the useful result should also be expressed by 7 bits. If such result is expressed by more than 7 bits an overflow or underflow condition exists. More particularly, 7 bit exponents, during overflow or underflow, will never yield values that require more than eight bits.Such characteristics can be understood with the help of Fig 6 wherein a 7 bit exponent defines 128 values within a range from 64 to 63, while an 8 bit exponent defines 256 values within a range from 128 to 127. Values from 64 to 127 and values from 65 to 128 are defined as representing an overflow or underflow condition these decimal values are obtained by interpreting the 8 bit exponents as two s complement notation binary numbers . Fig 6 also depicts overflow underflow conditions for addition, subtraction, multiplication and division operations.Thus, an addition or subtraction overflow occurs within a range from 64 to 126 while an addition or subtraction underflow occurs in a range from 64 to 127. A multiply overflow occurs in a range from 64 to 126 while a multiply underflow condition occurs in a range from 64 to 129. A division overflow occurs within a range from 64 to 128, while a division underflow occurs within a range from 64 to 127. Two special conditions should be pointed out. In the multiply underflow range a special condition occurs wherein 129 is represented as 127 and in the divide overflow range a special condition occurs wherein 128 is represented as 128. The exponent calculation is performed in two 4 bit slices as shown in Fig 5 by 4 bit microprocessor slice logic units 20A and 20B. AEXP is addressed from the A register ARECÇA 3A while the externally sourced exponent DEXP is supplied as bits DX XD7. During this calculation bits EXP 7 hold the AEXP value. BEXP is then calculated and supplied to the register addressed by the B register BREG A 3A . The system must then provide an indication of an overflow or an underflow condition, i.e. when the result falls outside the 7 bit range, and provide a suitable signal which will enable an appropriate sub routine for handling the particular identified overflow or underflow condition. Because of the particular conventional algorithm used, during the last cycle of the exponent calculationDEXP is limited to the value which lies within the range from 8 to 7. Thus, the value ranges of interest in the register AEXP addressed by AREG are shown in Fig 6. They include a middle range from 56 to 55 in which it is clear there will be no overflow or underflow error condition i.e. even where DEXP is at its 8 or 7 limits, the final result would not lie in an overflow or underflow range , an upper range from 72 to It127 and a lower range from 73 to 128. In the latter ranges it is clear that no matter what DEXP value during the last cycle, the final result would clearly be in an overflow or an underflow range. In the two crossover ranges 56 to 71 and 57 to 72 the overflow or underflow conditions must be determined, depending on the value of the DEXP within its limits during the last cycle of the exponent calculation. An NEXP1 bit is obtained by adding selected EXP1 and EXP5 7 of the AEXP with bits XD1 and XD5 7 of the DEXP, as shown by 4 bit adder unit 21 of Fig 7. An ERR CASE signal is dervied from AEXP bits EXP 7 via programmable array logic unit 22 in Fig 7. The overflow underflow status of the exponent calculation is defined by the NSI and NS2 bits from programmable array logic PAL 23 in Fig 7. In an overflow condition, programmable array logic 23 asserts an NS1 signal while in an underflow condition an NS2 bit is asserted. Bits SEXP and SEXP1 are derived from AEXP bits EXP 7 and signal FLAG 5 indicating multiply or divide, in PAL 24. This logic is provided to detect generally in which range the final floating point exponent result resides and, more particularyy, provides a capability of determining where within the cross over regions the final result lies so as to determine whether an overflow or underflow condition exists within such latter regions. In order to do so, examination of the selected AEXP bits and the selected DEXP bits is made in accordance with the following chart, an explanation of which can be understood in connection withFig 6, by the above described logic. Note that signals SEXP and SEXP1 in all cases, except for the special case described in the chart and below, are equal to EXP and EXP1, respectively.OVERFLOW NS1 IF ERR CASE SEXP ,1 IS TRUE NEXP1 XD1 EMI8.1 1 DON T CARE IF ERR CASE SEXP ,1 IS FALSE UNDERFLOW NS2 IF ERR CASE SEXP ,l IS TRUE NEXP1 XD1 EMI8.2 1 DON T CARE 1 IF ERR CASE SEXP L,l ,1 IS FALSE SPECIAL CASE SPC CASE IS TRUE when MULTIPLY UNDERFLOW EXP 127 real value is 129 ,FLAG 5 is true DIVISION OVERFLOW EXP 128 real value is 128,FLAG 5 is false IF SPC CASE IS TRUE SEXP ,1 IF SPC CASE IS FALSE SEXY0,1 EMI9.1 VALUES ARE INVERTEDVALUES REMAIN THE SAMEThe cases set forth in the above chart depcit the situations in which an overflow or an underflow condition exists in the final computed exponent result. The values of the condition indicator bits SEXY0,1, NEXPLI XD1 and ERR CASE are utilized during the last computation cycle in effect to predict the presence or absence or overflow or underflow condition in the final exponent resultBEXP. In order to access the desired sub routine for handling overflow or underflow conditions, a signal for indicating that one of such conditions has occurred is provided to the system as theSET FLT ERR signal from PROM unit 25 see Fig 7 . The latter signal is determined by the states of the first two AEXP indicator bits directly accessible as EXPÇ and EXP1 from 4 bit slice logic unit 20A , by the NEXP1 indicator bit determined by selected EXP 1, 5, 6 and 7 and XD 1, 5, 6 and 7 bits as discussed above , by theERR CASE indicator bit, and by indicator bit XD1, the second most significant bit of the DEXP, as shown in Fig 7. The status of such bits in determining the overflow and underflow conditions is defined in the chart set forth above.In effect SET FLT ERR is true when either NS1 or NS2 is true . While the add ADD or subtract SUB overflow and underflow conditions are relatively straightforward, as shown inFig 6, special cases exist for a multiply MULTI calculation wherein an underflow condition exists over a range from 64 to 129 and for a divide DIV calculation wherein an overflow condition exists over a range from 65 to 128. The special cases are as follows in multiply at 129, which is represented as 127, and in divide at 128, which is represented as 128. Such special cases are determined by programmable array logic 24 in Fig 7, wherein theAEXP bits EXP 7 are examined as well as the signal FLAG 5 which is set true during multiply and false during divide by microcode.If a special case condition 127 for a MULT and 128 for a DIV exists, a SPCCASE signal is generated SPCCASE is true . In such conditions the values of SEXPX and SEXP1 must be inverted. That is, when SPCCASE is true SEXP EXPÇ and SEXPl ExPl. So long asSPCCASE is false no change is made in the values of SEPQI and SEXY1 That is, SEXPX EXPX and SEXP1 EXP1 Accordingly, the above discussed logic not only computes the status of the floating point result but also simultaneously computes a SET FLT ERR signal which is supplied to the system in this case the address translation unit ATU of the system shown in the aforementioned Rasala et al application for accessing the desired sub routine for handling the overflow or underflow conditions, such operations occurring substantially at the same time that the overall exponent addition operation occurs in the computation of the floating point result in the computation of the BEXP value . In order to achieve full precision in the results obtained for multiplication and division operations of an arithmetic logic unit or a floating point computation unit, the use of a conventional multiplication algorithm known as a two bit Booth s algorithm requires that the multiplicand and partial product operands be extended by two additional bits e.g., when using 32 bit or 64 bit words such operands must be extended to 34 bits and 66 bits, respectively and the use of a conventional division algorithm known as a non restoring divide algorithm requires extension of the divident and divisor operands by one additional bit e.g. when using 32 bit or 64 bit words such operands must be extended to 33 bits or 65 bits, respectively . It is desirable to provide a technique for extending the words involved which does not require adding an extra 4 bit microprocessor slice logic unit. A technique for providing the desired arithmetic extensions is shown in Fig 8 which depcits a programmable array logic unit 26 and a simple 4 bit adder unit 27. The following analyses assist in explaining the operation of units 26 and 27 for a multiply or division operation. In the system design described herein, the multiply operation provides a result by adding a value A to the product of two valuesB and C, i.e. the multiply result is A BXC . A multiply operation may be signed or unsigned. In accordance with the conventional multiply algorithm, a signed multiply operation requires both a first operand the partial product and a second operand either a the multiplicand, or twice the multiplicand to be sign extended.An unsigned multiply operation requires the first operand to be sign extended except in the first multiplication cycle and requires the second operand to be zero extended. The chart set forth below depicts the two extended bits for both the first and second operands for the various multiply operations.SIGNED MULTIPLY OPERAND ADD SUBTRACT 1st Do Do Do Do 2nd 1 1 1st Do Do Do Do 2nd QB QB QB QB MULTIPLICAND B B 1st Do Do Do Do 2nd QB QB QB QB 2X MULTIPLICAND B B UNSIGNED MULTIPLY OPERAND ADD SUBTRACT 1st Do Do Do Do 2nd 1 1 1st Do Do Do Do 2nd ç 1 1 MULTIPLICAND 1st Do Do Do Do 2nd 0 QB 1 QB 2X MULTIPLICAND B In the above chart Do represents the most significant bit of the first operand and Q represents the most significant bit of the second operand. In the special case of an unsigned multiply during the first multiply cycle when the partial product is the value A the first operand partial product is zero extended as follows UNSIGNED MULTIPLY DURING FIRST CYCLE EMI12.1 tb OPERAND SEP ADD SEP SUBTRACT tb SEP 1st. tb SEP 2nd SEP 40 SEP ç SEP 1 SEP 1 SEP tb SEP 15t SEP QI. tb SEP 2nd SEP X SEP 0 SEP 1 SEP 1 SEP SEP MULTIPLICAND tb SEP Ist SEP QI SEP QI tb SEP 2nd SEP SEP QB SEP 1 SEP Q SEP SEP 2X SEP MULTIPLICAND tb SEP B SEP tb The signal DX contains the value of Do and QBit contains the value of QB in the above chart. The programmable array logic 26 handles the generation of the above values for the first and second operands as shown in Fig 8. IRAQI and IRI1 bits identify the cases set forth below, the IR04 signifies an add or subtract operation during the multiply, the UNSIGN bit signifies a signed or an unsigned multiply operation and the MACC EN bit signifies operation either in the first multiply cycle or in a cycle other than the first multiply cycle, as set forth below. The signal NPY is true during multiply cycles.EMI12.2 tb SEP BITS SEP SIGNIFY tb SEP IRIl SEP IRIÇ tb SEP b SEP tQI tb SEP 1 SEP SEP iMULTIPLICAND tb SEP 1 SEP 2 SEP X2xMULTIPLI SEP CAND tb SEP 1 SEP 1 SEP 4 SEP REDUNDANT tb SEP I 4 tb SEP ADD tb SEP 1 SEP SUBTRACT tb SEP UNSIGN tb SEP SIGNED tb SEP 1 SEP UNSIGNED tb SEP MACC SEP EN tb SEP FIRST SEP MULTIPLY SEP CYCLE tb SEP 1 SEP NOT SEP FIRST SEP MULTIPLY SEP CYCLE tb where SEP in SEP each SEP case SEP 521 SEP Low SEP and SEP 1 SEP High. tb Bits IRI1, IRI , IR P4 are generated in accordance with the particular multiply algorithm which is used, utilizing known logic techniques, and bits MPY, UNSIGN and MACC EN are obtained rom microcode control, in accordance with well known techniques. Thus, input bits to programmable array logic 26 as specified above provide the two operand extension bits at the A inputs first operand and the B inputs second operand of adder unit 27. The resulting addition produces the extension bits DSTX and DSTY for the next partial product as shown in Fig 8. The required CRY bit is also input to adder unit 27 as mentioned above. In the PAL unit 26 the LDQB, TCRYÇ and QBIN are used for purposes other than in the multiply or divide operations and need not be discussed further. With reference to division operations, in accordance with the aforementioned conventional divide algorithms, the first operand is the dividend and the second operand is the divisor. In an unsigned divide operation, during each divide cycle the first operand is always extended by the most significant bit of the result from the last divide cycle identified as the LINK bit, as shown in Fig 8 while the second operand is always zero extended, as follows UNSIGNED DIVISION ADD SUBTRACT 1st OPERAND LINK LINK 2nd OPERAND 1 The CRYY bit signifies whether an add or subtract is required, as follows TCRYY SIGNIFIES ADD 1 SUBTRACT The carry bit CRYY from adder unit 27 resulting from the above additions of the LINK bit and the bit is the quotient bit and such bit is registered for the next divide cycle, the registered value being designed the TCRYY bit. The PAL unit 27 and adder 27, thus, determine the carry bit required for the divide operation from the extended bits of the dividend first operand and the divisor second operand . The signal DIVD is true during divide cycles as set by microcode. Accordingly, the use of PAL unit 27 and adder unit 27 provides for the extension requirements in both a multiply and a divide operation without requiring the use of an additional 4 bit microprocessor slice logic unit of the type depicted for the 32 bits shown in Figs 2 or for 8 bits shown in Fig 5.