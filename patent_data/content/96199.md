# Method and apparatus for logging journal data in a computing apparatus.

## Abstract
Operation of a computing system including a data base and a log of changes to the data base is enhanced by enabling online access to log records stored both in direct access storage devices and archive log storage devices. Responsive to a request from a user of a log facility to store a log record, a sequential relative byte address is assigned to the log record and returned to the user, and the log record is stored in a main storage log buffer. The log buffer contents are periodically written to one of at least two data sets on direct access storage devices, and these data sets are offloaded selectively from the direct access storage device to an archive log device while writes of log buffer contents to the data set being offloaded are inhibited. An index of the log records is maintained in a boot strap data set, and includes the range of relative byte addresses of log records stored in each direct access storage device and archive device. Responsive to a request from a user of the log facility for a log record having a given relative byte address, the re quested log record is obtained from the most accessible storage location referenced by the index.

## Claims
CLAIMS 1. A method for operating a computing apparatus to enhance the operation of the computing apparatus during recovery from failure, the apparatus including buffer means, storage device means including direct access storage device means and archival storage device means, and program execution means, the method executed under control of said program execution means including the steps of writing log records to said storage device means, said log records including records of changes to a data base and of changes to the state of a system including said computing apparatus, the improved method characterized by the steps of assigning to each log record a relative byte address within a continuous address space storing said log record in said buffer means writing the contents of said buffer means to an active data set on said direct access storage device means offloading said active data set to an archive data set on said archival storage device means maintaining an index of the relative byte addresses of log records in each active and archive data set and responsive to a request specifying the relative byte address of a desired log record, obtaining said desired log record from the first of said buffer means, said direct access storage device means, or said archival storage device means in which it currently resides. 2. The method of claim 1 further characterized by the step of writing the contents of said buffer means to an active data set selectively upon the filling of said buffer means with log records or upon expiration of a predetermined time since the last writing of said buffer means to an active data set. 3. The method of claim 1 further characterized by the step of offloading an active data set to an archive data set upon the filling of an active data set. 4. The method of claim 1 further characterized by maintaining a plurality of copies of said log records in different active and archive data sets. 5. The method of claim 1 wherein said obtaining step is further characterized by the steps of searching said buffer means for the desired log record and if not found searching said index to identify an active data set containing said desired log record and, if found, loading the desired log record into a read buffer in main storage from the active data set otherwise, searching said index to identify an archival data set containing said desired log record and, if found, loading the desired log record into said read buffer from the archival data set. 6. The method of claim 1 further comprising the step of writing a log record as a spanned record into a plurality of active log data sets. 7. A computing apparatus including program execution means, buffer means, storage device means including direct access storage device means and archival storage device means, said program execution means being operable to control the writing of log records to said buffer means and thence to said storage device means, and a program executable by said program execution means which assigns to each log record a unique relative byte address within a continuous address space, the continuous address space including each of said buffer means, direct access storage device means, and archival storage device means. 8. The computing apparatus of claim 7 in which the program causes said program execution means to periodically write the contents of said buffer means an active log data set on said direct access storage device means, to periodically offload said active log data set to an archival data set on said archival storage device means, and responsive to a request specifying the relative byte address of a desired log record obtains said desired log record from the first of said buffer means, direct access storage device means, or archival storage device means in which said desired log record is located.

## Description
METHOD AND APPARATUS FOR LOGGING JOURNAL DATA IN A COMPUTING APPARATUS BACKGROUND OF THE INVENTION Field of the Invention This invention relates to a new system configuration and method for operating a computing apparatus. More specifically, it relates to the buffering of a journal of the creation, deletion and modification of recoverable objects including messages, data base records or tuples, and persistent systems states. Description of the Prior Art In the operation of computing systems, it is the practice to provide a data base management system which operates under the operating system to manage the creation, deletion, and modification of records stored in a data base. Such data base management systems, especially those which process multiple, concurrent transactions, require a means for maintaining the integrity of the data base in spite of the possibility of 1 failure of the media upon which the data base is recorded, 2 failure of the computing system upon which the data base management system is operating, or 3 failure of one or more of the transactions to successfully complete its processing.These failures may be the result of complete loss of power to the computing systems s main storage which, because it requires power to maintain the information contained therein is volatile, and such a power loss will result in loss of knowledge by the system as to its own state and the state of the processes under its control, as well as loss of information with respect to changes being made to the data base. This problem is commonly solved by use of a recovery log. Before data is modified, the before and after image of modified data or states is recorded in a non volatile log media. This technique is referred to as log write ahead . This is sometimes achieved by waiting until other activity fills log buffers which results in the write operation occurring, or by forcing a partially filled buffer to be written to non volatile storage. In the event of a transaction failure, if the data or state has been written to the data base, the log is used to backout the modifications. In the event of a media failure, the log, in conjunction with the most recent image copy of the data, is used to forward recover the data to its last point of consistency. In our IBM Information Management System IMS VS Version 1, three different logs are used. These are the system log, the dynamic log, and the restart dataset. The IMS VS system log is recorded on tape. It is used for data base media recovery and offline backout.This log can also be used to restart IMS VS. The dynamic log is recorded on direct access storage device s DASD . It contains the data base change information needed to backout the currently executing transactions.The restart dataset is also recorded on DASD. It contains system status information needed to restartIMS VS. The restart dataset and dynamic log are used to perform a fast restart after most IMS VS failures. In the IMS VS Version 1 logging approach, read access to the system log is used by off line utilities for data base recreate and repair operations, but is not available to the online system for online recovery operations. For this reason, information needed for online recovery operations is replicated. An example of this is the dynamic backout data. It exists in both the system log and the dynamic log. Further, in some system failure cases, it is not possible to reinstitute dual logging online or to restart the system without first terminating the system log from the dump data set. There is, therefore, a need to improve system performance and throughput during online and off line recovery operations required by a data base system by providing a single set of log accessing protocols having access to both the DASD and tape logs. The invention provides a method for operating a computing apparatus, and a computing apparatus, as specified in the appended claims.BRIEF DESCRIPTION OF THE DRAWINGS Figure 1 is a diagrammatic illustration of the logging apparatus of the invention, illustrating a continuous log stored in main storage output buffers, direct access storage devices, and archieval storage devices. Figure 2 is a diagrammatic illustration of the index structure for the log apparatus of Figure 1, andFigure 3 illustrates the content of an index record. Figure 4 is a diagrammatic illustration of the log control structure, illustrating the relationship between log manager tasks in responding to an external request for service. Figure 5 is a diagrammatic illustration of the control structure implemented for processing a write to the log. Figure 6 is a diagrammatic illustration of the control structure implemented for processing a read from the log. Figure 7 is a flow chart illustrating the log read procedure. Figure 8 is a diagrammatic illustration of log records within VSAM control intervals, showing an example of a spanned record. Figure 9 is a diagrammatic illustration of a log record header.DESCRIPTION OF THE PREFERRED EMBODIMENT Reference is made to our suropean application number for Method andApparatus for Logging Journal Data Using a Log WriteAhead Data Set by Gawlick et al, Applicants referenceSA9 82 004 US 390485 filed 21 June 1982 . In Figure 1 of the copending Gawlick et al application there is illustrated a system environment requiring the logging of data base and other changes to a log including main storage buffers, direct access storage devices DASD , and archival storage devices such as tapes . The apparatus and method of the present application operates within the same environment, excluding therefrom the specific implementation of the write ahead data set WADS , which is not the subject of this application. The computing apparatus of the invention may be a general purpose computer, or central electronic complex, such as an IBM System 360 orSystem 370, described in U.S. Patent 3,400,371 by G. M.Amdahl, et al, and in IBM System 370 Principles of operation, IBM Publication GA22 7000 6. Referring now to the figures, Figure 1 illustrates the continuous log 20 of the present invention, distributed across archive log data sets 22, 24, 26, active log data sets 30, 32, 34, and in log output buffers 40. Archive log data sets may be implemented in data sets on DASD or tape or mass storage system MSS devices. Active log data sets may be implemented in VSAM data sets on DASD devices. Data stored in archival and active data sets are non volatile. Other log data is stored in volatile, main storage buffers 40. As is illustrated in Figure 1, log data sets 51 53 are stored in archive devices 22, 24, 26, respectively, and log data sets 53 55 are stored in active log devices 30, 32, 34, respectively. At any given instant, a log data set, such as 53, may reside both in active and archive devices, output buffers 40 may include log records from a data set, such as 55, which has been written in whole or in part out to an active log device 34, and also log records 56 which have not yet been written to an active log device. Figure 1 also illustrates the extent of relative byte addresses RBA , extending from the beginning of time the oldest log RBA to the most recent log RBA. In operation, a data base system uses log 20 to record changes to data base records for use in maintaining integrity of the data base. Such integrity is maintained by 1 backing out removing changes made to a data base by processes that abnormally terminate, and 2 recreating data bases that are lost due to hardware recording media failures, such as DASD head crashes. The data base system also periodically writes its internal operating status to log 20 for use in restarting the data base system after either normal or abnormal termination. In building log 20, log records are first placed in log output buffers 40, and periodically written out toDASD 30, 32, 34 from buffers 40. Log records in active log data sets 30 34 are available for fast access during online backout and data base system restart operations. In order to support the large volume of log data needed for data base media recovery operations, the log data is periodically copied offloaded from DASD 30 34 to DASD or tape or a mass storage subsystem MSS 22 26.Once a data set, such as 53, is offloaded from DASD 30, the DASD.space is available for recording new log data, such as 56. The relative byte address RBA is provided for addressing all log data. The RBA provides a unique description allowing a single protocol for reading any log data independently of the age or location of the data. With an RBA field of 48 bits, for example, associated with each log 20 record, the recovery log manager component to be described hereafter presents to the rest of the data base system a logical log which appears to be a 248 byte sequentially addressable space.In time sequence, a logged event occurred first if its log record has a lower 48 bit number. Only the recovery log manager component need be aware of the physical location, or residence on log devices 22 26, 30 34, and all other components need only use a 48 bit number to identify the log record desired. Assuming, for example, 100 transactions per second with 1000 bytes of log information per transaction and 3.2 x 107 seconds per year, there will be created 3.2 x 1012 bytes of log per year. Under these circumstances, it will take about 90 years to fill log 20. Referring now to Figure 2, a description will be given of boot strap data set BSDS 60, and the index which it contains of log 20. Herein, BSDS 60 includesBSDS control record 61, copy 1 active index record 62, copy 2 active index record 63, copy 1 archive index record 64, and copy 2 archive index record 65. Herein,BSDS control record 61 is a Virtual Storage Access Method VSAM Key Sequenced Data Set KSDS record having a key of 00000001 hexadecimal notation . BSDS control record 61 includes pointers, in the form of data set record identifiers VSAM keys 00000002, 00000003, 00000004, and 00000005 for active and archive index records 62 65, respectively.Copy 1 active index record 62 contains a set of entries, with each entry containing, as is illustrated in Figure 3, the data set name corresponding to the entry and the high and low RBA values for the log records stored in that data set. As is illustrated, the two entries 71 and 72 index the log records contained in active log data sets 32 and 34 respectively. Similarly, copy 2 active index record 63 indexes the active log data sets containing the second copy of the log, with the most recent data set residing on DASD 36. The archive log data set name may include a user supplied portion, and also identify the physical device on which it currently resides.Whereas, in general, one record 62 or 63 is sufficient to index all log data sets residing on active devices, a plurality of records 64, 66 67 is required for the first copy of the index to archive log data sets, and records 65,68 69 for the second copy. Each copy 1 archive index record 64, 66 is chained to the index record 66, 67 preceeding it in the chain. Each record 64 69 comprises a plurality of entries, with each entry identifying a log data set 22 26 and the RBA range 51 53 of log records stored in the corresponding log data set.In this example, copy 1 archive record 67 and copy 2 archive record 69 will each contain in their respective first entries the RBA range and name of an archive log data set. Typically, BSDS 60 would contain entries for addressing log 20 data created during the period of a few weeks log data older than that being no longer required for recovery or restart operations. Referring now to Figure 4, a description will be given of the subcomponents included in the log manager component of the invention. These subcomponents may operate asynchronously from each other, each under control of an execution unit. The execution units can be in an active state during which the subcomponent is actually working a wait state, in which the subcomponent is awaiting its opportunity to become active and a suspend state, in which there is no work requiring processing. Requests for the writing of log records are received by the log manager in the form of application or system initiated write request macros 131, 132. These requests describe the log record to be written, and are received by log output processor 101, which serializes the requests and puts the log records in buffers 40. If a predefined threshold number 167 of buffers 40 are full, log ouput processor 101 requests that asynchronous writer 105 write all filled buffers to a log data set on DASD. The operation of log output processor 101 is further described in connection with LOGWRITE Tables 14, and Figure 5. The LOGWRITE function of Table 1 takes a log record described by a log write parameter list and places it in the log. The log can be viewed as a continuous string of data bytes. This function places the new log record at the end of the data string, or log.Associated with the log record is a 48 bit RBA value, which is the offset from the beginning of the continuous byte string offset O to the byte position in which the first byte of this record is placed. The interface between log output processor 101 and asynchronous writer 105 is defined by the BLDREC, NEWBUF, and WRITER procedures of Tables 2 4. Asynchronous writer 105 runs under its own execution unit. It processes a work queue whose elements indicate log output buffers 40 which need to be written to the active log data sets 30 34. Writer 105 performs the data set write operations. when its queue is empty, writer 105 suspends its execution waiting for new work request elements from output processor 101. Writer 105 is futher described in Table 5. In the event that the system is running slowly, in the sense that requests for writing log records to log 20 are sufficiently infrequent that buffers 40 do not fill to force a request to write a buffer to active log data sets 30 34 within some reasonable period, then timer task 136 initiates a request to asynchronous writer 105 to write an incomplete buffer to an active log device.This is done to prevent an undue delay in the processing of an application program, for example, which put a log record into buffer 40 but must wait for it to be written to non volatile storage before proceeding. Output data set control is described further inTable 6. If asynchronous writer 105 fills a data set, it calls output data set control 106 to get the next active log output data set. Output data set control 106, in turn, calls BSDS task 138 to update the index records inBSDS 60 see Figures 2 and 3 , and advises offload task 107 that asynchronous writer 105 has switched from one active log data set 30 to another say, 32 . The switched from data set 30 is available for offload, which is the copying of the log data from active log data set 30 to archival media data set 26. Once the data has been copied, the active log data set 30 may be used for new log output data. The offload task 107 is further described in Table 7. A request to read the log may be received from a log read request 133,134, via log read processor 108. Table 8 describes the operation of log read processor 108, archive log read task 118, and active log read task 128.Log read function 108, 118, 128 reads log records created by the log output processor 101. The caller specifies in log read request 133, 134 the log RBA of the desired record, and receives back a copy of the log record. Log read function 108, 118, 128 accesses the desired record from the most accessible of log output buffers 40, an active log data set 30 34, or an archive log data set 2226, in that order. BSDS 60 contains a list of the active log and archive log data sets, and the RBA range of the data therein, and is accessed on behalf of log read processor 108 by BSDS task 138. Log read function 108, 118, 128 is described further in connection with Figures 6 and 7. Referring now to Figure 5, the control structures implementing the log write, or log output, processor 101 of Tables 1 4 will be described. Upon initiating a call to the log output processor 101, the caller places in machine registers 150 pointer R1 to parameter list 152 describing the log record to be written to log 20, and pointer R6 to storage location EB Execution Block 154, thence to RMFT Resource Manager Function Table location 156, and thence to log manager block LMB 160.Log manager block 160 contains in fields 161 171 pointers and values describing and addressing the various log buffers 40, log buffer control elements LBCE 185 188, and log data set descriptors LDSD 191193. Current LBCE field 161 points to LBCE 185, which is the control element for buffer 180, which is currently the receiver of log records. Next record pointer 162 points to the location in buffer 180 to receive the next log record, and space remaining field 163 specifies the number of bytes in unfilled portion 181 of the current output buffer 180. LBCE 186 points to log output buffer 182, an example of a buffer that is filled and has already been written. Last written pointer field 164 points to the LBCE 187 for the last buffer written to an active log data set, herein buffer 183.Next to write pointer 165 points to LBCE 188, which is the control element for the next buffer to be written to an active log data set, herein buffer 184. Full buffer field 166 indicates the number of full buffers 40 not yet written, herein buffer 184, or one, and threshold field 167 indicates the number of buffers which must be filled to cause write of buffers to the active log data set. W007R field 168 points to the request options block ROB 172 for the asynchronous writer 105, which will be posted to activate the asynchronous writer for processing the full buffers which have not yet been written. W007Q field 169 points to request queue 173, each entry of which represents a request waiting for the log to be written.LOGRBA field specifies the end RBA for which the request is waiting, and ROB pointer 175 points to the request options block for the request to be used in informing the requestor or caller when the request has been processed and the log record written to non volatile storage 30 34. A chain of log data set descriptors 191193 describes the active log data sets 30 34, with ACETIC field 170 pointing to LDSD 193 corresponding to the active log data set 34 now being written, and ACT1 field 171 pointing to the beginning of the LDSD chain. The manner in which the control structure of Figure 5 is utilized in practicing the invention is set forth inTables 1 through 6. The procedure for offloading active log data set 30 to archive log data set 26 is set forth inTable 7. Referring now to Figure 6 in connection with Figure 7, a description will be given of the control structure and steps for processing a request to read a log record from log 20. A more detailed description of the log read process is provided in Tables 8A and 8B. Log read cursor LRC 210 provides fields for pointers LRRB 212 to log read request block LRRB 220,ARRB 214 to archive read request block ARRB 240, andLRCCI Log Read Cursor Control Interval Address 216 to the location in main storage buffers 230 or 40 of the control interval containing the log record requested by the user. LRCCI 216 is set by the log read processor after the log record has been located in output buffer 40 or read into read buffer 230. Log read request block 220 contains field BUFF 222, which is set to point to read buffer 230 at the time read buffer 230 is set up because the desired log record is not found in the log output buffers 40.Archive read request block 240 includes BUFF field 242 which points to read buffer 230 and LDSD 244 which points to log data set descriptor LDSD 250, and is set up if the desired log record is only found in archive data set 260. If the desired log record is found in an active data set, then log data set descriptor LDSD 250 pointed to by LDSD field 245 is one of LDSD s 191 193, otherwise it is created by the log read processor see block R006, Figure 7 . Active or archive data set 260 is the one of data sets 22 26, 30 34 on which the desired log record is found, if it is not found in log output buffer 40. Figure 7 sets forth the procedure for reading log 20, with handle records procedure R003, handle control interval CI procedure R005, and handle data sets procedure R006 corresponding to log read processor 108 in Figure 4, read active log R007 to active log read task 128, and read archive log R008 to archive log read task 118. Log read request 133 invokes the log read process of Figure 7, which returns the desired log record to the user S storage area. Referring next to Figures 8 and 9, a description will be given of the data structure for log records within VSAM control intervals in log output buffers 40 and active log data sets 30 34. In Figure 8 is illustrated two VSAM control intervals 310,312, each 4096 decimal bytes in length in hexadecimal notation, 1000 bytes . Each record includes a header 330 and a data portion 370. In Figure 8 is illustrated fields 331 and 332 of header 330, with the other fields of the header shown in Figure 9. Records 1, 2, 3, and the first segment of record 4 are contained in control interval 310, with the second segment of record 4, and record 5 in control interval 312. Thus, record 4 spans 320 from control interval 310 into control interval 312. Control interval 310 includes log descriptor 340, and CI 312 includes log descriptor 350. For purposes of illustration, the example log descriptor and record header values are noted in hexadecimal notation 4 bits per character, with two characters per byte . Header field 331 specifies in the last three hex digits the length of record 1, and field 332 in the last three hex digits the length of the previous record in this control interval. The first bit of field 331, if set on, indicates that the record is null to the end of the control interval. In field 331 this bit is off however, the header of the unused portion of control interval 312 FF illustrates the use of the first bit hex F is 1111 in binary, which includes a 1 in the first bit position, bit 0 .The first two bits of field 332 are used in spanned records, with hex 4 in field 335 indicating the record is the first segment of a spanned record and hex 8 in field 336 indicating the record is the last segment of a spanned record. Record descriptor field RDF 346 and control interval descriptor field 348 occupy the last 7 bytes of the control interval. Insofar as VSAM is concerned, the entire control interval is one record hex OFF9 bytes in length with no hex 0000 free space. This is because the log manager is controlling the allocation and use of the space within the control interval. Log descriptor fields 341, offset 342, and log RBA 344 are managed by the log manager. Field 341 is set to FF to flag the end of the buffer, preventing the writing of data into the log descriptor 340. Offset field 342 points to the beginning of the last record in control interval 310 to enable read backward, and is derived by summing the lengths of all preceding records in the control interval i.e., hex 064 028 400 48C, the value in field 342 .Log RBA field 344 gives the log RBA of the first byte of control interval 310. This field, in succeeding control interval headers, is incremented by hex 1000 4096 bytes . Thus, the log RBA of control interval 310 is 00044000 and of control interval 312 it is 00045000. TheRBA value of a log record is the RBA value of the first byte of the record for example, the RBA value for record 3 in control interval 310 is hex 064 028 00044000 0004408C, the sum of fields 344 and the length of records 1 and 2. In Figure 9 are illustrated the remaining fields of log record header 330, including type fields 360,362 for identifying the record type, resource manager identifier 364 for identifying the resource manager writing the current log record to the log, unit of recovery identifier field 366, and a link field 368. The use of fields 360 368 being outside of the scope of the present invention, will not be further described. The method of the invention, and the manner of use of the data and control structures of Figures, is set forth in Tables 1 8. As will be apparent to those skilled in the art, the psuedo code of the tables may readily be coded into executable code without undue experimentation. TABLE 1 LOGWRITE PROCEDURE 0001 LOGWRITE PROCEDURE 0002 0003 0004 Inhibit concurrent processing of another log write 0005 request by obtaining the LOG WRITE LATCH exclusive 0006 IF log record length remaining space in current log buffer 0007 and buffer space 256 bytes THEN 0008 CALL NEWBUF subroutine. 0009 ELSE. 0010 CALL BLDREC subroutine. 0011 Release the LOG WRITE LATCH. 0012 IF log write request specified FORCE THEN 0013 0014 The caller s log data must be written to the log 0015 data set immediately. o 0016 0017 CALL WRITER subroutine. 0018 ELSE. 0019 IF log write request specified FORCE or WAIT THEN OD20 0021 The caller does not want control returned until o 0022 the requested log data has been written. 0023 0024 Wait until the log buffers containing the new log 0025 record have been written. 0026 ELSE. 0027 Return log record RBA to caller. 0028 0029 o Later when some process wishes to read this log s 0030 o record, that process may use this log record RBA 0031 to identify the record to be read. 0032 0033 RETURN. 0034 END LOGWRITE PROCEDURE. 0035 TABLE 2 NEWBUF SUBROUTINE OF LOGWRITE PROCEDURE 0037 NEWBUF Subroutine of LOGWRITE PROCEDURE. 0038 0039 The log buffers are used in a wrap around fashion. 0040 o Hence before reusing a buffer which contains log data 0041 o the write of the buffer to an Active Log data set must 0042 have completed. 0043 0044 0045 NEWBUF SUBROUTINE. 0046 Increment number of full output buffers by 1. 0047 IF the next buffer contains unwritten log data THEN 0048 Wait for buffer write to data set to complete. 0049 ELSE. 0050 Initialize the buffer for new output data. 0051 IF number of full output buffers threshold THEN 0052 DO. 0053 Set number of full output buffers 0. 0054 CALL WRITER subroutine. 0055 END. 0056 ELSE. 0057 RETURN. 0058 END NEWBUF Subroutine. 0059 TABLE 3 BLDREC SUBROUTINE OF LOGWRITE PROCEDUREEMI18.1 tb SEP SEP SEP 0061 tb SEP SEP BLDREC SEP Subroutine SEP of SEP LOGWRITE SEP PROCEDURE. SEP SEP SEP 0062 tb SEP SEP SEP SEP 0063 tb SEP SEP The SEP caller SEP of SEP LOGWRITE SEP specifies SEP the SEP log SEP record SEP via SEP SEP 0064 tb SEP SEP a SEP parameter SEP list. SEP The SEP entire SEP log SEP record SEP need SEP not SEP reside SEP SEP 0065 tb SEP SEP in SEP contiguous SEP storage. SEP In SEP which SEP case SEP the SEP parameter SEP list SEP SEP 0066 tb SEP SEP designates SEP the SEP storage SEP location SEP and SEP length SEP of SEP each SEP SEP 0067 tb SEP SEP portion SEP of SEP the SEP record. SEP SEP SEP 0068 tb SEP SEP SEP 0069 tb SEP SEP The SEP length SEP of SEP the SEP log SEP record SEP may SEP exceed SEP the SEP available SEP SEP SEP 0070 tb SEP SEP space SEP in SEP the SEP current SEP buffer. SEP In SEP which SEP case SEP the SEP SEP 0071 tb SEP SEP record SEP is SEP segmented SEP with SEP the SEP segments SEP placed SEP in SEP SEP SEP 0072 tb SEP SEP multiple SEP log SEP buffers. SEP In SEP other SEP words. SEP a SEP spanned SEP SEP SEP 0073 tb SEP SEP record SEP is SEP created. SEP SEP SEP 0074 tb SEP SEP SEP SEP 0075 tb SEP SEP SEP 0076 SEP tb BLDREC SEP SUBROUTINE. SEP 0077 tb SEP Set SEP pointer SEP to SEP first SEP area SEP pointer SEP in SEP the SEP parameter SEP list. SEP 0078 tb SEP Set SEP segment SEP length SEP accumulator SEP SEP 0. SEP 0079 tb SEP DO SEP UNTIL SEP ALL SEP AREAS SEP PROCESSED. SEP 0080 tb SEP IF SEP area SEP will SEP fit SEP in SEP buffer SEP THEN SEP 0081 tb SEP DO. SEP 0082 tb SEP Move SEP Move SEP area SEP into SEP buffer. SEP 0083 tb SEP Accumulate SEP segment SEP length. SEP 0084 tb SEP 1 SEP Step SEP SEP to SEP next SEP area SEP pointer. SEP 0085 SEP tb SEP END. SEP 0086 tb SEP ELSE SEP 0087 tb SEP DO. SEP 0088 tb SEP Fill SEP buffer SEP from SEP area. SEP 0089 tb SEP Accumulate SEP segment SEP length. SEP 0090 tb SEP Insert SEP accumulated SEP length SEP in SEP segment SEP header. SEP 0091 tb SEP IF SEP first SEP segment SEP of SEP record SEP THEN SEP 0092 tb SEP Complete SEP the SEP record SEP header. SEP 0093 tb SEP ELSE SEP 0094 tb SEP Complete SEP the SEP segment SEP header. SEP 0095 tb SEP CALL SEP NEWBUF SEP SUBROUTINE SEP to SEP set SEP up SEP the SEP next SEP buffer. SEP 0096 tb SEP Set SEP segment SEP length SEP accumulator SEP 0. SEP 0097 tb SEP END. SEP 0098 tb SEP END. SEP 0099 tb SEP IF SEP entire SEP record SEP in SEP this SEP buffer SEP THEN SEP 0100 tb SEP Complete SEP the SEP record SEP header. SEP 0101 tb SEP ELSE SEP 0102 tb SEP Show SEP this SEP is SEP the SEP last SEP segment SEP of SEP spanned SEP record. SEP 0103 tb SEP Update SEP LMB SEP HIGHEST SEP USED SEP RBA SEP field. SEP 0104 tb SEP END SEP BLDREC SEP Subroutine. SEP D105 tb TABLE 4 WRITER SUBROUTINE OF LOGWRITE PROCEDURE 0107 WRITER Subroutine of LOGWRITE PROCEDURE. 0108 0109 The actual log data set operations are performed by an 0110 ASYNCHRONOUS WRITE function.This subroutine builds a 0111 buffer write request element, places it on the buffer J 0112 write queue. and resumes the ASYNCHRONOUS WRITE 0113 function. 0114 0115 0116WRITER SUBROUTINE. 0117 Build buffer write request element. 0118 IF FORCE requested then 0119 Set write to include current buffer in request element. 0120 ELSE 0121 Set write up to last filled buffer in request element. 0122 IF WAIT for write completion requested. 0123 DO. 0124 Set information in request element to cause resume 0125 of the execution unit, when write completes. 0126 END. 0127 ELSE. 0128 Place request element on ASYNCHRONOUS WRITER queue. 0129 RESUME the ASYNCHRONOUS WRITER. 0130END WRITER. 0131 TABLE 5 ASYNCHRONOUS WRITER PROCEDUREEMI20.1 tb SEP 0133 tb SEP SEP , SEP SEP 0134 tb SEP ASYNCHRONOUS SEP WRITER SEP PROCEDURE SEP s SEP SEP 0135 tb SEP SEP 0136 tb SEP 0137 tb SEP DO SEP UNTIL SEP Termination. SEP 0138 tb SEP SUSPEND SEP THIS SEP EXECUTION SEP UNIT. SEP 0139 tb SEP SEP 0140 tb SEP SEP SEP 0141 SEP tb SEP SEP WHILE SEP THIS SEP MODULE SEP HAS SEP NO SEP WORK, SEP s SEP SEP 0142 tb SEP o SEP SEP IT SEP REMAINS SEP SUSPENDED SEP AT SEP THIS SEP POINT SEP SEP SEP 0143 tb SEP SEP WAITING SEP FOR SEP THE SEP NEXT SEP RESUME SEP SEP 0144 tb SEP SEP SEP 0145 SEP tb SEP SEP 0146 SEP tb SEP DO SEP WHILE SEP Buffer SEP Write SEP queue SEP is SEP not SEP empty. SEP 0147 tb SEP Locate SEP request SEP element SEP with SEP highest SEP log SEP RBA. SEP 0148 tb SEP IF SEP highest SEP RBA SEP SEP Last SEP log SEP RBA SEP written SEP SEP 1 SEP THEN SEP 0149 SEP tb SEP DD. SEP 0150 tb SEP Locate SEP next SEP buffer SEP to SEP write. SEP 0151 tb SEP IF SEP SEP copyl SEP Active SEP Log SEP output SEP data SEP set SEP is SEP full SEP THEN SEP 0152 tb SEP DO. SEP 0153 tb SEP I SEP SEP Indicate SEP a SEP copyl SEP data SEP set SEP is SEP required. SEP 0154 tb SEP l SEP SEP CALL SEP GET NEXT ACTIVE LOG OUTPUT DATA SET. SEP 0155 tb SEP END. SEP 0156 tb SEP ELSE. SEP SEP 0157 tb SEP COPYlWRITE SEP SEP 0158 tb SEP DO. SEP SEP SEP COPYlWRITE SEP SEP DO SEP SEP 0159 tb SEP Write SEP the SEP buffer SEP to SEP the SEP copyl SEP data SEP set. SEP 0160 tb SEP IF SEP Write SEP error SEP THEN SEP 0161 tb SEP DO. SEP 0162 tb SEP I SEP Indicate SEP a SEP copyl SEP data SEP set SEP is SEP required. SEP 0163 tb SEP I SEP CALL SEP GET NEXT ACTIVE LOG OUTPUT DATA SET. SEP 0164 SEP tb SEP COPY1WRITE. SEP 0165 tb SEP END. SEP 0166 tb SEP ELSE. SEP 0167 tb SEP END. SEP SEP End SEP of SEP COPY1WRITE SEP DO. SEP 0168 tb SEP I SEP I SEP IF SEP dual SEP copy SEP output SEP THEN SEP 0169 SEP tb SEP DD. SEP SEP SEP DO. SEP 0170 tb SEP IF SEP copy2 SEP Active SEP Log SEP output SEP data SEP set SEP is SEP full SEP 0171 tb SEP DO. SEP SEP 0172 tb SEP I SEP Indicate SEP a SEP copy2 SEP data SEP set SEP is SEP required. SEP 0173 tb SEP i SEP SEP CALL SEP GET NEXT ACTIVE LOG OUTPUT DATA SET. SEP 0174 tb SEP END. SEP SEP 0175 tb SEP ELSE. SEP 0176 tb SEP COPY2WRIT SEP E SEP 0177 SEP tb SEP 1 SEP SEP DO. SEP SEP SEP COPY2WRITE SEP DO SEP SEP 0178 tb SEP I SEP Write SEP the SEP buffer SEP to SEP the SEP copy2 SEP data SEP set. SEP 0179 tb SEP IF SEP Write SEP error SEP THEN SEP 0180 tb SEP DO. SEP 0181 tb SEP Indicate SEP a SEP copy2 SEP data SEP set SEP is SEP required. SEP 0182 tb SEP CALL SEP GET NEXT SEP ACTIVE LOG OUTPUT DATA SET. SEP 0183 tb SEP CDPY2WRITE. SEP 0184 tb SEP END. SEP 0185 tb SEP ELSE. SEP 0186 tb SEP END. SEP SEP SEP End SEP of SEP COPYZWRITE SEP DO. SEP 0187 tb SEP END. SEP SEP SEP End SEP of SEP dual SEP copy SEP output SEP SEP 0188 tb SEP ELSE. SEP 0189 tb SEP END. SEP SEP End SEP of SEP write SEP required SEP SEP 0190 tb SEP ELSE. SEP 0191 tb SEP IF SEP there SEP are SEP execution SEP units SEP waiting SEP for SEP this SEP write SEP 0192 tb SEP operation SEP to SEP complete SEP THEN SEP 0193 tb SEP DO. SEP 0194 tb SEP RESUME SEP each SEP waiting SEP request. SEP 0195 tb SEP END. SEP 0196 tb SEP ELSE. SEP 0197 tb SEP Free SEP the SEP buffer SEP write SEP request SEP elements SEP which SEP have SEP 0198 tb SEP been SEP processed. SEP 0199 tb SEP Update SEP END OF LOG SEP RBA SEP values SEP in SEP the SEP BSDS SEP control SEP record. SEP 0200 tb SEP END. SEP o SEP SEP End SEP of SEP DO SEP WHILE SEP Queue SEP not SEP empty. SEP SEP SEP 0201 tb SEP END. SEP SEP End SEP of SEP process SEP until SEP termination SEP loop SEP SEP 0202 tb SEP END SEP ASYNCHRONOUS SEP WRITER SEP PROCEDURE. SEP 0203 tb TABLE 6 CET NEXT ACTIVE LOG OUTPUT DATA SET SUBROUTINE 0205 GET NEXT ACTIVE LOG OUTPUT DATA SET Subroutine. 0206 0207 This subroutine updates the Boot Strap Data Set BSDS 0208 to indicate one data set is full and output has 0209 switched to another data set. 0210 0211 0212 0213 SEND MESSAGE FULL ACTIVE LOG DATA SET. 0214 Read the Active Log Data Set record from the BSDS. 0215 Update the BSDS record to show no more data will be 0216 written in the current copyl or copy2 based on input 0217 parameter data set. 0218 0219 The BSDS record now shows the LOG RBA range of the 0220 data placed in the current data set. 0221 0222 Select the next Active Log Output Data Set using the 0223 BSDS record information. 0224 Update the BSDS record to show the new current output 0225 data set. 0226 Write the updated BSDS record to the BSDS. 0227 IF OFFLOAD option is specified THEN 0228 INVOKE the OFFLOAD process. 0229 0230 The OFFLOAD process executes asynchronous s 0231 with this process. The INVOKE performs 0232 the necessary actions to get the OFFLOAD s 0233 process into execution. 0234 0235 ELSE. 0236 RETURN. 0237END GET NEXT ACTIVE LOG DUTPUT DATA SET Subroutine. 0238 TABLE 7 OFFLOAD PROCEDUREEMI22.1 tb SEP 0240 SEP tb SEP SEP OFFLOAD SEP PROCEDURE SEP SEP 0241 tb SEP SEP 0242 SEP tb SEP D243 SEP tb OFFLOAD SEP PROCEDURE. SEP 0244 tb DO SEP UNTIL SEP no SEP more SEP data SEP sets SEP to SEP OFFLOAD, SEP 0245 tb SEP Allocate SEP a SEP copyl SEP Archive SEP Log SEP Data SEP Set SEP for SEP output. SEP 0246 tb SEP IF SEP duel SEP Archive SEP data SEP sets SEP specified SEP THEN SEP 0247 tb SEP Allocate SEP a SEP copy2 SEP Archive SEP Log SEP Data SEP Set. SEP 0248 tb SEP ELSE. SEP 0249 tb SEP Position SEP the SEP Active SEP Log SEP Data SEP Set SEP to SEP be SEP OFFLOADed SEP to SEP 0250 SEP tb SEP the SEP first SEP VSAM SEP Control SEP Interval SEP of SEP log SEP data SEP which SEP has SEP not SEP 0251 tb SEP been SEP previously SEP offloaded. SEP 0252 tb SEP DO SEP WHILE SEP there SEP is SEP data SEP to SEP copy. SEP 0253 tb SEP Read SEP data SEP from SEP the SEP Active SEP Log SEP Data SEP Set, SEP 0254 tb SEP IF SEP read SEP error SEP and SEP dual SEP input SEP log SEP exists SEP THEN SEP 0255 tb SEP Read SEP data SEP from SEP the SEP alternate SEP Active SEP Log SEP Data SEP set. SEP 0256 tb SEP Write SEP the SEP data SEP to SEP the SEP Archive SEP Log SEP Data SEP Set s . SEP 0257 tb SEP 1 SEP END. SEP SEP 0258 tb SEP Close SEP and SEP deallocate SEP the SEP Archive SEP Log SEP Data SEP Sets. SEP SEP 0259 tb SEP Read SEP SEP the SEP Archive SEP Log SEP Data SEP Set SEP BSDS SEP record. SEP 0260 tb SEP Update SEP the SEP BSDS SEP record SEP to SEP reflect SEP the SEP new SEP Archive SEP Log SEP 0261 tb SEP Data SEP Set s . SEP 0262 tb SEP Update SEP the SEP highest SEP log SEP RBA SEP OFFLOADed SEP value . SEP 0263 tb SEP END. SEP SEP SEP 0264 tb END SEP OFFLOAD SEP PROCEDURE. SEP D265 SEP tb TABLE 8A LOGREAD PROCEDURE PART A EMI23.1 tb SEP 0267 SEP tb SEP LOGREAD SEP PROCEDURE SEP 0268 tb SEP SEP 0269 SEP tb FINDREC SEP 0270 tb DO. SEP SEP Start SEP of SEP FINDREC SEP DO. SEP SEP SEP 0271 tb SEP IF SEP if SEP an SEP input SEP log SEP buffer SEP is SEP assigned SEP to SEP this SEP caller SEP THEN SEP 0272 tb SEP DO. SEP 0273 SEP tb SEP 11 SEP SEP IF SEP requested SEP log SEP RBA SEP is SEP in SEP the SEP buffer SEP THEN SEP 0274 tb SEP DO. SEP 0275 tb SEP Update SEP caller s SEP log read position SEP information SEP to SEP 0276 tb SEP point SEP to SEP the SEP record SEP 0277 tb SEP Move SEP the SEP log SEP record SEP into SEP the SEP callers SEP area. SEP 0278 tb SEP RETURN. SEP 0279 tb SEP END. SEP 0280 tb SEP ELSE SEP SEP 0281 tb SEP DO. SEP 0282 tb SEP 1 SEP SEP IF SEP requested SEP log SEP RBA SEP is SEP in SEP the SEP log SEP data SEP set SEP 0283 tb SEP assigned SEP to SEP this SEP caller SEP THEN SEP 0284 tb SEP DO. SEP SEP 0285 tb SEP Read SEP the SEP block SEP containing SEP the SEP requested SEP log SEP 0286 tb SEP II SEP SEP RBA SEP from SEP the SEP data SEP set SEP into SEP the SEP input SEP 0287 tb SEP I SEP buffer SEP assigned SEP to SEP the SEP caller. SEP 0288 tb SEP I SEP Update SEP the SEP input SEP buffer SEP control SEP information SEP to SEP 0289 tb SEP i SEP SEP 1 SEP SEP show SEP the SEP log SEP RBA SEP range SEP of SEP the SEP data SEP in SEP the SEP buffer. SEP 0290 tb SEP 1 SEP SEP I SEP Update SEP caller SEP log read position SEP information SEP 0291 tb SEP I SEP SEP I SEP to SEP point SEP to SEP the SEP record. SEP 0292 tb SEP t SEP SEP Move SEP the SEP log SEP record SEP into SEP the SEP caller s SEP area. SEP 0293 tb SEP RETURN. SEP SEP 0294 tb SEP END. SEP 0295 SEP tb SEP l SEP SEP ELSE SEP 0296 tb SEP DO. SEP 0297 tb SEP l SEP SEP Release SEP the SEP input SEP log SEP data SEP set SEP assigned SEP to SEP 0298 tb SEP j SEP SEP I SEP this SEP caller. SEP 0299 tb SEP j SEP IF SEP the SEP data SEP set SEP was SEP an SEP Archive SEP Log SEP Data SEP Set SEP 0300 tb SEP and SEP anotherprocessis SEP waiting SEP touse SEP the SEP 0301 tb SEP RESUME SEP SEP the SEP process SEP waiting SEP for SEP the SEP data SEP set. SEP 0303 tb SEP I SEP ELSE. SEP 0304 tb SEP Release SEP SEP the SEP input SEP buffer SEP assigned SEP to SEP this SEP caller. SEP 0305 tb SEP END. SEP SEP 0306 tb SEP I SEP END. SEP SEP 0307 tb SEP END. SEP 0308 tb SEP I SEP ELSE. SEP tb TABLE 8B LOGREAD PROCEDURE PART B EMI24.1 tb IF SEP SEP requested SEP log SEP RBA SEP is SEP in SEP the SEP current SEP output SEP log SEP buffers SEP THEN SEP 0311 tb I SEP DO. SEP 0312 tb SEP 1 SEP SEP Update SEP caller s SEP log read position SEP SEP information SEP to SEP 0313 tb SEP 1 SEP SEP point SEP to SEP the SEP record. SEP 0314 tb SEP I SEP Move SEP the SEP log SEP record SEP into SEP the SEP caller s SEP area. SEP 0315 tb SEP I SEP RETURN. SEP 0316 tb I SEP END. SEP SEP 0317 tb ELSE. SEP SEP 0318 tb SEP IF SEP if SEP requested SEP log SEP RBA SEP is SEP in SEP an SEP Active SEP Log SEP Data SEP Set SEP THEN SEP 0319 tb SEP DO. SEP 0320 tb SEP Allocate SEP an SEP input SEP log SEP buffer SEP to SEP the SEP caller. SEP 0321 tb SEP Update SEP the SEP caller s SEP log read position SEP information SEP to SEP 0322 tb SEP show SEP the SEP data SEP set SEP and SEP buffer SEP are SEP assigned SEP to SEP the SEP 0323 tb SEP caller. SEP 0324 tb II SEP ITERATE SEP FINDREC. SEP 0325 tb SEP END. SEP 0326 tb SEP ELSE. SEP SEP 0327 tb SEP Read SEP the SEP BSDS SEP to SEP determine SEP the SEP Archive SEP Log SEP Data SEP Set SEP 0328 tb SEP containing SEP the SEP requested SEP log SEP RBA. SEP 0329 tb SEP IF SEP if SEP no SEP data SEP set SEP containing SEP log SEP RBA SEP found SEP THEN SEP 0330 tb DO. SEP SEP 0331 tb SEP I SEP Set SEP request SEP completion SEP status SEP to SEP indicate SEP the SEP 0332 tb SEP I SEP SEP requested SEP log SEP RBA SEP does SEP not SEP exist SEP in SEP the SEP log SEP 0333 tb SEP data SEP SEP sets SEP described SEP by SEP the SEP BSDS. SEP 0334 tb II SEP SEP RETURN. SEP 0335 tb I SEP END. SEP SEP 0336 tb I SEP ELSE SEP SEP 0337 tb I SEP DO. SEP SEP 0338 tb I SEP IF SEP the SEP Archive SEP Log SEP Data SEP Set SEP is SEP in SEP use SEP THEN SEP 0339 tb SEP DO. SEP 0340 tb SEP 0341 SEP tb SEP SEP SEP Archive SEP Log SEP Data SEP Sets SEP may SEP reside SEP on SEP tape. SEP SEP SEP 0342 tb SEP SEP Only SEP 1 SEP process SEP at SEP a SEP time SEP is SEP permitted SEP to SEP SEP SEP 0343 tb SEP SEP SEP use SEP an SEP Archive SEP Log SEP Data SEP Set. SEP This SEP avoids SEP SEP SEP 0344 tb SEP SEP SEP inefficent SEP positioning SEP of SEP the SEP tape SEP to SEP z SEP SEP 0345 tb SEP satisfy SEP SEP requests SEP from SEP multiple SEP processes. SEP SEP SEP 0346 tb SEP j SEP SEP 0347 SEP tb SEP I SEP Build SEP a SEP queue SEP element SEP requesting SEP use SEP of SEP the SEP 0348 tb I SEP Archive SEP SEP Log SEP Data SEP Set. SEP 0349 tb SEP Place SEP the SEP element SEP on SEP the SEP Archive SEP Log SEP Data SEP Set SEP queue. SEP 0350 tb SEP SUSPEND SEP SEP the SEP caller SEP until SEP the SEP data SEP set SEP is SEP available, SEP 0351 tb SEP END. SEP 0352 tb SEP ELSE. SEP 0353 tb SEP Allocate SEP SEP the SEP Archive SEP Log SEP Data SEP Set SEP and SEP an SEP input SEP log SEP 0354 tb SEP buffer SEP SEP to SEP the SEP caller. SEP 0355 tb SEP SEP ITERATE SEP FINDREC. SEP 0356 tb I SEP END. SEP SEP 0357 tb END. SEP SEP SEP End SEP of SEP FINDREC SEP DO. SEP SEP 0358 tb TABLE 9 PSEUDO CODE PROCEDURE OVERVIEW , 0360 o 0361 Data Base System Logging Techniques 0362 0363 0364 0365 Pseudocode procedures for the following functions were 0366 f supplied above 0367 0368 LOGWRITE This function is invoked by a log write 0369 request and runs under the execution unit 0370 of the invoker. o 0371 It Ittakes a log record described by a log 0372 write parameter list and places it in the 0373 log. The log can be viewed as a o 0374 continuous string of data bytes. This 0375 function places the new log record at the 0376 end of the data string log .Associated 0377 with the log record is a 6 byte value 0378 called the log record s RBA relative byte 0379 address . This value is the offset from 0380 the beginning of the continuous byte string 0381 offset 0 to the byte position in which 0382 the first byte of this record is placed. 0383 0384 f ASYNCHRONOUS WRITER This function runs under its 0385 own execution unit. 0386 It Itprocesses a work queue 0387 whose elements indicate log output buffers 0388 which need to be written to the Active Log z 0389 data sets. This function performs the data o 0390 set write operations. When its queue is 0391 empty, this function SUSPENDs its execution 0392 waiting for new work request elements. 0393 o 0394 OFFLOAD This function runs under its own exeuction 0395 unit. When the ASYNCHRONOUS WRITER function 0396 switches output from one Active Log Data 0397 Set to another, the switched from data 0398 set is available for OFFLOAD.OFFLOAD is 0399 the process of copying the log data from 0400 the disk log Active Log Data Sets to 0401 archival media data sets. Once the data 0402 has been copied, the Active Log Data Set z 0403 may be reused for new log output data. 0404 0405 LOGREAD This function reads log records created by 0406 the LOGWRITE function, The caller specifies 0407 the log RBA of the desired record. This 0408 function locates and returns a copy of the 0409 log record to the caller.This function 0410 accesses the record from one of the 0411 following. 0412 1. l. Log output buffers 0413 2. 2.An Active Log Data Set 0414 3. 3.An Archive Log Data Set 0415 The Boot Strap Data Set BSDS contains z 0416 a alist of the Active Log and Archive Log s 0417 data sets. Associated with each log data 0418 set entry in the BSDS is the log RBA o 0419 range of the data contained in the data set. 0420 0421 0422