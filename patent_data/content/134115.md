# Asynchronous buffered communications interface.

## Abstract
A communications interface for controlling asynchronous data transmission between a host computer and an input out put device achieves very high data transfer rates and reduces I O bottlenecks. The interface includes a microprocessor and a memory addressable thereby. The microprocessor controls data transfer from the host computer into an output buffer maintained within the memory and controls subsequent data transfer from the output buffer to an output device, indepen dently of the operation of the host computer. Data received from the host computer is stored directly into the appropriate output buffer storage location without any time consuming reading and writing of the data by the microprocessor. This is accomplished by providing a hardware register for storing data received from the host computer. At the appropriate time data transfer from the microprocessor to the memory is disabled, and data transfer from the register to the memory is enabled. Data is this rapidly transferred from the register directly into the memory location addressed by the microprocessor.

## Claims
CLAIMS 1. A communications interface for controlling data transmission between a host computer and an input output device, said communications interface comprising a programmable control means and b data storage means addressable by said programmable control means said program mable control means including means for i controlling data transfer from the host computer to an output buffer maintained within said data storage means and ii controlling data transfer from said output buffer to an output device independently of the operation of the host computer. 2. A communications interface as recited in claim 1, said programmable control means further including means for i controlling, independently of the operation of the host computer, data transfer from an input device to an input buffer maintained with in said data storage means and ii controlling data transfer from said input buffer to the host computer. 3. A communications interface as recited in claim 1 wherein said output buffer comprises a plurality of sequentially addressable data storage locations in said data storage means and wherein data received from the host computer is stored in the next sequentially available data storage location of said output buffer without reading of said data by said programmable control means. 4. A communications interface as recited in claim 1 further comprising a a register for storing data received from the host computer and b means for disabling data transfer from said programmable control means to said data storage means and for enabling data transfer from said register to said data storage means whereby data is transferred from said register into a data storage location of said data storage means addressed by said programmable control means. 5. A communications interface as recited in claim 4 further comprising a a counter for counting data characters received from the host computer and b means for resetting said counter if a preselected number of data storage loca tions of said output buffer are avail able to receive data whereby i overflow of said counter signals the host computer that no data storage locations of said output buffer are available to receive data and ii resetting of said counter signals the host computer that data storage locations of said output buffers are available to receive data. 6. A communications interface as recited in claim 4 further comprising a address storage means addressable by said programmable control means and for storing the address of the next sequen tially available storage location of said output buffer and b digital circuit means for changing said address to the address of the first data storage location of said output buffer if said address exceeds the address of the last data storage location of said output buffer. 7. A communications interface as recited in claim 4 further comprising a timer for timing host computer specified time delays between transmission of successive data characters from said output buffer to the output device. 8. A communications interface as recited in claim 4 further comprising a programmable timer for timing the rate of data transfer from said output buffer to the output device. 9. A communications interface as recited in claim 2 further comprising a register for storing data to be inputed to the host computer and wherein said programmable control means controls data transfer from said input buffer to the host computer by transferring the data from said input buffer to said register and then signalling the host computer that the data may be extracted from said register. 10. A communications interface as recited in claim 4 wherein said output buffer comprises 1,022 sequentially addressable data storage locations. 11. A communications interface as recited in claim 9 wherein said input buffer comprises 2,048 sequentially addressable data storage locations. 12. A communications interface for controlling data transmission between a host computer, a first plurality of input devices and a second plurality of output devices, said communications interface comprising a programmable control means and b data storage means addressable by said programmable control means and including a plurality of output buffers, each one of said output buffers corresponding to one of said output devices said pro grammable control means including means for i controlling data transfer from the host computer to said output buffers and ii controlling data transfer from said output buffers to said correspond ing output devices independently of the operation of the host computer. 13. A communications interface as recited in claim 12 wherein said data storage means further includes a plurality of input buffers, each one of said input buffers corresponding to one of said input devices and said programmable control means further including means for i controlling, independently of the operation of the host computer, data transfer from said input devices to said corresponding input buffers and ii controlling data transfer from said input buffers to the host computer. 14. A communications interface as recited in claim 13 wherein said output buffers each comprise a plurality of sequentially addressable data storage locations in said data storage means and wherein data received from the host computer is stored in the next sequentially available data storage location of the output buffer corresponding to the output device specified by the host computer, without reading of said data by said programmable control means. 15. A communications interface as recited in claim 12 further comprising a a register for storing data received from the host computer and b means for disabling data transfer from said programmable control means to said data storage means and for enabling data transfer from said register to said data storage means whereby data is transferred from said register into a data storage location of said data storage means addressed by said programmable control means.

## Description
ASYNCHRONOUS BUFFERED COMMUNICATIONS INTERFACE FIELD OF THE INVENTION This invention pertains to input output interfaces for facilitating communication between a digital computer and one or more input output devices.In particular, the invention pertains to an interface for controlling asynchronous communication between a digital computer and an input output device such as a high speed keyboard equipped graphics terminal. BACKGROUND Communications interfaces facilitate digital computer input output operations by controlling the flow of data transmitted by the computer to one or more output devices and the flow of data transmitted from one or more input devices to the computer. Typically, the computer is programmed to transmit output data to a communications interface which, in turn, transmits the data to the output device in controlled fashion, at the relatively slow data transfer rate at which the output device operates, thereby freeing the computer from the task of ensuring that all applicable data transmission protocols are adhered to while the data is transmitted to the output device. The computer programming for transferring data from the computer to an output device is usually such that a check is first made by the computer to determine whether the communications interface is already busy transmitting data to the output device.If the communications interface is busy , then the computer must wait some minimum time interval before again checking to see if the communications interface is free to accept fresh data. If the communications interface is free , then a data character is transmitted to the communications interface, which then enters the busy state, and transmits the data character to the output device, independently of the operation of the computer. Because the data transfer rate attainable by even a very high speed output device will be relatively slow in comparison to the data transfer rate attainable by the computer, the communications interface remains in the busy state for a comparatively long time.If the computer has additional data available for transmission to the output device it must wait until the communications interface has reverted from the busy state to the free state. Such waiting causes a bottleneck which may impede operating some very high speed output devices Esuch as graphics terminals, which may be capable of operating at 19,200 baud data transfer rates at their maximum capabilities. The present invention substantially reduces the time during which the computer must wait for the communications interface to revert from the busy state to the free state and become available to accept fresh data for transmission to the output device.The communications interface of the present invention may accept up to 1,022 data characters from the computer much faster than a conventional output device can accept that data. The data is temporarily stored in an output buffer included in the communications interface.The transfer of data from the computer to the temporary output storage buffer is handled by high speed electronic hardware, in a manner which minimizes the time the computer must wait before fresh data may be transmitted. The communications interface then transmits the data from the temporary output storage buffer to the output device at the relatively slow data transfer rate attainable by the output device and independently of the operation of the computer which initiated the data output operation. A corresponding data transfer bottleneck may be encountered during the transmission of data from an input device to the computer. The computer may, for example, be busy executing some non input task when the input device presents the communications interface with a stream of data characters for input to the computer.If the com puter does not happen to be ready to accept fresh input data then the data may be lost, necessitating retransmission of the data to the computer. The communications interface of the present invention also includes a temporary input storage buffer in which up to 2,048 input data characters received from an input device may be temporarily stored for subsequent rapid transfer to the computer. Thus, a relatively large block of data may be assembled for input to the computer. This is advantageous when input is to be received from a relatively high speed input device at a time when the computer is heavily burdened by some other operation, such as outputting data to a very high speed output device. The communications interface accepts the input data and stores it temporarily in the input storage buffer independently of the operation of the computer, thereby minimizing the likelihood that input data may be lost. It is accordingly an object of the present invention to provide a data communications interface having output buffer storage for rapidly accumulating data output by the computer and for temporarily storing that data for subsequent transmission to a relatively slow speed output device, independently of the operation of the computer. It is a further object of the invention to provide a communications interface having input buffer storage for accumulating, independently of the operation of the computer, data received from an input device and for temporarily storing that data for subsequent rapid transmission to the computer. SUMMARY OF THE INVENTION In accordance with the invention, there is.provided a communications interface for controlling data transmission between a host computer and an input output device. The communications interface comprises programmable control means and data storage means addressable by the programmable control means.The programmable control means controls data transfer from the host computer to an output buffer maintained within the data storage means. The programmable control means also controls subsequent transfer of the data from the output buffer to an output device, independently of the operation of the host computer.Further, the programmable control means controls, independently of the operation of the host computer, data transfer from an input device to an input buffer maintained within the data storage means and subsequently controls transfer of the data from the input buffer to the host computer. The output buffer comprises a plurality of sequentially addressable data storage locations in the data storage means. Data received from the host computer is stored directly into the next sequentially available data storage location of the output buffer. The programmable control means does not read or write the data. This is preferably accomplished by providing a register for storing data received from the host computer and means for disabling data transfer from the programmable control means to the data storage means and for enabling data transfer from the register to the data storage means. Data may thus be transfered from the register directly into a data storage location of the data storage means addressed by the programmable control means. Advantageously, the communications interface may also comprise a counter for counting data characters received from the host computer and means for resetting the counter if a preselected number of data storage locations of the output buffer are available to receive data. Overflow of the counter may then be used to signal the host computer that no data storage locations of the output buffer are available to receive data. Resetting of the counter may be used to signal the host computer that data storage locations of the output buffer are available to receive data. Preferably, the communications interface also comprises address storage means addressable by the programmable control means and for storing the address of the next sequentially available data storage location of the output buffer and, digital circuit means for receiving, from the programmable control means, an incremented address for storage in the address storage means and for changing the incremented address to the address of the first data storage location of the output buffer if the incremented address exceeds the address of the last data storage location of the output buffer. The communications interface may further comprise a timer for timing host computer specified time delays between transmission, by the programmable control means, of successive data characters transfered from the output buffer to the output device. A programmable timer for programming as specified by the host computer, to specify the rate of data transfer, by the programmable control means, from the output buffer to the output device may also be provided. Preferably, a register is also provided for storing data to be input to the host computer. The programmable control means controls data transfer from the input buffer to the host computer by transfering the data from the input buffer to the register and then signals the host computer that the data may be extracted from the register. In a particularly preferred embodiment, the communications interface facilitates the control of data transmission between a host computer, a first plurality of input devices and a second plurality of output devices. In this case, the data storage means includes a plurality of output buffers one output buffer corresponding to each of the output devices.The programmable control means controls data transfer from the host computer to the out put buffers and controls subsequent transfer of the data from the output buffers to their corresponding output devices. Similarly, a plurality of input buffers may be provided one corresponding to each of the input devices. The programmable control means controls data transfer from the input devices to their corresponding input buffers and controls subsequent transfer of the data from the input buffers to the host computer. BRIEF DESCRIPTION OF THE DRAWINGS FIG. 1 is a block diagram of the preferred embodiment. FIG. 2 is an electronic circuit schematic diagram of the microprocessor and electronically programmable read only memory EPROM microcircuitry of the preferred embodiment. FIGS. 3A and 3B hereinafter collectively called FIG. 3 are alignable such that they together comprise an electronic circuit schematic diagram of the random access memory RAM and RAM control microcircuitry of the preferred embodiment. FIGS. 4A and 4B hereinafter collectively called FIG. 4 are alignable such that they together comprise an electronic circuit schematic diagram of the input output control microcircuitry of the preferred embodiment. FIGS. 5A and 5B hereinafter collectively called FIG. 5 are alignable such that they together comprise an electronic circuit schematic diagram of the memory address and data control microcircuitry of the preferred embodiment. FIG. 6 is an electronic circuit schematic diagram of the host computer interrupt control microcircuitry of the preferred embodiment. The host computer interrupt control microcircuitry is standard in the art. DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTI. Introduction The preferred embodiment to be described is a quad four channel asynchronous buffered communications interface for controlling data transmission between a Digital Equipment Corporation DEC PDP 11 digital computer and up to four separate full duplexRS232C compatible input output devices. The communications interface of the preferred embodiment is controlled by programmable control means, namely, a microprocessor. Hereinafter, the term host computer is used to refer to the DEC PDP 11 computer from which output data is to be transmitted to an output device, or to which input data is to be transmitted from an input device. The term microprocessor is used exclusively to refer to the programmable control means which controls the operation of the preferred communications interface.I a . Data Transfer From Host Computer to Output Device Data is transferred, one character at a time, from the host computer to an output device in two stages. During the first stage, data is rapidly transferred, by special purpose electronic hardware operating under the microprocessor s control, from the host computer into a temporary output storage buffer provided on the communications interface. During the second stage, data temporarily stored in the output buffer is transmitted to the output device, one character at a time, independently of the operation of the host computer, and at the relatively slow data transmission rate attainable by the output device. Conventionally, the operation of transferring data from the host computer to the output buffer would be accomplished with an intermediate operation in which the microprocessor would read the data presented by the host computer and subsequently write the data into the appropriate output buffer data storage location. This, however, is relatively time consuming. In the preferred embodiment, the aforesaid special purpose electronic hardware facilitates direct storage into the output buffer of data presented by the host computer, without necessitating any reading or writing of the data by the microprocessor. Utilizatiion of the host computer s operating time is thus optimized by reducing the number of host computer operating cycles completed before the communications interface becomes free to accept another data character for output. I b . Data Transfer From Input Device to Host Computer Data is also transferred, one character at a time, from an input device to the host computer in two stages. During the first stage, which proceeds at the relatively slow data transfer rate attainable by the input device, and independently of the operation of the host computer, data received from the input device is temporarily stored in an input storage buffer provided on the communications interface. During the second stage, which occurs whenever the host computer is free to accept the input data, the data is rapidly transferred, one character at a time, from the temporary input storage buffer to the host computer. Because the first data input stage proceeds independently of the operation of the host computer, the possibility of losing input data because the host computer is too busy to accept that data is eliminated.II. Block Diagram Overview Fig. 1 is a block diagram representative of the preferred communications interface, which is capable of simultaneously controlling asynchronous data transfer between a host computer not shown and up to four output devices, and between the host computer and up to four input devices. Thus, the communications interface includes four data output channels and four data input channels. Operation of the communications interface is controlled by microprocessor 24. EPROM 38 contains the firmware program which defines the sequence of operations performed by microprocessor 24. Static RAM 26 serves as an address storage means in which tables of address pointers to the temporary input and output storage buffers are maintained. The temporary input and output storage buffers are maintained in a data storage means, namely dynamic RAM 54, which is controlled and refreshed by RAM controller 40 A separate temporary, cyclical, output storage buffer OUTBUF 28 is maintained in RAM 54 for each of the four output channels. Similarly, a separate, cyclical, input storage buffer INBUF 48 is maintained in RAM 54 for each input channel. OUTBUFs 28 each include 2,048 sequentially addressable one byte storage locations.The output buffer storage locations are used in pairs, to store a data character and an attribute code which is utilized, as hereinafter explained, to control some aspects of the manner in which the data character is transmitted to the output device. Each output buffer thus contains 1,024 pairs of one byte storage locations. However, only 1,022 pairs of storage locations are actually utilized in each buffer. This is to avoid time consuming buffer pointer address comparison operations which would otherwise be required to determine whether the oldest data character in a particular buffer might be overwritten by a newly received data character. The storage capacity of each output buffer is therefore 1,022 data characters plus 1,022 attribute codes.Although each data character stored in a particular output buffer is in fact separated, by an attribute code, from the next data character stored in the same output buffer, the output buffers are nonetheless described herein as each comprising 1,022 sequentially addressable data storage locations. Each input buffer includes 2,048 sequentially addressable data storage locations i.e. each input buffer may store a maximum of 2,048 data characters . Up to four communications interfaces, each controlling four input output channel pairs, may be used with a single host computer. Switches 47 FIGS. 1 and 5 may be set to identify each of the four possible interfaces with a unique one of four code addressable by the host computer.II a . Data Transfer From Host Computer to Output Device A transmitter ready TRDY flag is maintained for each output channel to signal the host computer when the communications interface is ready to accept a fresh data character for output via a particular channel. The hardware TRDY flags facilitate direct interrupts of the host computer. The TRDY flags, which are maintained in transmitter control status registers TCSR 12, may also be interrogated by the host computer if it is outputting data with interrupts disabled. The host computer presents the data character to the communications interface via the host computer bus 16. The eight bit data character is stored in a temporary hardware holding register TBUF 18. The host computer also presents address decoder 20 with address information identifying the output channel servicing the output device to which the data character is to be transferred. After decoding this information, address decoder 20 triggers interrupt controller 22 which interrupts the operation of microprocessor 24.Microprocessor 24 then obtains from the address pointer tables maintained in RAM 26, an address which points to the next sequentially available data storage location in whichever of OUTBUFs 28 is associated with the output device to which the data character is to be transferred. The data character is then transferred, on microprocessor bus 30, from TBUF 18, directly into the appropriate OUTBUF 28, as hereinafter explained. Microprocessor 24 controls the transfer of data from OUTBUFs 28 to their associated output devices in conventional fashion with the aid of asynchronous communication interface adapters ACIAs 42 and line drivers 44. One ACIA is provided for each input output channel pair, and each output channel is provided with a line driver 44. A counter 32 is provided for each of the four output channels to assist in ensuring as hereinafter explained that OUTBUFs 28 do not overflow. A programmable timer 34 is also provided for each output channel for timing delayed output of successive data characters, as hereinafter explained. Each channel is also provided with a programmable clock 36 for controlling the channel data transfer rate, as hereinafter explained.II b . Data Input From Input Device to Host Computer Line receivers 46 one per input channel convey serial input data from the input devices to the associated ACIAs 42 which convert the data to parallel form and, in turn, interrupt the operation of microprocessor 24. Microprocessor 24 transfers the input data character from the receiving ACIA into whichever of INBUFs 48 is associated with the output device from which the data was received. Data characters temporarily stored in INBUFs 48 are then transferred, one character at a time, by microprocessor 24 to a hardware receiver buffer RBUF 49. Each input channel is provided with a separate RBUF register. A receiver ready RRDY flag is maintained for each input channel to signal the host computer when a fresh data character is waiting to be read from the associated RBUF 49. The RRDY flags facilitate direct interrupts of the host computer. The RRDY flags, which are maintained in receiver control status registers RCSR 10, may also be interrogated by the host computer if it is inputting data with interrupts disabled.II c . Channel Status and Control The communications interface of the preferred embodiment facilitates software control, by the host computer, of the operating characteristics of each of the four input output channels serviced by the communictions interface. Channel or, port status and control registers respectively, PSTAT 14, and PCTR are maintained for each input output channel pair. By interrogating the appropriate PSTAT 14 the host computer may determine the current operating characteristics of a particular input output channel. Similarly, the host computer may, by depositing an appropriate code in a particular PCTR, change the current operating characteristics of a particular input output channel. Channel characteristics which may be determined and or controlled by the host computer are largely arbitrary, but may, for example, include the channel data transfer rate, and a flagged input mode facility for terminating input data transmission by a particular input device if the associated INBUF 48 is full. The definition of these characteristics may be varied, via suitable programming of the host computer and microprocessor 24, to suit the particular environment in which the communications interface must operate. Accordingly, in the description of the block diagram of FIG. 1 these characteristics are not discussed in great detail.III. Detailed Description of Microcircuitry and Microprocessor Firmware The communications interface of the present invention accomplishes data transfer operations with the aid of special purpose microcircuit hardware and firmware i.e. a computer program which programs the operation of microprocessor 24. The interaction between the microcircuitry and the firmware is now described in detail.III a . Registers and Microprocessor Interrupts Seven 16 bit registers are maintained on the communications interface in respect of each input output channel pair. These registers, which are addressable by the host computer via address decoders 86 FIG. 2 , are used to pass data characters, channel control and status information between the host computer and the communications interface. Six of the seven registers have already been mentioned, namely,RCSRs 10, TCSRs 12, PSTATs 14, TBUF 18, RBUFs 49, and the PCTRs. The seventh register is a data attributes register used to pass data attribute codes from the host computer to the communications interface, as hereinafter explained. The ATR, PCTR and TCSR registers each pertain to data output operations. As hereinafter explained, there are three stypes of data output operation namely, output of a normal data character to whichTCSRs 12 pertain , output of a data attribute code to which the ATTR registers pertain and output of channel control information to which the PCTR registers pertain . Since only one type of output operation may occur at any give time with respect to a particular output channel, the addresses in which the TCSRs are maintained may also be used to maintain the ATTRs andPCTRs. The three register types are distinguished by setting bits 4 and 5 thereof as will shortly be explained. The TBUF register is used only during data output operations. Conversely, the PSTAT registers are used to input status information to the host computer.Accordingly, since input and output operations never occur at the same time on a given input output channel pair, the address in which the TBUF register is maintained may also be used to maintain the PSTAT register. The registers are configured as follows Receiver Status Register RCSR Bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 UNASSIGNED RECEIVER DONE RRDY .RECEIVER INTERRUPT ENABLE RINTE . UNASSIGNED .UNASSIGNED .UNASSIGNED .UNASSIGNED .UNASSIGNEDUNASSIGNEDBit Description and Operation 15 8 Unassigned 7 This is the RRDY flag which is set when a data character has been transferred to the associated RBUF 49 for input to the host computer. It is cleared when the host reads the contents of RBUF.6 This bit, when set, causes a host computer interrupt request to be generated each time the RRDY flag is set. It may be cleared by the host program.5 0 Unassigned. Receiver Data Buffer Register RBUF Bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 UNASSIGNED RECEIVED DATABit Description and Operation 15 8 Unassigned 7 0 These bits contain the data character to be read by the host program. The data is valid only if the RRDY flag in the associated RCSR is set. Transmitter Status Register TCSR Bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 UNASSIGNED TRANSMITTER DONE TRDY . . . . TRANSMITTER INTERRUPT ENABLE TINTE . . . . .SAME STATE AS BIT 4 . . . . . . . . . . SAME STATE AS BIT 5 .UNASSIGNED .UNASSIGNED .UNASSIGNEDUNASSIGNEDBit Description and Operation 15 8 Unassigned 7 This is the TRDY flag which indicates that the host 15 computer may output data through TBUF 18.6 This bit, when set, causes a host computer interrupt request to be generated whenever the TRDY flag is set. It may be cleared by the host program.5,4 These two bits are used to indicate whether this register is to be interpreted as TCSR, ATTR, or PCTR. Both bits must be the same both set or cleared if this is to be interpreted as a TCSR register.3 0 Unassigned. Port Control Register PCTR Bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 UNASSIGNED REQUEST BIT 7 . REQUEST BIT 6 . CLEARED SET . . . . . . . . . . . . . . . . . . . . REQUEST BIT 3 . REQUEST BIT 2 REQUEST BIT 1 .REQUEST BIT O .Bit Description and Operation 15 8 Unassigned 7 Buffer Control Request Bit.6 Buffer Control Request Bit.5,4 Bit 5 must be cleared and bit 4 must be set if this is to be interpreted as PCTR register.3 0 Buffer Control Request Bits. Refer to PORT CONTROL REQUESTS in the PROGRAMMING section for correct request protocol.See Appendix A for a summary of the buffer control request codes which may be specified via appropriate settings of the buffer control request bits. Data Attributes Register ATTR Bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 UNASSIGNED START OF REPEAT SEQUENCE . . . END OF REPEAT SEQUENCE . . . . . SET CLEARED . DATA OUTPUT INHIBIT . DELAY UNITBit Description and Operation 15 8 Unassigned 7 When set this marks the first character of an output buffer repeat sequence.6 When set this marks the end character of an out put buffer repeat sequence.5,4 Bit 5 must be set and bit 4 must be cleared if this 15 is to be interpreted as an ATTR register.3 When this bit is set the character is not output to the terminal.2 0 These 3 bits indicate the delay requested before the next character is output.See Appendix A for particulars of action taken in respect of bits 7, 6 and 2 0. Transmit Data Register TBUF Bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 UNASSIGNED TRANSMITTED DATABit Description and Operation 15 8 Unassigned 7 0 These bits contain the data character to be transmitted to the output buffer and then on to the output device. The registers are configured as follows Receiver Status Register RCSR Bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 UNASSIGNED CLEARED .DOUBLE CTRL C DETECTED . . . .DATA OVERRUN .FRAMING ERROR .UNASSIGNED UNASSIGNED .UNASSIGNEDUNASSIGNEDBit Description and Operation 15 8 Unassigned 7 When cleared this bit indicates that the ter minal input status is reflected in bits 4 6. When set this bit indicates that port control request status is reflected in bits 4 6.6 When set this bit indicates that two consecutive CTRL C s were received from the input device.5 When set this bit indicates an input buffer or ACIA overflow.4 When set this bit indicates that an improperly framed character was received as the stop bit was not received as expected. It usually means that a BREAK code was received from the output device.3 0 Unassigned.See Appendix A for further particulars of action taken in respect of the assigned bits. Port Status Register PSTAT Address 176XX6 Port Control Status Request Bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 UNASSIGNED SET . . .STATUS UNASSIGNED .UNASSIGNED .UNASSIGNED UNASSIGNEDBit Description and Operation 15 8 Unassigned When set this bit indicates that the port control request status is reflected in bits 4 6. When cleared this bit indicates that terminal input status is reflected in bits 4 6.6 4 See Appendix A for the returned status bit codes.3 0 Unassigned. RCSRs 10 and TCSRs 12 are addressed via multiplexers 58 and 66 FIG. 5 . Multiplexer 58 selects for presentation on its output line the appropriate channel TRDY flag maintained, as hereinafter described, via counters 32 or RRDY flag maintained in latch 70 . Multiplexer 66 selects for presentation on its output line the appropriate channel receiver or transmit enable flag maintained in latch 62 . A host computer addressable 16 bit register 14 is used to maintain PSTATs 14. Similarly, a pair of 16 bit registers 49 comprise RBUFs 49. A single flip flop 18 comprises TBUF 18.It is not necessary to provide a separate TBUF for each output channel because, as hereinafter explained, special hardware included in the communications interface facilitates direct determination of the appropriate output buffer storage location which is to receive a data character held in TBUF 18 and also facilitates direct transfer of the data character into that storage location. The fast interrupt request FIRQ capability of microprocessor 24 FIG. 2 is used to transfer data characters or attribute codes from TBUF 18 toOUTBUFs 28 and to transfer data characters from RBUFs 49 to the host computer. FIRQ interrupts are also used to process channel control information which the host computer may transfer to the communications interface via RBUF 18. The interrupt request IRQ capability of microprocessor 24 is used to transfer data characters from OUTBUFs 28 to the associated output devices or from the input devices to the associated INBUFs 48. The non maskable interrupt NMI capability of microprocessor 24 is used by the self testing routines included in the firmware which programs the operation of microprocessor 24.III b . Microprocessor Firmware Appendix A to this specification is a source code listing of the firmware which programs the operation of microprocessor 24 in the preferred embodiment. The mainline routine included in Appendix A runs continuously whenever interrupts are not being serviced. Each pass of the mainline routine services a different input output channel pair. Accordingly, four passes through the mainline routine are required to service all four channel pairs. The mainline routine initiates data transfers from INBUFs 48 to RBUFs 49 and from OUTBUFs 28 to the associated output devices. Appendix A also includes the FIRQ and IRQ interrupt service routines for processing the previously mentioned FIRQ and RIQ interrupts. Appendix A further includes a number of selftest and diagnostic routines which are provided for testing the integrity of the memory devices, timers, and input output ports included in the communications interface. It is believed that Appendix A, together with the many explanatory comments embedded therein, will enable those skilled in the art to understand the firmware programming.III c . Data Transfer From Host Computer to Output Device The TRDY flags maintained in TCSRs 12 may be used by microprocessor 24 to signal the host computer that it may output a data character via the associated output channel. The host computer may be operating with its interrupts enabled or disabled. TCSRs 12 also include the transmit interrupt enable flags for each channel. If the host computer interrupts are enabled then operation of the host computer is interrupted if any of the four TRDY flags are set. The host computer, when interrupted, transfers control of the host computer operations to an appropriate interrupt service routine which determines whether any data is available for output to the channel associated with the TRDY flag which caused the interupt and, if so, outputs a data character to that channel.If the host computer interrupts are disabled then the host computer must periodically examine the TRDY flags maintained in TCSRs 12 to determine whether or not a data character may be output to a particular channel. Data is output by the host computer on its data lines DOO D07. Addressing information identifying the particular communications interface, output channel, and register for which the data is intended is output by the host computer on its address lines A01 A17. The address information is passed through line receivers 50 FIG. 5 to address decoder 20 which is programmed to decode the information so as to identify one of the three possible types of data output operations. These are 1. Output of a normal data character. 2. Output of data attribute information. 3. Output of channel control information.III c i . Output of Normal Data Character If a normal data character output operation is detected by address decoder 20 then its output linesTBUFA and TBUFB are both set high. After presenting the data and address information, the host computer issues a MSYN strobe pulse to indicate that the in for mation on the data and address lines has stabilized and may be latched into a register. The MSYN strobe pulse causes the data character to be latched from transceivers 84 into TBUF 18. At the same time the TBUFA and TBUFB outputs of address decoder 20 are latched into flip flop 56 FIG. 4 which outputs, on linesOUTll, ATTll, and PORTll, a one of three signal uniquely identifying which of the three possible data output operations is in progress. The OUTll line is low if a normal data character output operation is in progress.The ATTll line is low if an attribute code output operation is in progress. The PORTll line is low if a channel control information output operation is in progress. The OUTll, ATTll, and PORTll output signals of flip flop 56 are fed into interrupt controller 22.Latching of these signals into interrupt controller 22 causes the IRQ output line of interrupt controller 22 to go low which, in turn, signals an FIRQ interrupt request to microprocessor 24. Microprocessor 24 then transfers control to an appropriate firmware FIRQ interrupt service routine. Interrupt controller 22 is conventionally used to generate IRQ type interrupt requests. However, in the preferred embodiment, interrupt controller 22 is adapted so as to generate FIRQ type interrupt requests. EPROM 38 FIG. 2 contains tables of pointers to IRQ and FIRQ interrupt service routines.The lower four bits of the base address of the table ofIRQ interrupt service routine addresses are conventionally fed directly into interrupt controller 22 FIG. 4 which offsets those address bits to point into the table at the location containing the address of the appropriate IRQ interrupt service routine. ExclusiveOR gates 64 perform an additional, preliminary offset of those address bits so that the base address presented to interrupt controller 22 points to the beginning of the table of addresses of FIRQ interrupt service routines, not to the beginning of the table of addresses of IRQ interrupt service routines. Interrupt controller 22 thus presents microprocessor 24 with a vector which points to the address of the appropriateFIRQ interrupt service routine. As microprocessor 24 signals its readiness to service the FIRQ interrupt, the STRETCH output line of interrupt controller 22 goes low, causing flip flop 68 FIG. 3 to be set. When set, flip flop 68 indicates that an FIRQ interrupt is in progress. RAM 26 contains tables of addresses which point to the next available sequential storage locations in each of OUTBUFs 28, the location of the oldest data character in each of OUTBUFs 28 which has not yet been outputed to the associated output device, and corresponding pointers to each of INBUFs buffers 48. The microprocessor firmware FIRQ interrupt service routine to which control is transferred by microprocessor 24 obtains from RAM 26 the output buffer address of the next available sequential storage location which is to receive the data character held in TBUF 18. The A6 and A7 address lines of RAM 26 receive a two bit signal which indicates which of the four output channels serviced by the communications interface is to receive the data character. An immediate offset into the proper output channel address pointer table withinRAM 26 is thus obtained.Microprocessor 24 then attempts to write a data character into the addressed output buffer location. However, octal bus transceiver 72 FIG. 2 , which controls the transmission of data from microprocessor 24 onto the microprocessor bus, is disabled while an FIRQ interrupt is in progress. Thus, although microprocessor 24 attempts to write a data character into the output buffer, that character is not actually written into the output buffer. Instead, TBUF register 18 is enabled and the data character therein is transferred directly onto the microprocessor bus and into the output buffer storage location addressed by microprocessor 24. The hardware just described eliminates the need for intermediate read write operations in transferring the data character from TBUF 18 into the appropriate output buffer storage location.Thus, a single flip flop 18 and a single FIRQ interrupt service routine suffice to service the four output channels. The microprocessor firmware FIRQ interrupt service routine then increments the output buffer address pointer by two so that the pointer points to the next sequentially available data storage location in the output buffer. As previously explained, an attribute code is stored in the output buffer with each data character. Thus, two output buffer storage locations are consumed for each data character and the pointer must therefore be incremented by two. Two write operations are required to place the incremented pointer in RAM 26 because the address is 16 bits long, but may be written only eight bits at a time .Before the upper eight bits of the address pointer are written into RAM 26, they are adjusted by octal bus driver 74 to point back to the beginning of the output buffer, if the pointer has been incremented beyond the address of the last available sequential storage location in the output buffer. This may be accomplished becauseOUTBUFs 28 are located in known portions of microprocessor 24 s address space. In the preferred embodiment, octal bus driver 74 substitutes lOCClXXX binary for the upper eight bits of the address pointer before those bits are written into RAM 26. The letters CC denote the number of the output channel currently being serviced by the communications interface and the letters XXX denote the lower three bits of the address, which remain unchanged. The lower eight bits of the address pointer are then written as is into RAM 26. As the lower eight bits are written, flip flop 68 is cleared to signal completion of the FIRQ interrupt. The completion signal is produced by AND gates 76 and 78 and NAND gate 80. Specifically, the output of AND gate 76 is high when flip flop 68 is set i.e. an FIRQ interrupt is in progress , a data output operation is in progress i.e. the R W line is low and information is being written into RAM 26 i.e. line RAM is low . The output of AND gate 76 is fed into AND gate 78. The other input of AND gate 78 is an inversion of bit 0 of the microprocessor address line. Thus, if the location ofRAM 26 addressed by microprocessor 24 is even, the output of AND gate 78 will be high. The output of AND gate 78 is in turn fed into NAND gate 80 which is strobed by microprocessor 24, thereby turning off flipflop 68 which, in turn, turns off AND gate 76 to prevent resetting of flip flop 68. OUTBUFs 28 are cyclical, and, in the preferred embodiment, each comprise 2,048 bytes of contiguous address space within dynamic RAM 54. The address pointer tables stored in static RAM 26 include pointers to the address of the next sequentially available storage location in each output buffer i.e.the buffer start address and to the address of the oldest data character stored in each output buffer which has not yet been output to the output device serviced by the channel associated with the particular output buffer i.e. the buffer end address . The end address pointer is incremented by two each time a character stored in an output buffer is transmitted to its associated output device, thereby indicating that an output buffer data storage location has been freed to accept a fresh data character. As previously described, octal bus driver 74 ensures that the output buffer address pointers stored in RAM 26 wrap around to point back to the beginning of the buffer if the pointer address is incremented beyond the address of the last data storage location in the output buffer. However, care must also be taken to ensure that the output buffers are not overflowed by storing new data in buffer storage locations which contain data that has not yet been transferred to an output device. This is accomplished with the aid of ripple counters 32 Fig. 5 . The firmware which controls the operation of microprocessor 24 may, by comparing the output buffer start and end address pointers stored in RAfl 26, determine whether a particular output buffer has enough room to store at least 128 additional data characters.If the buffer has room for 128 additional data characters then the ripple counter associated with that buffer is cleared. Otherwise, the counter which is clocked by decoder 82 each time a data character is stored in TBUF 18 is allowed to continue counting.The counter overflows if the count reaches 128. The counter output constitutes the TRDY flag, which is cleared if the counter overflows, to signal the host computer that additional data characters should not be transmitted to the associated output channel. The firmware controlling the operation of microprocessor 24 does not clear counter 32 thereby raising the TRDY flag to signal the host computer that fresh data may be output to the associated channel until at least 128 locations in the associated output buffer have been freed. Microprocessor 24 transfers the data fromOUTBUFs 28 to the output devices associated therewith in routine fashion via a conventional IRQ firmware interrupt service routine. Specifically, microprocessor 24 transfers a data character from RAM 54 in which the output buffers are maintained to whichever of ACIAs 42 is associated with the output device which is to receive the data character. Octal bus transceiver 88 FIG. 3 boosts the output drive capability of RAM 54. ACIA 42 converts the data character from parallel to serial format for subsequent transmission to the output device via line driver 44 which converts the data to RS232C levels.III c ii . Output of Data Attribute Information Each data character output by the host computer may be preceded by a one byte attribute code.Before the data character is transferred to the output device, the attribute code is deciphered by the microprocessor firmware, which then takes appropriate action. Typical attributes may include, for example, time delay codes to specify that microprocessor 24 should wait some selected time interval before transmitting the next data character to the output device, a data repeat code to indicate that the particular data character should be repeatedly transmitted to the output device, etc. Appendix A particularizes the attribute codes utilized in the preferred embodiment. Address decoder 20 signals that a data attribute write operation is in progress by setting itsTBUFB output line high and its TBUFA output line low. The attribute code is then latched into TBUF 18 as though it were a normal data character. The ATT11 out put of flip flop 56 is set low to signal interrupt controller 22 that an attribute write operation is in progress. Interrupt controller 22 then causes an FIRQ interrupt of microprocessor 24 and provides it with a vector address to an appropriate FIRQ interrupt service routine. The FIRQ interrupt service routine obtains from RAM 26 the address of the output buffer location which is to receive the attribute code and then stores the attribute code in that location by direct transfer from TBUF 18 as described above. The output buffer address pointer in RAM 26 is not updated after the attribute code has been stored in the output buffer. The reason is that the host computer transmits the attribute code before transmitting the data character associated with the attribute code.The output buffer address pointer in RAM 26 must therefore not be updated until after the data character has been received from the host computer and stored in the output buffer. To signal completion of the FIRQ interrupt, the FIRQ interrupt service routine does a dummy write operation into an even addressed scratch location ofRAM 26, thereby causing AND gates 76 and 78 and NAND gate 80 to reset flip flop 68 as previously described, clearing the FIRQ interrupt status. Programmable timers 34 FIG. 4 are used by the microprocessor firmware to time the delay of any data output which may be specified via the attribute code. The timers are started by loading them with a delay code specified in the attribute code. When the timers time out, operation of microprocessor 24 is interrupted and the next data character may be outputed.III c iii . Output of Channel Control Information The third type of data output operation is the transmission, by the host computer, of channel control information. Such information is interpreted by the microprocessor firmware which may, in turn, adjust the characteristics of the particular channel in some appropriate fashion. Typical channel characteristics which might be controlled could include the channel data transmission rates which, in the preferred embodiment, may be varied between 150 baud and 19,200 baud , a capability to clear the contents of the input and or output buffers, and a flagged input facility for terminating input device data transmission if the associated INBUF 48 is full. Appendix A particularizes the channel characteristics which may be controlled in the preferred embodiment. Address decoder 20 signals that the host computer is transmitting channel control information by setting its output line TBUFB low and its output lineTBUFA high. One byte of channel control information transmitted by the host computer is then latched intoTBUF 18. As previously described, flip flop 56 sets its PORT11 output line low, thereby signaling interrupt controller 22 that a channel control data output operation is in progress. Interrupt controller 22, in turn, causes a vectored FIRQ interrupt whereby microprocessor 24 transfers control to an appropriate firmware interrupt service routine. That interrupt service routine disables the FIRQ hardware thereby disabling furtherFIRQ interrupts and then directly reads the contents of TBUF 18 to obtain the channel control information, decodes the information, and executes the appropriate channel control commands as defined by the firmware programming. The FIRQ hardware is then re enabled and the interrupt service routine terminates. Programmable timers 36 are the same devices as timers 34 which enable delayed output of successive data characters. Timers 36 are loaded with predefined codes supplied by the host computer via the PCTR registers which control the frequency of a square wave output by the timer. The square wave is used to clock to associated ACIA 42, thereby determining the rate at which data is transferred by the particular input output channel.III d . Data Input From Input Device to Host Computer Up to four input devices may be serviced by the communications interface of the preferred embodiment. The input devices present input data in serial fashion via line receivers 46 one per input channel which convert from RS232C to TTL voltage levels and transmit the data into the associated ACIAs 42. The receiving ACIA converts the serial input data to parallel form and generates an IRQ interrupt signal to interrupt the operation of microprocessor 24. Microprocessor 24 then polls each of ACIAs 42 to determine which of those four devices caused the interrupt i.e.to determine which channel received the data character . Once that determination has been made microprocessor 24 obtains from RAM 26 the address of the next sequentially available input buffer storage location which is to receive the input character, stores the input character into that address and then increments the address pointer in RAM 26. If the input buffer is full then the data character is discarded and bit 5 of the associated PSTAT 14 is set for interrogation by the host computer, thereby informing the host computer that the data character has been lost. Microprocessor 24 regularly examines the input buffer address pointers to determine whether there is any data in any of INBUFs 48 awaiting transmission to the host computer. If a non empty input buffer is detected then the oldest data character in that buffer which has not yet been transmitted to the host computer is extracted from the buffer and written into the associated RBUF 49. RBUF 49 comprises two microcircuit registers 49 which together provide four eight bit registers, one for each of the four input channels. Presentation of input data to the host computer via RBUFs 49 ensures that the host computer does not have to wait for the input character to be retrieved from the storage buffer when the host is eventually signaled that input data is waiting.The host computer may rapidly extract the data character fromRBUFs 49 via bi directional transceivers 84, thereby minimizing the time taken to complete the data input operation. When a data character is stored in a particular RBUF 49, the RRDY flat associated therewith is set to signal the host computer that the data character is waiting in RBUF 49 and may be read therefrom by the host computer. If the host computer receiver interrupts are enabled for a particular input channel, then setting of the RRDY flag for that channel automatically interrupts the host computer, which then transfers control to an appropriate interrupt service routine which reads the data character from RBUF 49. If the host computer receiver interrupts are disabled then the host computer must periodically examine the RRDY flags maintained inRCSRs 10 to determine that a data character is waiting in RBUF 49 for input to the host computer. Address decoder 20 determines that the host computer has read the data character from RBUF 49 by detecting the RBUF register address presented by the host computer. Upon such detection, decoder 20 clears the associated RRDY flag by clearing one of the four latches comprising quad latch 70. The four output lines of latch 70 constitute inversions of the RRDY flags for each input channel. Address decoder 20 also sets its RBUFR output line low to signal that the host computer has read the data character from RBUF 49. The RBUFR signal causes the FINT input of flip flop 56 FIG. 4 to go high which, in turn, enables two to four line decoder 60 which then provides a one of four signal to interrupt controller 22 representative of the particular channel from which the input character was initially received.Interrupt controller 22 then generates an FIRQ interrupt, causing microprocessor 24 to vector to an appropriate firmware interrupt service routine. That routine clears a firmware replica RRDY flag which is maintained at an even address in RAM 26. Therefore updating of the replica RRDY flag terminates the FIRQ servicing mode by causing flip flop 68 to reset as previously explained. Component values for the microcircuitry and other electronic components included in the communications interface of the preferred embodiment are specified in FIGS. 2 6. Appendix B is a listing of the microcode which programs the operation of address decoder 20 a field programmable ROM patch microcircuit in the preferred embodiment. As will be apparent to those skilled in the art, the preferred embodiment hereinbefore described is merely representative of one particular way in which the invention may be reduced to practice. Those skilled in the art may prefer alternate microcircuitry configurations for achieving the objects of the invention. Similarly, the firmware which programs the operation of microprocessor 24 may be adapted in many ways to suit the needs of any particular environment in a manner which is well understood by those skilled in the art. Thus, the foregoing description of the preferred embodiment is not to be taken as limiting the invention defined in the appended claims. APPENDIX ss TITLE LTDRIV LT 11 GUAD COMMUNICATIONS INTERFACE DR .IDENT V6. 0 i SAME AS IDENT . MOD BELOW 25 MAY 82 COPYRIGHT C 1981, BY TEKTRONIX, INC. ALL RIGHTS RESERVED THIS SOFTWARE PRODUCT IS THE PROPERTY OF TEKTRONIX, INC. AND IS PROTECTED UNDER UNITED STATES FEDERAL COPYRIGHT LAW AS AN UNPUBLISHED WORK. THIS SOFTWARE MAY NOT BE USED, COPIED, OR MODIFIED IN ANY MANNER OUTSIDE OF TEKTRONIX, IN WITHOUT THE EXPRESS WRITTEN CONSENT OF TEKTRONIX, INC. TEKTRONIX, INC.P. D. BOX 500 BEAVER OREGON 97077 U. S. A. i WRITTEN BY LANNIE J. TIERNEY IDENT AND IDENT MOD CONTAINS THE CURRENT VERSION NUMB THE VERSION IS DISPLAYED DYNAMICALLY IN SELF TEST START UP VERSION 5.0 WAS THE FIRST OFFICIALLY RELEASED VERSION OF TFIRMWARE 11 NOV 81 VERSION 5. 1 CONTAINED THE FOLLOWING ENHANCEMENTS HOLD MODE ALLOWS BLOCK MOVES OF INPUT RELOAD HOST INPUT RELOADS LAST VALID HOST INPU FLAGGED INPUT XON XOFF CONTROL TO PREVENT LOCAL ECHO REMOVED TERMINAL INPUT STATUS IS NOW CLEARED AFTER INPUT R BREAK GENERATION ADDED VERSIONS 5.2 5.9 CLEANED UP PROBLEMS WITH VERSION 5. 1 VERSION 6.0 CHANGED THE PORT CONTROL REQUEST PROTOCOL THIS IS THE SYSTEM FIRMWARE FOR THE LT ll QUAD COMMUNICATI FACE, RESIDING IN A SINGLE ROM ON THE BOARD. MOST OF THE SPENT SERVICING INTERRUPTS. HOST DATA TRANSFERS ARE DONE i VIA FIRQ INTERRUPT ROUTINES, ALONG WITH SPECIAL EXPEDITING TERMINAL I O IS DONE THROUGH IRQ INTERRUPT ROUTINES. THE IS USED TO START EVENTS. A 2K BYTE INPUT BUFFER AND A 2K OUTPUT ATTRIBUTE BUFFER FOR EACH OF THE FOUR CHANNELS IS U STORING INPUT AND OUTPUT CHARACTERS. SPECIAL HARDWARE CONSIDERATIONS THE BUFFER MEMORY IS MADE UP OF 16K OF DYNAMIC RAM. TO IN i READ WRITE ACCESS IS NOT MADE DURING A REFRESH CYCLE, A RE MUST BE REQUESTED IMMEDIATELY PRIOR TO READING OR WRITING. DONE BY DOING A SCRATCH RAM ADDRESSES 0000 03FF ACCESS.i BUFFER READ WRITE REQUEST MUST BE MADE WITHIN 20 USEC FOLL THIS REQUIREMENT ALLOWED FOR A SIMPLER HARDWARE DESIGN WIT SIGNIFICANT PERFORMANCE DEGRADATION.i ALSO. A BUFFER MEMORY READ WRITE REQUEST MAY TAKE LONGER T CYCLE, SO 16 BIT READ WRITES TO BUFFER MEMORY ARE NOT PERF , LOD, STD, LDX, STX . OTHER INSTRUCTIONS THAT DO READ MODI OPERATIONS, SUCH AS NEG, COM, CLR, ETC. CAN CAUSE AMBIGUOU PROBLEMS AND ARE AVOIDED WHEN READING OR WRITING BUFFER ME ASSEMBLY INSTRUCTIONS UNDER RT 11 R 6809 LTDRIV LTDRIV AC R CLINK LTDRIV LTDRIV L C R PROMPV LTDRIV. ROM M C 4096 L 4096. LTDRIV.LDA RT 11 V2B RSTS RT 1 , LTDRIV.ROM M C 4096 L 4096. LTDRIV.LDA RT 11 V2B AC RADIX 16ASECT .SBTTL SPECIAL CONSTANTSIDENT 6 PROGRAM VERSION NUMBERMOD O PROGRAM MODIFICATION LEVELIMASK 10 IRG INTERRUPT MASKFMASK 40 FIRQ INTERRUPT MASK IFMASK 50 , IRG FIRQ INTERRUPT MASKMRESET 3 ACIA MASTER RESET CONSTANTTXON OB5 TERMINAL TRANSMIT INTERRUPTS ENABLE CONSTAN i8 BITS 1 STOP BIT1 RECEIVE AND TRANSMIT I RTS LOWTXOFF 95 TERMINAL TRANSMIT INTERRUPTS DISABLE CONSTA i8 BITS 1 STOP BIT1 RECEIVE INTERRUPT ON, TRANSMIT INTERRUPT OFF1 RTS LOWTXROFF 15 TERMINAL TRANSMIT RECEIVE INTERRUPTS CONSTA 18 BITS DATA 1 STOP BITI NO INTERRUPTS RTBREAK OF5 BREAK GENERATION RECEIVE INTERRUPTS CONSTAN 8 BITS DATA 1 STOP BIT, RECEIVE INTERRUPTFSHOT B2 PTM CONTINUOUS TIMER OUTPUT CONSTANTSSHOT OE2 PTM SINGLE SHOT TIMER OUTPUT CONSTANTMSHOT 00 PTM MASKED INTERRUPT CONSTANTMAXRM 20 MAXIMUM SPACE IN INPUT BUFFER BEFORE SENDIN ASCII CONTROL CHARACTER DEFINITIONSNUL 00 NULLSOH 01 CTRL AETX 03 CTRL CLF 0A LINEFEEDCR OD CARRIAGE RETURNSI OF ,CTRL D XON 11 CTRL Q XOFF 13 ,CTRL SCAN 18 ,CTRL XESC 18 ,ESCAPESPACE 20 iSPACE .SBTTL BAUD RATE CONSTANTS iFOR PTM SETTINGB150 OFF 150 BAUDB300 7F 300 BAUD B600 3F 1600 BAUDB1200 lF i1200 BAUDB2400 OF 2400 BAUDB4800 07 1 4800 BAUDB9600 03 9600 BAUDB19200 01 1 19200 BAUD .SBTTL HARDWARE ADDRESSESPTMO 4202 CHANNEL O PROGRAMMABLE INTERRUPT TIMER LATCCLOCKO 4602 CHANNEL O TERMINAL BAUD RATE LATCH ADDRESS ACIA0 4800 CHANNEL O TERMINAL PORT HWCLRO 5000 CHANNEL O TRANSMIT COUNTER CLEARPSTRO 6000 CHANNEL O PORT STATUS REGISTERRBVFO 7000 ,CHANNEL O HOST INPUT REGISTERPTM1 4204 CHANNEL 1 PROGRAMMABLE INTERRUPT TIMER LATC CLOCK1 4604 CHANNEL 1 TERMINAL BAUD RATE LATCH ADDRESS ACIAl 4A00 ,CHANNEL 1 TERMINAL PORT HWCLRl 5001 CHANNEL 1 TRANSMIT COUNTER CLEARPSTR1 6001 ,CHANNEL 1 PORT STATUS REGISTERRBUF1 7001 CHANNEL 1 HOST INPUT REGISTERPTM2 4402 iCHANNEL 2 PROGRAMMABLE INTERRUPT TIMER LATCCLOCK2 4606 CHANNEL 2 TERMINAL BAUD RATE LATCH ADDRESSACIA2 4000 CHANNEL 2 TERMINAL PORTHWCLR2 5002 CHANNEL 2 TRANSMIT COUNTER CLEARPSTR2 6002 CHANNEL 2 PORT STATUS REGISTERRBUF2 7002 CHANNEL 2 HOST INPUT REGISTERPTM3 4404 CHANNEL 3 PROGRAMMABLE INTERRUPT TIMER LATCCLOCK3 4406 CHANNEL 3 TERMINAL BAUD RATE LATCH ADDRESS ACIA3 4E00 CHANNEL 3 TERMINAL PORTHWCLR3 5003 iCHANNEL 3 TRANSMIT COUNTER CLEARPSTR3 6003 CHANNEL 3 PORT STATUS REGISTERRBUF3 7003 CHANNEL 3 HOST INPUT REGISTER PICON OFFEO PROGRAMMABLE INTERRUPT CONTROLLER ENABLE ADPICOFF OFFFE PROGRAMMABLE INTERRUPT CONTROLLER DISABLE ATBUF 4000 GHOST OUTPUT REGISTER SBTTL RAM AREA .SBTTL CHANNEL O POINTER TABLECONTAINS BUFFER POINTERS, HARDWARE POINTERS AND FLAGSESPECIAL NOTES STATO MUST BE THE FIRST ENTRY IN THE TABLE WITHE TOP BYTE OF PUSHO0 MUST BE AT AN ODD ADDRESS INFLOO AND HOLDO MUST BE AT EVEN ADDRESSESTHESE RESTRICTIONS ARE DUE TO SPECIAL FIRQ HARDWARE . 0000STATO .BLKB 1 PORT TERMINAL INPUT STATUS BYTEPUSHOO .BLKB 2 OUTPUT BUFFER WRITE POINTERPOPOO .BLKB 2 OUTPUT BUFFER READ POINTERPUSHIO .BLKB 2 INPUT BUFFER WRITE POINTERPOP IO . BLKB 2 1 INPUT BUFFER READ POINTEROTFLGO .BLKB 1 OUTPUT IN PROGRESS FLAG NOT ZERO TINFLOO .BLKB 1 INPUT WAITING FOR HOST FLAG NOT ZE CCFLGO .BLKB 1 CONTROL C RECEIVED FLAG NOT ZERO THOLDO .BLKB 1 HOLD MODE FLAG NOT ZERD TRUE, MINULOOPO . BLKB 2 REPEAT MODE LOOP STARTING ADDRESS A GOFLGO .BLKB 1 1FLAG FOR ENABLING OUTPUT TO TERMINATPORTO .BLKB 2 ,TERMINAL PORT ADDRESSTTCSRO .BLKB 2 ,TERMINAL PORT CONTROL STATUS REGISTINPUTO . BLKB 2 CONTAINS POINTER TO TERMINAL INPUTOUTPTO .BLKB 2 CONTAINS POINTER TO TERMINAL OUTPUTHRBUFO .BLKB 2 HOS INPUT REGISTER ADDRESSPSTATO BLKB 2 PORT STATUS REGISTER ADDRESSTTCLRO BLKB 2 TRANSMIT COUNTER CLEAR ADDRESSPTCTLO .BLKB 2 INTERRUPT TIMER CONTROL REGISTER ADTIMERO .BLKB 2 INTERRUPT TIMER ADDRESSPTMONO . BLKB 1 INTERRUPT TIMER ENABLE CONSTANTPTMSKO . BLKB 1 INTERRUPT TIMER DISABLE CONSTANTRATEO ,BLKB 2 TERMINAL BAUD RATE LATCH ADDRESS POINTO .BLKB 2 POINTER TABLE STARTING ADDRESSATTRO .BLKB 1 LAST READ OUTPUT ATTRIBUTES LOAD .BLKB 1 INTERRUPT TIMER RELOAD COUNTKILLIO .BLKB 2 iKILL INPUT BUFFER FLAQ ADDRESS MIN KILLOO .BLKS 2 KILL OUTPUT BUFFER FLAGSADDRESS MI QUEUEO .BLKB 1 1QUEUED PORT CONTROL REQUEST NOT ZESPEEDO .BLKB 1 TERMINAL BAUD RATE VALUEMARKO .BLKB 1 iCONTAINS CHANNEL INDICATOR BIT IN L PRIVO .BLKB 1 PRIVILEGED USER FLAG NOT ZERO TRUEOBOTO .BLKB 2 1CONTAINS POINTER TO START OF OUTPUT NSFLGO .BLKB 1 NON TERMINAL INPUT STATUS IN HW STAFROZO .BLKB 1 XDFF SENT TO TERMINAL FLAG NOT ZERSHIFTO .BLKB 1 1ROTATING BIT PATTERN FOR HOST INITIECHOO .BLKB 1 ,ECHO BACK FLAG FOR SELF TEST NOT Z FLAG .BLKB 1 FLAGGED INPUT MODE FLAG NOT ZERO TCLONEO .BLKB 1 RELOAD HOST INPUT DATA FLAG NOT ZEOLDINO .BLKB 1 LAST VALID HOST INPUT DATALASTO .BLKB 1 LAST VALID TERMINAL INPUT STATUS WR 003ENOFIPO .BLKB 1 DUMMY LOCATION FOR ENDFIPSBTTL CHANNEL 1 POINTER TABLECONTAINS BUFFER POINTERS HARDWARE POINTERS AND FLAGS ,SPECIAL NOTES iSTATl MUST BE THE FIRST ENTRY IN THE TABLETHE TOP BYTE OF PUSHD1 MUST BE AT AN ODD ADDRESS INFLG1 AND HOLD1 MUST BE AT EVEN ADDRESSESTHESE RESTRICTIONS ARE DUE TO SPECIAL FIRQ HARDWARE 004O STAT1 .BLKB 1 PORT TERMINAL INPUT STATUS BYTEPUSHO1 .BLKB 2 1OUTPUT BUFFER WRITE POINTERPOPOL1 .BLKB 2 OUTPUT BUFFER READ POINTERPUSHI1 .BLKB 2 INPUT BUFFER WRITE POINTERPOPI1 .BLKB 2 INPUT BUFFER READ POINTER OTFLGI .BLKB 1 OUTPUT IN PROGRESS FLAG NOT ZERO T INFLG1 .BLKB 1 INPU WAITING FOR HOST FLAG NOT ZECCFLG1 .BLKB 1 CONTROL C RECEIVED FLAG NOT ZERO THDLD1 .BLKB 1 HOLD MODE FLAG NOT ZERD TRUE, MINU LOOP1 .BLKB 2 REPEAT MODE LOOP STARTING ADDRESS AGOFLG1 .BLKB 1 FLAG FOR ENABLING OUTPUT TO TERMINATPORT1 .BLKB 2 TERMINAL PORT ADDRESSTTCSR1 .BLKB 2 TERMINAL PORT CONTROL STATUS REGISTINPUT1 .BLKB 2 CONTAINS POINTER TO TERMINAL INPUTOUTPUT .BLKB 2 CONTAINS POINTER TO TERMINAL OUTPUTHRBUF1 .BLKB 2 iHOST INPUT REGISTER ADDRESSPSTAT1 .BLKB 2 iPORT STATUS REGISTER ADDRESSTTCLR1 .BLKB 2 TRANSMIT COUNTER CLEAR ADDRESSPTCTL1 .BLKB 2 INTERRUPT TIMER CONTROL REGISTER ADTIMER .BLKB 2 INTERRUPT TIMER ADDRESS PTMONl .BLKB 1 INTERRUPT TIMER ENABLE CONSTANTPTMSK1 .BLKB 1 INTERRUPT TIMER DISABLE CONSTANT RATE1 .BLKB 2 TERMINAL BAUD RATE LATCH ADDRESSPOINT1 .BLKB 2 iPOINTER TABLE STARTING ADDRESSATTR1 .BLKB 1 LAST READ OUTPUT ATTRIBUTESRLOAD1 .BLKB 1 INTERRUPT TIMER RELOAD COUNTKILLI1 .BLKB 2 KILL INPUT BUFFER FLAG ADDRESS MINKILLO1 .BLKB 2 KILL OUTPUT BUFFER FLAG ADDRESS MIQUEUE1 .BLKB 1 GUEUED PORT CONTROL REQUEST NOT ZESPEED1 .BLKB 1 , TERMINAL BAUD RATE VALUEMARK1 .BLKB 1 CONTAINS CHANNEL INDICATOR BIT IN LPRIV1 .BLKB 1 PRIVILEGED USER FLAG NOT ZERO TRUEOBOTl .BLKB 2 CONTAINS POINTER TO START OF OUTPUT NSFLGl .BLKB 1 NON TERMINAL INPUT STATUS IN HW STAFROZE .BLKB 1 XOFF SENT TO TERMINAL FLAG NOT ZERSHIFTS .BLKB 1 ROTATING BIT PATTERN FOR HOST INITIECHO1 .BLKB 1 ECHO BACK FLAG FOR SELF TEST NOT ZFLAGD1 .BLKB 1 FLAQQED INPUT MODE FLAQ NOT ZERO TCLONE1 .BLKB 1 RELOAD HOST INPUT DATA FLAG NOT ZEOLDIN1 .BLKB 1 LAST VALID HOST INPUT DATA LAST1 .BLKB 1 LAST VALID TERMINAL INPUT STATUS WR . 007E NOFIP1 .BLKB 1 DUMMY LOCATION FOR ENDFIP SBTTL CHANNEL 2 POINTER TABLECONTAINS BUFFER POINTERS, HARDWARE POINTERS1 AND FLAGS ,SPECIAL NOTES STAT2 MUST BE THE FIRST ENTRY IN THE TABLE iTHE TOP BYTE OF PUSHO2 MUST BE AT AN ODD ADDRESS INFLG2 AND HOLD2 MUST BE AT EVEN ADDRESSES ,THESE RESTRICTIONS ARE DUE TO SPECIAL FIRQ HARDWARE . 0080 STAT2 .BLKB 1 1 PORT TERMINAL INPUT STATUS BYTEPUSHO2 .BLKB 2 OUTPUT BUFFER WRITE POINTERPOPO2 .BLKB 2 OUTPUT BUFFER READ POINTER PUSHI2 .BLKB 2 INPUT BUFFER WRITE POINTER POPI2 .BLKB 2 INPUT BUFFER READ POINTEROTFLG2 .BLKB 1 OUTPUT IN PROGRESS FLAG NOT ZERO TINFLG2 .BLKB 1 INPUT WAITING FOR HOST FLAG NOT ZECCFLG2 .BLKB 1 CONTROL C RECEIVED FLAG NOT ZERO THOLD2 .BLKB 1 HOLD MODE FLAG NOT ZERO TRUEt MINULOOP2 .BLKB 2 REPEAT MODE LOOP STARTING ADDRESS AGOFLG2 .BLKB 1 FLAG FOR ENABLING OUTPUT TO TERMINATPORT2 .BLKB 2 TERMINAL PORT ADDRESSTTCSR2 .BLKB 2 TERMINAL PORT CONTROL STATUS REGIST INPUT2 .BLKB 2 CONTAINS POINTER TO TERMINAL INPUTOUTPT2 .BLKB 2 CONTAINS POINTER TO TERMINAL OUTPUTHRBUF2 .BLKB 2 HOST INPUT REGISTER ADDRESSPSTAT2 .BLKB 2 PORT STATUS REGISTER ADDRESSTTCLR2 . BLKB 2 TRANSMIT COUNTER CLEAR ADDRESSPTCTL2 BLKB 2 INTERRUPT TIMER CONTROL REGISTER ADTIMER2 .BLKB 2 INTERRUPT TIMER ADDRESSPTMON2 BLKB 1 INTERRUPT TIMER ENABLE CONSTANTPTMSK2 BLKD 1 INTERRUPT TIMER DISABLE CONSTANT RATE2 .BLKB 2 TERMINAL BAUD RATE LATCH ADDRESSPOINT2 .BLKB 2 POINTER TABLE STARTING ADDRESSATTR2 .BLKB 1 LAST READ OUTPUT ATTRIBUTESRLOAD2 .BLKB 1 INTERRUPT TIMER RELOAD COUNTKILLI2 .BLKB 2 KILL INPUT BUFFER FLAG ADDRESS MIN KILL02 .BLKB 2 KILL OUTPUT BUFFER FLAG ADDRESS MIQUEUE2 .BLKB 1 QUEUED PORT CONTROL REQUEST NOT ZESPEED2 .BLKB 1 TERMINAL BAUD RATE VALUEMARK2 .BLKB 1 CONTAINS CHANNEL INDICATOR BIT IN LPRIV2 .BLKB 1 PRIVILEGED USER FLAG NOT ZERO TRUEOBOT2 .BLKB 2 CONTAINS POINTER TO START OF OUTPUTNSFLG2 .BLKB 1 NON TERMINAL INPUT STATUS IN HW STAFROZ2 .BLKB 1 XOFF SENT TO TERMINAL FLAG NOT ZERSHIFT2 .BLKB 1 ROTATING BIT PATTERN FOR HOST INITI ECHO2 .BLKB 1 ECHO BACK FLAG FOR SELF TEST NOT ZFLAGD2 .BLKB 1 FLAGGED INPUT MODE FLAG NOT ZERO TCLONE2 .BLKB 1 ,RELOAD HOST INPUT DATA FLAG NOT ZEOLDIN2 .BLKB 1 LAST VALID HOST INPUT DATALAST2 .BLKB 1 LAST VALID TERMINAL INPUT STATUS WR OOBE NOFIPZ .BLKB 1 DUMMY LOCATION FOR ENDFIP SBTTL CHANNEL 3 POINTER TABLECONTAINS BUFFER POINTERS, HARDWARE POINTERS AND FLAGSSPECIAL NOTES 1STAT3 MUST BE THE FIRST ENTRY IN THE TABLE THE TOP BYTE OF PUSH03 MUST BE AT AN ODD ADDRESS INFLG3 AND HOLD3 MUST BE AT EVEN ADDRESSESTHESE RESTRICTIONS ARE DUE TO SPECIAL FIRQ HARDWARE OOCOSTAT3 .BLKB 1 PORT TERMINAL INPUT STATUS BYTEPUSHO3 .BLKB 2 OUTPUT BUFFER WRITE POINTER POP03 .BLKB 2 OUTPUT BUFFER READ POINTERPUSHI3 .BLKB 2 INPUT BUFFER WRITE POINTER POP 13 .BLKB 2 INPUT BUFFER READ POINTEROTFLG3 .BLKB 1 OUTPUT IN PROGRESS FLAG NOT ZERO TINFLG3 .BLKB 1 INPUT WAITING FOR HOST FLAG NOT ZECCFLG3 BLKB 1 CONTROL C RECEIVED FLAG NOT ZERO T HOLD3 .BLKB 1 HOLD MODE FLAG NOT ZERO TRUE, MINU LOOP3 .BLKB 2 REPEAT MODE LOOP STARTING ADDRESS AGOFLG3 BLKB 1 a FLAG FOR ENABLING OUTPUT TO TERMINATPORT3 .BLKB 2 TERMINAL PORT ADDRESSTTCSR3 BLKB 2 TERMINAL PORT CONTROL STATUS REGISTINPUT3 .BLKB 2 CONTAINS POINTER TO TERMINAL INPUTOUTPT3 .BLKB 2 CONTAINS POINTER TO TERMINAL OUTPUT HRBUF3 .BLKB 2 HOST INPUT REGISTER ADDRESSPSTAT3 .BLKB 2 PORT STATUS REQISTER ADDRESSTTCLR3 .BLKB 2 TRANSMIT COUNTER CLEAR ADDRESSPTCTL3 . BLKB 2 INTERRUPT TIMER CONTROL REGISTER ADTIMER3 .BLKB 2 INTERRUPT TIMER ADDRESSPTMON3 .BLKB 1 INTERRUPT TIMER ENABLE CONSTANT PTMSK3 .BLKB 1 INTERRUPT TIMER DISABLE CONSTANTRATE3 .BLKB 2 ,TERMINAL BAUD RATE LATCH ADDRESSPOINT3 .BLKB 2 POINTER TABLE STARTING ADDRESSATTR3 .BLKB 1 LAST READ OUTPUT ATTRIBUTESRLOAD3 .BLKB 1 INTERRUPT TIMER RELOAD COUNTKILLI3 .BLKB 2 ,KILL INPUT BUFFER FLAG ADDRESS MINKILLO3 .BLKB 2 ,KILL OUTPUT BUFFER FLAG ADDRESS MIQUEUE3 .BLKB 1 QUEUED PORT CONTROL REQUEST NOT ZESPEED3 .BLKB 1 TERMINAL BAUD RATE VALUEMARK3 .BLKB 1 CONTAINS CHANNEL INDICATOR BIT IN LPRIV3 .BLKB 1 PRIVILEGED USER FLAG NOT ZERO TRUE OBOT3 .BLKB 2 CONTAINS POINTER TO START OF OUTPUTNSFLG3 .BLKB 1 NON TERMINAL INPUT STATUS IN HW STAFROZ3 .BLKB 1 XOFF SENT TO TERMINAL FLAG NOT ZERSHIFT .BLKB 1 ROATING BIT PATTERN FOR HOST INITIECHO3 .BLKB 1 ECHO BACK FLAG FOR SELF TEST NOT ZFLAGD3 .BLKB 1 FLAGGED INPUT MODE FLAG NOT ZERO TCLONE3 .BLKB 1 RELOAD HOST INPUT DATA FLAG NOT ZEOLDIN3 .BLKB 1 iLAST VALID HOST INPUT DATALAST3 .BLKB 1 LAST VALID TERMINAL INPUT STATUS WR .SBTTL SPECIAL STORAGE LOCATIONS . 00FCENDFIP .BLKB 1 DUMMY LOCATION1 WHEN WRITTEN TO. CA SPECIAL INTERRUPT HARDWARE.THIS LOCATION MUST RESIDE AT AN EVEN ADDRESS SBTTL SCRATCH LOCATIONS FOR OPEN MODE AND SELF TES 0100IORATE SELF TEST TERMINAL BAUD COUNT FOR ERRORSOPEFLG .BLKB 1 OPEN MODE LOCATION OPEN FLAG NOT ZOPEPNT OPEN MODE INPUT BUFFER POINTER OFFSETCLKPNT .BLKB 2 CONTAINS POINTER TO NEXT BAUD RATETRACE ,CONTAINS IRQ INTERRUPT STATUS FOR SELF TESTOPEBUF .BLKB 2 OPEN MODE INPUT BUFFER FOR ADDRESSEXPDAT CONTAINS EXPECTED DATA FOR SELF TESTBLANK .BLKB 1 REOPEN MODE SCRATCH LOCATION FOR INPURECDAT a CONTAINS RECEIVED DATA FOR SELF TESTOPEDAT .BLKB 1 iOPEN MODE INPUT BUFFER FOR DATA SPEIOCHAN .BLKB 1 iCURRENT CHANNEL BEING TESTED FOR SEIOATT .BLKB 1 ATTRIBUTE STORAGE FOR SELF TEST I OERRFMT .BLKB 1 ERROR FORMAT FOR SELF TEST I O ERROENDRAM ..SBTTL STACK . 0400STACK .BLKB 1 STACK MOVES TOWARDS LOW MEMORY FROM SBTTL POINTER TABLE OFFSETS STATX STATO STAT0 POINTS TO PORT TERMINAL INPUT STATU PUSHOX PUSHOO STATO iPOINTS TO OUTPUT BUFFER WRITE POINTPOPOX POPOO STATO 1POINTS TO OUTPUT BUFFER READ POINTEPUSHIX PUSHIO STATO POINTS TO INPUT BUFFER WRITE POINTEPOPIX POPIO STATO POINTS TO INPUT BUFFER READ POINTER OTFLGX OTFLG0 STATO POINTS TO OUTPUT IN PROGRESS FLAGINFLGX INFLGO STATO POINTS TO INPUT WAITING FOR HOST FLCCFLGX CCFLGO STATO POINTS TO CONTROL C RECEIVED FLAGHOLDX HOLDO SYATO ,POINTS TO HOLD MODE FLAGLOOPX LOOPO STATO 1POINTS TO REPEAT MODE LOOP STARTINGGOFLGX GOFLGO STATO POINTS TO TERMINAL ENABLE OUTPUT FL TPORTX TPORT0 STATO POINTS TO ADDRESS OF TERMINAL PORT TTCSRX TTCSRO STAT0 POINTS TO ADDRESS OF TERMINAL CONTR INPUTX INPUTO STATO POINTS TO TERMINAL INPUT SERVICE RO OUTPTX OUTPT0 STATO a POINTS TO TERMINAL OUTPUT SERVICE R HRBUFX HRBUFO STAT0 POINTS TO ADDRESS OF HOST INPUT REG PSTATX PSTATO STAT0 POINTS TO ADDRESS OF PORT STATUS RETTCLRX TTCLRO STATO POINTS TO ADDRESS OF TRANSMIT COUNT PTCTLX PTCTL0 STATO POINTS TO TIMER CONTROL REGISTER ADTIMERX TIMERO STATO ,POINTS TO ADDRESS OF INTERRUPT TIMEPTMONX PTMONO STATO a POINTS TO INTERRUPT TIMER ENABLE COPTMSKX PTMSKO STATO POINTS TO INTERRUPT TIMER DISABLE C RATEX RATEO STATO POINTS TO ADDRESS OF TERMINAL BAUDPOINTX POINTO STATO POINTS TO START OF TABLE POINTER AD ATTRX ATTRO STAT0 POINTS TO LAST READ OUTPUT ATTRIBUTRLOADX RLOADO STATO POINTS TO INTERRUPT TIMER RELOAD COKILLIX KILLIO STATO POINTS TO KILL INPUT BUFFER FLAGGED KILLOX KILLOO STATO POINTS TO KILL OUTPUT BUFFER FLAG A QUEUEX QUEUEO STATO POINTS TO QUEUED PORT CONTROL REVUESPEEDX SPEEDO STATO POINTS TO TERMINAL BAUD RATE VALUE MARKX MARKO STAT0 POINTS TO CHANNEL INDICATORPRIVX PRIVO STATO POINTS TO PRIVILEGED USER FLAGOBOTX OBOTO STATO POINTS TO START OF OUTPUT BUFFER PO NSFL6X NSFLGO STATO ,POINTS TO HW STATUS HOLDS NON TERMI FROZX FROZO STÁTO iPOINTS TO XOFF SENT TO TERMINAL FLA SHIFTX SHIFTO STATO POINTS TO ROTATING BIT PATTERN FORECHOX ECHOO STATO POINTS TO SELF TEST ECHO BACK FLAGFLAGDX FLAGDO STATO POINTS TO FLAGGED INPUT MODE FLAG CLONEX CLONE0 STATO POINTS TO RELOAD HOST INPUT DATA FL OLDINX OLDINO STATO POINTS TO LAST VALID HOST INPUT DAT LASTX LASTO STAT0 POINTS TO LAST VALID TERMINAL INPUT SBTTL MISCELLANEOUS OFFSETSCLKMAX MAXTBL CLKTBL POINTS TO CORRECT POSITION IN BAUDCLKMIN MINTBL CLKTBL POINTS TO CORRECT POSITION IN BAUD .SBTTL INPUT AND OUTPUT BUFFERS ALL BUFFERS ARE CIRCULAR 8000INBUFO .BLKB 800 CHANNEL O INPUT BUFFEROTBUFO .BLKB 800 CHANNEL O OUTPUT BUFFER i9000INBUF1 .BLKB 800 CHANNEL 1 INPUT BUFFEROTBUF1 .BLKB 800 CHANNEL 1 OUTPUT BUFFER 0A000 INBUF2 .BLKB 800 CHANNEL 2 INPUT BUFFEROTBUF2 .BLKB 800 a CHANNEL 2 OUTPUT BUFFER ,0B000INBUF3 .BLKB 800 CHANNEL 3 INPUT BUFFEROTBUF3 .BLKB 800 CHANNEL 3 OUTPUT BUFFER OF000THIS WORD CONTAINS THE CHECKSUM FOR THE ENTIRE ROM PROMPV PUTS IT HEREVERIFY .WORD O CHECKSUM FOR THIS ROM .SBTTL PROGRAM STARTING POINTTHE POINTER TABLE FOR EACH CHANNEL IS INITIALIZED IN TURNSALONG WITH ACIA S AND PTM S ,SWI2 INTERRUPT COMES HERE TOOSTART LDS num STACK a INITIALIZE STACK POINTER FOR NMI RECOGNITIOSTA PICOFF DISABLE PROGRAMMABLE INTERRUPT CONTROLLERLBSR INIT iINITIALIZE POINTER TABLE AND HARDWARE REGISRSTART STA PICON DUMMY WRITE TO ENABLE PROGRAMMABLE INTERRUP .SBTTL MAINLINETHE MAINLINE IS USED MAINLY FOR STARTING EVENTS AND IS NOT FOR REAL TIME EVENT CONTROL. THIS SECTION RUNS ONLY WHEN I AWARE NOT BEING SERVICED. IT TAKES 4 COMPLETE PASSES OF THE MAINLINE IN ORDER TO SERVALL 4 CHANNELS ONE PASS PER CHANNEL PATROL LDX num STAT3 PRESET CHANNEL TABLE POINTERNEXTCH TFR X.D MOVE POINTER TO CHANNEL TABLE POINTER TO ACADDB num 40 AND POINT TO NEXT CHANNEL TO BE SERVICEDTFR D,X iRETURN VALUE TO XACTIVE TST QUEUEX. X ANY PORT CONTROL REQUEST WAITING LBNE COMPLY YES. SERVICE ITLDY XKILLIX,X iHAS KILL INPUT BUFFER REQUEST BEEN MADE BPL ENABLE ,NO. GO ONSTY POPIX. X YES. STORE NEW INPUT BUFFER READ POINTER CLR INFLQX. X X a IGNORE ANY CURRENTLY WAITING CHAR CLR KILLIXwX ACKNOWLEDGE KILL INPUT REQUEST 1SECTION TO ENABLE SUSPENDED TERMINAL TO HOST INPUTENABLE TST FROZX. X IS TERMINAL INPUT SUSPENDED BLE PROMPT NO. TAKE NO ACTION MINUS QUEUED LDD POPIX. X YES.LOAD INPUT BUFFER READ POINTER SUBD PUSHIX, X DETERMINE NUMBER OF FREE INPUT BUFFER LOCATANDA num 7 ONLY LOOK AT 11 BITS 2K CMPD num CMAXRM 2 RE ENABLE INPUT BLS PROMPT NO, MAYBE LATERLDA num XON 80 YES. QUEUE XONSTA FROZX, X iSECTION TO CONTROL HOLD MODE WARNING USE OF DELAY BITS IN ATTRIBUTE BYTE HOST OUTPUT i CAN CAUSE UNPREDICTABLE EVENTS TO OCCURPROMPT LDB HOLDX, X a IS HOLD MODE IN EFFECT BEG INCHEK NO, USE NORMAL INPUT PROCESSINGBPL 1 YES, FIRST CHARACTER IS ALREADY INLDY PUSHIX, X HAS FIRST CHARACTER ARRIVED CMPY POPIX, XBEQ PRIMER NO, CHECK AGAIN LATERANDB num OF YES, INDICATESTB HOLDX, X BY CLEARING MSBANDB num 3 ONLY LOOK AT COUNTDOWN TIME BITSBEQ INCHEK NO DELAY REQUESTED1 SWITCH TO NORMAL INPUTLBSR SETOFF START COUNTDOWNBRA ACTIVE CHECK FOR MORE ACTIVITY FOR THIS CHANNEL 1 BITB 3 a IS TIMEOUT HOLD MODE IN EFFECT BEG INCHEK NO, PROCESS INPUTTST RLOADX, X a IS COUNTDOWN TIMER ARMED BNE PRIMER YES, INPUT IS STILL ACTIVESECTION TO PROCESS NORMAL INPUT BETWEEN INPUT BUFFER ANDHOST INPUT REGISTERINCHEK TST CLONEX, X RELOAD HOST INPUT DATA BNE a8 YESa DO ITTST INFLGX, X NO, IS THERE INPUT WAITING FOR HOST BNE PRIMER YES, GO ONCLR LASTX, X a ASSUME OLD STATUS ALREADY READLDY POPIX, X DOES INPUT READ POINTER EQUAL WRITE CMPY PUSHIX, XBEQ PRIMER YES, INPUT BUFFER IS EMPTYTST NSFLGX, X a IS NON TERMINAL INPUT STATUS IN HW STATUS RBNE 1 YES, DON T CHANGE HW PORT STATUSORCC num IMASK MAKE SURE STATUS DOESN T CHANGELDA STATX,X a GET LATEST STATUSSTA LASTX, X SAVE AS LAST VALID PORT STATUS REFLECTED TOSTA PSTATX, X AND TRANSFER TO HW PORT STATUS REGISTERCLR STATX, X a START ON NEW STATUSANDCC num CIMASK iRE ENABLE IRQ INTERRUPTS 1 CLR NSFLGX, X a MAKE SURE THAT NEXT READ REFLECTS TERMINALLDA ,Y FETCH NEXT CHAR TO INPUT TO HOSTSTA XOLDINX.X SAVE AS LAST LOADED HOST INPUT DATATFR Y, D MOVE UPDATED READ POINTER TO ACANDA num CB TAKE CARE OF ANY WRAP AROUND STD POPIX, X SAVE NEW POINTER 2 INC INFLGX, X SET INPUT WAITING FOR HOST FLAGLDA OLDINX,X LOAD DATASTA HRBUFX, X AND MOVE TO HARDWARE REGISTERCLR XCLONEXwX a ASSUME RELOAD COMPLETELBRA ACTIVE CHECK FOR MORE ACTION ON THIS CHANNELPRIMER LDY PUSHOX, X SAVE CURRENT OUTPUT WRITE POINTER FOR LATERLDD POPOX, X a TIME TO CLEAR HARDWARE CHAR COUNTER SUBD PUSHOX, XBEQ 1 a ZERO MEANS LOTS OF ROOMANDA num 7 ONLY LOOK AT LOWER 11 BITS OF DIFFERENCE 2CMPD num 200 ROOM FOR MORE THAN 512 BYTES BHI 1 YES, RESET HARDWARE COUNTERCMPD num 104 NO, ROOM FOR MORE THAN 256 BYTES POSSIBLYBLS 28 NO, GO ONORCC num IFMASK NO INTERRUPTIONS FOR THIS STEPCMPY PUSHOX, X HAVE WE HAD HOST OUTPUT VERY RECENTLY BNE 2 YES, MAYBE WE SHOULD RE EVALUATE. ..LATER 1 STA TTCLRX, X RESET HARDWARE OUTPUT COUNTER 2 ANDCC num CIFMASK RE ENABLE INTERRUPTSTST OTFLGX, X IS THERE OUTPUT IN PROGRESS LBNE NEXTCH YES, SERVICE NEXT CHANNELLDY POPOX, X NO, FETCH BUFFER READ POINTERLDD KILLOX, X HAS KILL OUTPUT BUFFER REQUEST BEEN MADE BPL 5 NO, GO ONSTD POPOX, X YES, UPDATE BUFFER READ POINTERCLRA a CLEAR DATA TO BE USEDTST LOOPX, X IS LOOP MODE ENABLED BPL 3 NO, USE CURRENT READ POINTER AND PLAY CATCHLDY LOOPX, X YES, USE START OF LOOP POINTERCLR LOOPX, X CLEAR LOOP MODE FLAG 3 TST STATO DUMMY READ TO REFRESH BUFFER MEMORYSTA 1, Y CLEAR ATTRIBUTE LOCATIONCMPY KILLOX, X iCLEARED ALL ATTRIBUTE LOCATIONS BEQ 4 YES, GO ONEXG Y.D NO, UPDATE POINTERANDA num C8 MAKE ROOM FOR ANY OVERFLOWADDD num 2 i2 BYTES TO NEXT ATTRIBUTEORA num 8 RESTORE BUFFER ADDRESS BITEXG D,Y MOVE BACK TO YBRA 3 CLEAR NEXT LOCATION 4 CLR XKILLOX,X ACKNOWLEDGE KILL OUTPUT BUFFER REQUEST 5 CMPY PUSHOX, X IS DUTPUT BUFFER EMPTY BNE 6 NO, INITIATE OUTPUT TST FROZX. X a IS XON QUEUED LBPL NEXTCH NO. SERVICE NEXT CHANNEL 6 TST QOFLGX. X IS TERMINAL OUTPUT INHIBITED LBNE NEXTCH YES. SERVICE NEXT CHANNELSEND LDA num TXON ENABLE OUTPUT INTERRUPTSSTA OTFLGX. X SET OUTPUT IN PROGRESS FLAGSTA TTCSRX.X REST IS AUTOMATICLBRA ACTIVE CHECK FOR MORE ACTION ON THIS CHANNEL SECTION TO SERVICE QUEUED PORT CONTROL REQUESTSTHE MOST SIGNIFICANT BIT OF THE HW PORT STATUS REGISTER ISCOMPLETION EXCEPT FOR RETURN TERMINAL INPUT STATUS THE PORT11 ROUTINE EXPLAINS REQUESTS IN DETAILCOMPLY CLRB PREPARE FOR REQUEST CLEARORCC num IFMASK ,NO INTERRUPTIONS FOR NEXT STEPLDA GUEUEX, X a FETCH QUEUED REQUESTSTB GUEUEX, X CLEAR QUEUE REQUEST FLAG STB IS FASTER TANDCC num CIFMASK RESTORE INTERRUPT MONITORINGCMPA num 1A RETURN TERMINAL INPUT STATUS BNE 1 ,NO, GO ONLDB STATX, X LOAD VERY LATEST STATUSANDB num 40 BUT.ONLY DOUBLE CTRL C BIT FOR NOWORB LASTX X ADD IN LAST REFLECTED TERMINAL INPUT STATUSBRA SIGNAL COPY TO PORT STATUS REGISTER 1 LDB num 80 PRESET FINAL DATA FOR HW STATUS REGISTERCMPA ODO, IS SPECIAL MODE REQUEST BHS MODE YES, TAKE CARE OF ITTSTA a KILL BUFFER REQUEST BMI ZERO YES, PROCESSASLA a IS BUFFER EMPTY REQUEST LBMI UPDATE YES, GO DO ITANDA 7 2 ONLY LOOK AT BAUD BITSLDY num CLKTBL POINT TO START OF BAUD RATE TABLELDY A.Y FETCH NEW BAUD RATESTY RATEX.X AND TRANSFER TO HARDWAREASLA MOVE BAUD BITS TO UPPER HALF OF BYTEASLAASLASTA SPEED, X aAND STORE INTO POINTER TABLEBRA SIGNAL a INDICATE REQUEST COMPLETEDTHIS SECTION HANDLES SPECIAL MODE SELECTIONSSUCH AS BINARY, PRIVILEGED USER HOLD RELOAD HOST INPUT DAAND FLAGGED INPUT MODESTHIS IS PART OF THE COMPLY SECTIONMODE CMPA num ODE BINARY NON BINARY INPUT MODE REQUEST BHS CHANGE YES, GO ONBITA num 8 a IS THIS A HOLD MODE REQUEST BEG 4 NO. GO ON BITA num 4 CANCEL HOLD MODE BNE 25 YES. DO ITTST INFLGX. X aNO, IS FIRST CHARACTER ALREADY WAITING BEQ 1 NO.GO ONLDA num 40 YES, INDICATE BY CLEARING MSB AND COUNTDOWN 1 STA HOLDX. X iSET HOLD MODEBRA SIGNAL REQUEST SERVICED 2 LDA HOLDX. X IS TIMEOUT HOLD MODE IN EFFECT BITA num 3BEQ 39 NO. LEAVE TIMER ALONELDA XPTMSKXgX RELOAD MASK TO STOP TIMER WHETHER OR NOT STASTA PTCTLX. X AND STOP ITCLR RLOADX. X a INDICATE COUNTDOWN COMPLETE 3 CLR HOLDX. X INDICATE HOLD HOME CANCELEDCLR INFLOX. X IGNORE ANY WAITING INPUTBRA SIGNAL REQUEST SERVICED 4 BITA num 4 RELOAD HOST INPUT DATA BEQ 5 NO. GO ONSTA CLONEX. X YES.GUEUEBRA SIGNAL REQUEST SERVICED 5 BITA num 2 FLAGGED INPUT REQUEST BEQ 6 aNO, MUST BE PRIVILEGED USER REQUESTANDA num 1 REVEAL INDICATED STATESTA XFLAGDX,X AND SAVEBRA SIGNAL REQUEST SERVICED 6 ANDA num 1 REVEAL INDICATED PRIVILEGED USER STATESTA PRIVX. X AND SAVEBRA SIGNAL REQUEST SERVICEDCHANCE LDY num HOSTIN DEFAULT INPUT ROUTINE FOR NON BINARY MODEBITA num 1 SET BINARY INPUT MODE BNE l NO. NON BINARYCLR GOFLGX. X YES, MAKE SURE OUTPUT CONTROL FLAG IS CLEARLDY num LTREAD CHANGE TO BINARY INPUT ROUTINE 1 STY INPUTX,X SAVE INPUT ROUTINE POINTERSIGNAL STB XNSFLGX,X SAVE NON TERMINAL INPUT STATUS IN HW STATUSSTB PSTATX. X a INDICATE REQUEST COMPLETED LBRA ACTIVE AND CHECK FOR MORE ACTION SECTION TO KILL INPUT AND OR OUTPUT BUFFER THIS IS PART OF THE COMPLY SECTION BIT 3 OF REQUEST BYTE SET, ZEROES THE OUTPUT BUFFER ,BIT 2 OF REQUEST BYTE SET, ZEROES THE INPUT BUFFER BIT 1 OF REQUEST BYTE SET, ZEROES THE TERMINAL INPUT STATUS SPECIAL NOTE THE HOST INPUT REGISTER MAY CONTAIN A WAITINEVEN THOUGH THE INPUT BUFFER IS ZEROED ZERO BITA num 8 KILL OUTPUT BUFFER BEQ 1 NO, MAYBE INPUT BUFFERORCC num IMASK NO IRQ INTERRUPTS FOR NEXT STEPLDY PUSHOX, X FETCH OUTPUT WRITE POINTERSTY POPOX, X AND STORE AS NEW OUTPUT READ POINTERANDCC num CIMASK RE ENABLE IRQ INTERRUPT MONITORINGLBSR CLRATT MAKE SURE THAT ALL ATTRIBUTE BYTES ARE CLEA 1 BITA num 4 KILL INPUT BUFFER BEG 2 NO, PROBABLY ZERO TERMINAL INPUT STATUSORCC num IMASK iNO IRQ INTERRUPTS FOR NEXT STEPLDY PUSHIX, X FETCH CURRENT INPUT BUFFER WRITE POINTERSTY POPIX, X AND SAVE AS NEW INPUT BUFFER READ POINTERANDCC num CIMASK aRE ENABLE IRQ INTERRUPT MONITORING 2 BITA num 2 ZERO TERMINAL INPUT STATUS BEG SIGNAL NO, REQUEST COMPLETEORCC num IMASK YES, DON T LET STATUS CHANGECLR STATX, X a ZERO LATEST STATUSCLR LASTX, X a AND THAT LAST REFLECTEDANDCC num CIMASK RE ENABLE INTERRUPTSBRA SIGNAL ALL DONESECTION TO RETURN LT 11 STATUSBIT 3 OF REQUEST BYTE SET1 RETURNS BUFFER EMPTY STATUS IN B i 6 AND 7 OF THE HARDWARE PORT STATUS REGISTER PSTR PRIVILEGE STATUS IN BIT 5.BIT 1 SET, WITH BITS 2 AND 3 CLEARED, RETURNS THE CURRENT P TO THE HARDWARE PORT STATUS REGISTER BIT O SET1 WITH BITS 1, 2, AND 3 CLEARED RETURNS THE CURRE NUMBER TO THE HOST INPUT REGISTER 1THIS IS PART OF THE COMPLY SECTIONUPDATE BITA num 8 2 BUFFER EMPTY STATUS REQUEST BEQ BAUD NO, GO ONTST PRIVX, X IS USER PRIVILEGED BEQ 1 NO, NON PRIVILEGEDORB num 10 YES, INDICATE 1 LDY PUSHOX, X FETCH OUTPUT BUFFER WRITE POINTERCMPY POPOX, X a IS OUTPUT BUFFER EMPTY BNE 28 NO, CHECK INPUT BUFFERTST OTFLGX, X MAYBE, IS CHAR IN PROGRESS BNE 2 YES, BUFFER IS NOT EMPTYTST KILLOX,X IS KILL OUTPUT BUFFER REQUEST STILL QUEUED BMI 2 YES, BUFFER IS NOT EMPTY ORB num 40 a INDICATE OUTPUT BUFFER EMPTY 2 LDY PUSHIX. X FETCH INPUT BUFFER WRITE POINTERCMPY POPIX. X IS INPUT BUFFER EMPTY BNE SIGNAL NO, WRITE TO HARDWARETST INFLGX. X MAYBE, IS CHAR WAITING FOR HOST BNE SIGNAL YES, INPUT IS NOT EMPTYORB num 20 a INDICATE INPUT BUFFER EMPTYBRA SIGNAL COPY TO HARDWARE STATUS REGISTERBAUD BITA 1 2 RETURN FIRMWARE VERSION NUMBER BNE FWVER YES, DO ITORB SPEEDX. X iFETCH BAUD RATE FOR THIS PORTBRA SIGNAL AND WRITE TO HARDWARE PORT STATUS REGISTERFWVER LDA num IDENT num 10 MOD YES. LOAD FIRMWARE VERSION NUMBERINC INFLQX. X SET CHARACTER WAITING FOR HOST FLAGSTA HRBUFX.X AND WRITE TO RECEIVER REQISTERBRA SIGNAL DONE SBTTL FIRQ INTERRUPT SERVICE ROUTINESSBTTL HOST DATA INPUT INTERRUPT SERVICE ROUTINE PROGRAM CONTROL COMES HERE AFTER THE HOST READS A CHARACTERGHOST INPUT REGISTER 176XX2 THIS ROUTINE IS COMMON FOR ALL FOUR CHANNELSTHE HARDWARE AUTOMATICALLY REFERENCES THE CORRECT POINTER T IN11 TST HOLDO a IS HOLD MODE IN EFFECT BEQ 1 NO, GO ONCLR HOLD0 a INDICATE HOLD MODE COMPLETE AND CANCEL SPECRTI AND RETURN 1 CLR INFLGO iCLEAR INPUT FLAG AND CANCEL SPECIAL HARDWARRTI AND RETURN .SBTTL HOST DATA OUTPUT INTERRUPT SERVICE ROUTINE THIS ROUTINE IS COMMON FOR ALL FOUR CHANNELS THE HARDWARE AUTOMATICALLY TAKES CARE OF STORING CHARACTER iAND HANDLES WRAP AROUND OF NEW BUFFER WRITE POINTERCONTROL COMES HERE ON WRITE TO ADDRESS 176XX6 REGISTER U IS RESERVED FOR FIRQ INTERRUPTS AND SELF TEST ST OUTll LDU PUSHOO FETCH OUTPUT BUFFER WRITE POINTERSTA ssU LET HARDWARE TRANSFER DATA TO OUTPUT BUFFERSTU PUSHDO SAVE NEW POINTERRTI HARDWARE DESERVES MOST OF CREDIT .SBTTL HOST DATA ATTRIBUTE OUTPUT INTERRUPT SERVICE ROUTINETHIS ROUTINE IS COMMON FOR ALL FOUR CHANNELSTHE HARDWARE AUTOMATICALLY STORES BYTE PROPERLY iREGISTER U IS RESERVED FOR FIRQ INTERRUPTS AND SELF TEST ST i 76543210 FUNCTION HEX i 00100000 NO OPERATION E20 XX10X001 2 MSEC DELAY 21 XX10X010 4 MSEC DELAY 22 XX10X011 50 MSEC DELAY 23 XX10X100 500 MSEC DELAY C243 XX10X101 1 SEC DELAY C253 XX10X110 2 SEC DELAY C263 XX10X111 5 SEC DELAY 27 i XXlOlXXX INHIBIT OUTPUT 28 X110XXXX END OF HW REPEAT 60 1X10XXXX START OF HW REPEAT CASE 11101000 BREAK OUTPUT OF FEW USEC EE8 11101001 BREAK OUTPUT OF 2 MSEC E9 11101010 BREAK OUTPUT OF 4 MSEC EEA 11101011 BREAK OUTPUT OF 50 MSEC CEB3 i 11101100 BREAK OUTPUT OF 500 MSEC CHECK i 11101101 BREAK OUTPUT OF 1 SEC ED i 11101110 BREAK OUTPUT OF 2 SEC BEEN 11101111 BREAK OUTPUT OF 5 SEC LEFT BIT 5 IS ALWAYS SETBIT 4 IS ALWAYS CLEAREDBITS MAY BE OR D TO ALLOW MULTIPLE REQUESTS EXCEPT FOR BRE CAUTION THE CHARACTER IN THE BUFFER IMMIDIATELY FOLLOWING A BRE BE LOST, UNLESS DELAY BITS ARE SPECIFIED FOR THAT CHARA CONTROL COMES HERE ON WRITE TO ADDRESS 176XX4 IF DATA BITATT11 LDU PUSHDO FETCH OUTPUT BUFFER WRITE POINTERSTA 1,U LET HARDWARE STORE DATA ATTRIBUTES INTO BUFSTA ENDFIP CANCEL SPECIAL HARDWARERTI DONE SBTTL HOST PORT CONTROL INTERRUPT SERVICE ROUTINETHIS ROUTINE IS COMMON FOR ALL FOUR CHANNELS REGISTER U IS RESERVED FOR FIRQ INTERRUPTS AND SELF TEST STPORT CONTROL REQUESTS ARE AS FOLLOWS 76543210 FUNCTION HEX i 00010000 150 BAUD C103 i 00010001 300 BAUD 11 00010010 600 BAUD C123 00010011 1200 BAUD C133 00010100 2400 BAUD C143 00010101 4800 BAUD 15 00010110 9600 BAUD C163 00010111 19200 BAUD 17 00011010 RETURN TERMINAL INPUT STATUS E1A 00011011 VIRTUAL SELF TEST 1B 00011100 DOWNLOAD MODE C1C3 00011101 OPEN LOCATION MODE END i 00011110 SELF TEST MODE E1E 00011111 RESTART 1F 010100X1 RETURN FIRMWARE VERSION NUMBER C513 01010010 RETURN CURRENT BAUD RATE 52 01011XXX RETURN BUFFER EMPTY STATUS E583 100100XX NO OPERATION EXCEPT DONE 90 1001XX1X CLEAR TERMINAL INPUT STATUS 92 1001X1XX KILL INPUT BUFFER 94 1001X11X KILL INPUT BUFFER AND STATUS 96 10011XXX KILL OUTPUT BUFFER 98 I100111XX KILL OUTPUT AND INPUT BUFFERS EACH 1001111X KILL BOTH BUFFERS AND STATUS 9E 11010000 SET NON PRIV. USER STATUS DON i 11010001 SET PRIVILEGED USER STATUS D1 11010010 CLEAR FLAGGED INPUT MODE D2 11010011 SET FLAGGED INPUT MODE D3 110101XX RELOAD HOST INPUT DATA D4 11011000 HOLD MODE, NO COUNTDOWN D8 11011001 HOLD MODE, 2 MSEC COUNTDOWN D9 11011010 HOLD MODE, 4 MSEC COUNTDOWN DA 11011011 HOLD MODE, 50 MSEC COUNTDOWN DB i 11011100 CLEAR HOLD MODE EACH i 11011110 BINARY INPUT MODE DE 11011111 NON BINARY INPUT MODE DF BIT 5 IS ALWAYS CLEAREDBIT 4 IS ALWAYS SET RETURNS EXCEPT FIRMWARE VERSION NUMBER ARE VIA THE UPPER iPORT STATUS REGISTER PSTR .NORMAL INPUT STATUS INFORMATION RETURNED IN HARDWARE PORT S i 76543210 STATUS HEX OCTAL DECIM 00001111 NO ERRORS OF 17 C 15 0XX11111 FRAMING ERROR 1F 37 31 0X1X1111 INPUT OVERRUN 2F 57 47 01XX1111 2 CTRL C S 4F BIT 117 C 79 SET, 7 IS CLEARED BIT 6 SET INDICATES THAT 2 CTRL C S IN SUCCESSION W BIT 5 SET.INDICATES THAT A DATA OVERRUN WAS DETECTE BIT 4 SET, INDICATES THAT A FRAMING ERROR WAS DETECT BITS 3,2,1, AND O ARE ALWAYS SET BITS MAY BE OR D FOR MULTIPLE INDICATION i CAUTION TERMINAL INPUT STATUS IS ONLY VALID IMMEDIATELY OF THE HOST INPUT REGISTER BUFFER EMPTY STATUS INFORMATION RETURNED IN HARDWARE PORT S 76543210 STATUS HEX OCTAL DECIM 100X1111 NONE TRUE 8F 217 143 1XX11111 PRIV USER 9F 257 175 1X1X1111 INPUT EMPTY AF 257 175 i IlXXl1ll OUTPUT EMPTY ECHO 317 207 BIT 7 IS SET BIT 6 SET, INDICATES THAT THE INPUT BUFFER IS EMPTY BIT 5 SET, INDICATES THAT THE OUTPUT BUFFER IS EMPTY BIT 4 SET, INDICATES THAT USER IS PRIVILEGED 1 BITS 3,2,1 AND O ARE ALWAYS SET BITS MAY BE OR D FOR MULTIPLE INDICATION CURRENT BAUD RATE INFORMATION RETURNED IN HARDWARE PORT STA 76543210 RATE HEX OCTAL DECIM 10001111 150 BAUD OFF 217 143 10011111 300 BAUD 9F 237 159 10101111 600 BAUD AF 257 175 10111111 1200 BAUD BF 277 191 11001111 2400 BAUD ECHO 317 207 11011111 4800 BAUD DF 337 223 11101111 9600 BAUD EF 357 239 i 11111111 19200 BAUD OFF 377 255THE FIRMWARE VERSION NUMBER IS RETURNED IN THE HOST INPUT OF THE PORT STATUS REGISTER.THE UPPER 4 BITS OF THE DATAIDENTIFICATION NUMBER IDENT AND THE LOW 4 BITS CONTAINSLEVEL MOD . ANY DATA CURRENTLY RESIDING IN THE HOST INPDOWNLOAD MODE, OPEN MODE1 SELF TEST MODE, RESTART, RETURN T STATUS AND VIRTUAL SELF TEST REQUESTS ARE SERVICED IMMEDIA REQUESTS ARE ONLY QUEUED1 AND ARE SERVICED BY THE MAINLINETHE MOST SIGNIFICANT BIT OF THE CHANNEL S HW PORT STATUS RE UPON COMPLETION OF QUEUED REQUESTS a INTENDED APPLICATION OF THIS ROUTINE FOR QUEUED REQUESTS IS 1 HOST CHECKS THAT MSB OF PORT STATUS IS ZERO i 2 IF NOT ZERO, THEN HOST REQUESTS RETURN TERMINAL I i AND TESTS MSB OF HW PORT STATUS REGISTER UNTIL BI 3 HOST MAKES REQUEST 4 HOST PROGRAM TESTS MSB OF HW PORT STATUS REGISTER i 5 HOST PROGRAM READS PERTINENT STATUS BITS OF REGIS 6 HOST PROGRAM ISSUES A RETURN TERMINAL INPUT STATU 7 HOST PROGRAM TESTS MSB OF HW PORT STATUS REGISTER aBINARY NON BINARY INPUT MODES i BINARY INPUT MODE PASSES ALL S BITS OF INCOMING CHAR i TERMINAL TO HOST. NON BINARY INPUT MODE SUPPORTS XON XOFF TO CONTROL O KILLS THE INPUT BUFFER, AND CTRL C AND CCTRL 0 KII BUFFER iFLAGGED INPUT MODE ALLOWS XONXXOFF CONTROL OF INPUT. WHEN INPUT BUFFER i XOFF IS SENT TO THE TERMINAL TO STOP INPUT. XON IS a SPACE IS MADE AVAILABLE.RELOAD HOST INPUT DATA i THE MOST RECENT CHARACTER LOADED INTO THE HOST INPUT i IN CONJUNCTION WITH HOLD MODE, THIS CAN BE USED TO O AN INPUT CHARACTER IS WAITING. THE SAME CHARACTER B TWICE, CAN BE IGNORED ON THE FIRST READ. THE WAIT F IS THUS REDUCED. i INTENDED APPLICATION 1 THE HOST PROGRAM DISABLES RECEIVER INTERRUPTS 2 THE HOST PROGRAM REQUESTS HOLD MODE 3 THE HOST PROGRAM ENABLES RECEIVER INTERRUPTS 4 THE FIRST CHARACTER RECEIVED IS LOADED INTO THE H REGISTER AND INTERRUPTS THE HOST COMPUTER i 5 THE HOST READS THE CHARACTER. THE FOLLOWING CHA LOADED INTO THE HOST INPUT REGISTER UNTIL THE HOS i IS AGAIN READ1 UNLESS A RELOAD REQUEST IS MADE.i 6 THE HOST MAKES A RELOAD REQUEST. THIS RELOADS TH THOUGH FOR THE FIRST TIME. a NOTE HOLD MODE IS AUTOMATICALLY RESET AFTER READING HOWEVER THE FIRMWARE THINKS THAT THE FIRST CH BE READ, UNLESS A RELOAD IS REQUESTED.HOLD MODE THIS MODE PROVIDES THE CAPABILITY OF BLOCK INPUT REA INTERRUPTING THE HOST COMPUTER FOR EVERY CHARACTER. INPUT BURDEN IS REDUCED. INTENDED APPLICATION 1 THE HOST DISABLES RECEIVER INTERRUPTS i 2 THE HOST REQUESTS HOLD MODE WITH SPECIFIED COUNTD 3 THE HOST ENABLES RECEIVER INTERRUPTS i 4 THE FIRST CHARACTER RECEIVED IS LOADED INTO THE H i REGISTER AND INTERRUPTS THE HOST COMPUTER 5 THE HOST READS THE CHARACTER. THE FOLLOWING CHA a LOADED INTO THE HOST INPUT REGISTER UNTIL THE HOS a IS AGAIN READ BLINDLY THIS TIME . i 6 THE HOST DISABLES RECEIVER INTERRUPTS AND WAITS A a BEFORE DOING THE BLIND READ. THE FIRST CHARACTE i BE AVAILABLE DURING THE BLIND READ. a 7 THE HOST THEN DOES NORMAL READS WITH INTERRUPTS D THE INPUT BUFFER IS EMPTIED NOTE HOLD MODE IS AUTOMATICALLY RESET AFTER READING HOWEVER THE FIRMWARE THINKS THAT THE FIRST CHBE READ. OPTIONALLY, THE FIRST CHARACTER INTERRUPT MAY BE HEL NO INPUT IS RECEIVED FOR UP TO 50 MSEC O a BUFFER FILLS. THIS WOULD ALLOW A STEADY SAY, 2000 CHARACTERS TO BE INPUT BEFORE INTERRUPTED. THIS IS DONE BY SPECIFYING i TIMEOUT VALUE.WARNING USE OF DELAY BITS IN ATTRIBUTE BYTE HOST OUTPUT i CAN CAUSE UNPREDICTABLE EVENTS TO OCCUR SINCE BO a HARDWARE TIMERCONTROL COMES HERE ON WRITE TO ADDRESS 176XX4 IF DATA BIT a IRQ AND FIRQ INTERRUPTS ARE DISABLED FOR THIS ENTIRE ROUT INPORT11 LDU POINTO POINT TO START OF CHANNEL POINTER TABLESTA ENDFIP CANCEL SPECIAL HARDWAREPSHS A MAKE SOME WORKING SPACELDA TBUF a INPUT PORT CONTROLCMPA num 1B PORT CONTROL REQUEST BLO 1 YES, QUEUE ITLBEQ TESTME NO, START VIRTUAL SELF TESTCMPA 1F PORT CONTROL MODE REQUEST BHI 1 YES, QUEUE ITLBEQ START NO, RESTARTCMPA 1C ENTER DOWNLOAD MODE BEQ DOWNLD YES, ENTER DOWNLOAD MODECMPA num 1D OPEN MODE REQUEST LBEQ OPEN YES, ENTER OPEN MODELBRA QUERY MUST BE NORMAL SELF TEST MODE REQUEST 1 STA QUEVEX,U QUEUE REQUESTDONE11 PULS A RESTORE ARTI AND RETURN SBTTL DOWNLOAD MODE SECTIONTHIS SECTION ALLOWS DOWNLOADING AND EXECUTION OF HOST PROGRDIAGNOSTICS MAY BE DOWNLOADED AS CAN SPECIAL APPLICATION PRLOCATIONS 0000 03F0 ARE AVAILABLE AS DOWNLOAD RUNABLE SPACE iIN ADDITION, BUFFER MEMORY LOCATIONS 8000 BFFF MAY BE USED TABLE AREA NON RUNABLE DUE TO REFRESH MEMORY RESTRICTIONS PROGRAMS STARTING AT ENDRAM OR HIGHER WILL NOT DISTURB POOR OPEN LOCATION MODE STORAGE LOCATIONS.i INPUTX AND OUTPTX ENTRIES IN POINTER TABLE MAY BE USEDPROGRAM TO INTERCEPT TERMINAL I O INTERRUPTS DOWNLOAD FORMAT IS DEC PDP ll .LDA FORMATTHE DATA IS EXPECTED TO BE IN THE LOW 4 BITS OF THE PORT COOF THE CHANNEL WHICH INITIATED THE DOWNLOAD. IT TAKES TWOBYTES TO RECONSTRUCT THE 8 BIT .LDA DATA BYTE. THE FIRST PCONTAINS THE LOW 4 BITS OF THE .LDA DATA BYTE, AND THE SECOBYTE CONTAINS THE HIGH 4 BITS OF THE .LDA DATA BYTE.PORT CONTROL BIT VALUES ARE AS FOLLOWS BIT 7 SET1 INDICATES THAT DATA NIBBLE IS HIGH 4 BITS BIT 6 SET, INDICATES THAT DATA NIBBLE IS LOW 4 BITS BIT 5 IS ALWAYS CLEARED BIT 4 IS ALWAYS SET BITS 3 0 CONTAIN DATA NIBBLE IN ADDITION1 THE FOLLOWING PORT CONTROL COMMANDS ARE STILL 76543210 FUNCTION HEX OCTA 00011011 VIRTUAL SELF TEST 1B 033 i 00011100 DOWNLOAD MODE EACH 034 i 00011101 OPEN LOCATION MODE 1D 035 00011110 SELF TEST MODE 1E 036 00011111 RESTART 1F 037WHEN A PORT CONTROL BYTE IS WRITTEN THE PORT STATUS REGISTAFTER THE BYTE HAS BEEN PROCESSED, BIT 7 OF THE PORT STATUS SET AND BITS 6 4 CONTAIN SUCCESS FAIL INDICATION.THE HOSTREAD AND DECODE THE SUCCESS FAIL INDICATION PRIOR TO WRITINCONTROL BYTE. SUCCESS FAIL STATUS IS AS FOLLOWS 76543210 INDICATION HEX OCTA 00001111 DATA BEING PROCESSED OF 17 10001111 VALID DATA 8F 217 10011111 SUCCESSFUL DOWNLOAD 9F 237 11001111 BAD CHECKSUM ECHO 317 11011111 BAD DATA NIBBLE DF 337 11101111 DATA TIMEOUT LEFT 357 11111111 BAD .LDA FORMAT OFF 377NO RETURN IS MADE IF AN ERROR OCCURS FIRQ INTERRUPTS ARE ETHE SUCCESSFULLY DOWNLOADED PROGRAM IS AUTOMATICALLY STARTETHE ADDRESS AT WHICH IT IS STARTED IS DETERMINED BY ADDRESSTHE .END NNNN STATEMENT AT THE END OF THE SOURCE CODE.FOR EXAMPLE, IF START IS THE LABEL THAT INDICATES THE STA i OF THE PROGRAMS THEN THE PROGRAM SHOULD END WI LDA FORMAT i 1ST BYTE OF EACH BLOCK 01 2ND BYTE 00 3RD BYTE BLOCK BYTECOUNT 4TH BYTE 00 5TH BYTE LOW BITS LOADING ADDRESS 6TH BYTE HIGH BITS LOADING ADDRESS 7TH THROUGH BYTECOUNT 6 DATA LAST BYTE CHECKSUM NEGATED SUM OF ALL BYTES IF BYTECOUNT 6 THEN NO MORE BLOCKS WILL i FOLLOW, AND LOADING ADDRESS BECOMES STARTING ADDRESSDOWNLD LDS num STACK a ZERO STACKANDCC CFMASK ENABLE FIRQ INTERRUPTS 1 BSR WAITS FETCH INPUTBEQ 1 a IGNORE NULLS BETWEEN BLOCKSCMPA num SOH a IS START OF BLOCK BNE BADF NO, BAD FORMAT ERRORLDY num 0000 a INITIALIZE CHECKSUM TO ZEROBSR WAITS FETCH NEXT BYTEBNE BADF IF NOT ZEROS THEN BAD FORMATBSR WAITS FETCH BYTECOUNTPSHS A SAVE FOR LAST BLOCK CHECKTFR A,B MOVE TO BSUBB num 5 SUBTRACT HEADER BYTECOUNT BUT NOT CHECKSUMPSHS B SAVE AS DATA BYTECOUNTBSR WAITS iFETCH NEXT BYTEBNE BADF IF NOT ZERO, THEN BAD FORMATBSR WAITS GET LOW BYTE OF STARTING ADDRESSTFR A,B iTEMP SAVE BSR WAIT8 GET HIGH BYTE OF STARTING ADDRESSTFR D,X MOVE STARTING ADDRESS TO XPULS B RESTORE DATA BYTECOUNT 2 BSR WAITS FETCH DATA BYTEDEC B END OF THIS BLOCK BEQ 39 YES, CHECK CHECKSUMSTA ,X NO, STORE ITLDA ,X AND READ BACK TO CHECK ITBRA 2 QET REST OF BLOCK 3 LEAY AxY TEST CHECKSUMTFR Y1 D TSTB LOW BYTE SHOULD BE 00BNE BADC BAD CHECKSUMPULS A RESTORE INITIAL BYTECOUNTCMPA num 6 WAS 6 BNE 19 aNO, READY FOR NEXT BLOCKLDA 90 a INDICATE SUCCESSFUL DOWNLOADBRA REPLY AND WRITE TO PORT STATUS REGISTERBADF LDA num OFO LOAD ERROR TYPE FOR BAD FORMATBRA LDAERR AND WRITE TO HOST INPUT REGISTERBADC LDA num OCO LOAD ERROR TYPE FOR BAD CHECKSUMLDAERR LDX num HALT LOAD JUMP ADDRESS FOR FATAL ERRORREPLY STA PSTATX,U SEND RESULTS TO PORT STATUS REGISTERHALT JMP ,X JUMP TO START OF NEWLY LOADED PROGRAMROUTINE TO GET INPUT FOR DOWNLOAD CHECKSUM IN REGISTER Y IS UPDATEDREGISTER A CONTAINS PREVIOUSLY RECEIVED BYTEREGISTER A WILL CONTAIN NEW INPUT a IF NO INPUT IS RECEIVED WITHIN APPROX. 10 SECONDS, A TIMEOU NO OTHER REGISTERS ARE AFFECTEDWAITS LEAY AnY ADD PREVIOUS BYTE TO CHECKSUMPSHS X, Y, B TEMP SAVE X, Y, AND B 1 CLR QUEUEX,U CLEAR FUTURE DATA BYTELDA num 80 iINDICATE READY FOR NEXT DOWNLOAD BYTESTA PSTATX,U LDA num OA iPRESET MAX. COUNT FOR TIMEOUTLDX num 0000 CLEAR X FOR TIMEOUT 2 LDB QUEUEX U ANY HOST INPUT BNE 3 a YES, PROCESSLEAX 1,X NO, INNER LOOP TIMEOUT 1. 12 SEC. BNE 2 NO, CONTINUEDEC A YES, MAX.TIMEOUT BNE 2 NO, CONTINUELDA OEO LOAD TIMEOUT EXPIRATION ERRORBRA LDAERR AND DISPLAY ERROR INDICATION 3 BMI 6 iHIGH NIBBLE1 GO ONBITB num 40 CORRECT LOW NIBBLE INDICATION BNE 5 YES, PROCESS 4 LDA 0B0 NO, INDICATE ERRORBRA LDAERR 5 ANDB num OF MASK OFF ALL BUT DATA NIBBLETFR D,Y a AND SAVE FOR LATERBRA 1 READY FOR HIGH NIBBLE 6 BITB num 40 CORRECT HIGH NIBBLE INDICATION BNE 4 NO,ERRORASLB MOVE DATA NIBBLE TO UPPER BITSASLBASLBASLBLEAY B,Y AND ADD TO LOW NIBBLETFR Y,D MOVE TO ATFR B,APULS B,Y,X RESTORE B,Y, AND XTSTA CONDITION CODES SHOULD REFLECT DATARTS RETURN SBTTL OPEN LOCATION MODE SECTIONTHIS SECTION ALLOWS MEMORY LOCATIONS TO BE OPENED FOR EXAMIAND DEPOSIT OF NEW CONTENTSSLASH WITH A VALID ADDRESS PRECEDING, OPENS THAT LOCASLASH ONLY, OPENS THE CURRENT LOCATIONRETURN CLOSES THE CURRENT LOCATION 1LINEFEED CLOSES THE CURRENT LOCATION AND OPENS THE NEXT UP ARROW t CLOSES THE CURRENT LOCATION AND OPENS PREVIO . G LOADS THE PROGRAM COUNTER WITH THE CURRENT ADDRESS AND iIRQ AND FIRQ INTERRUPT MONITORING IS DISABLED THROUGHOUT THESCAPE OR CTRL C EXIT OPEN LOCATION MODE START AND MAINLINE OF THE OPEN MODE SECTIONOPEN PSHS B,X INCREASE WORKING SPACELDX num 0000 DEFAULT TO ADDRESS ONEWLOC CLR OPEBUF CLEAR INPUT ADDRESS BUFFERCLR OPEBUF 1 CLR OPEFLG CLEAR LOCATION OPEN FLAG CLR OPEPNT CLEAR OFFSET LOCATIONLBSR CRLF PRINT CR LFFETCH LBSR GETC GET INPUT FROM TERMINALCMPB num ESC a IS INPUT AN ESCAPE BEG WINDUP YESss EXIT OPEN MODECMPB num ETX NO, IS INPUT A CTRL C BEG WINDUP iYESw EXIT OPEN MODECMPB num CR NO, IS INPUT A RETURN BEQ OPERET YES, TAKE CARE OF ITCMPB num LF NO, IS INPUT A LINEFEED BEG OPELF YES, TAKE CARE OF ITCMPB num ssNO IS INPUT AN UP ARROW LBEQ ARROW YES, TAKE CARE OF ITCMPB SPACE NO, IS LESS THAN A SPACE BLO FETCH YES, IGNORE ITLBSR PUTC NO, ECHO ITCMPB num IS, INPUT A SLASH LBEQ SLASH YES, TAKE CARE OF ITCMPB num G NO, IS A G LBEQ GOMAN YES, PROCEED TO EXECUTION MODESUBB num 30 NO, IS LESS THAN O LBLO OPERR aYES, ERRORCMPB num 9 IS, BETWEEN O AND 9 BLS 1 YES, GOOD DIGITSUBB num 11 NO, IS LESS THAN A LBLO OPERR a YES, ERRORCMPB num 5 NO, IS BETWEEN A AND F LBHI OPERR NO, ERRORADDB num OA YES.MAKE INTO A HEX NUMBER 1 LDA OPEPNT FETCH INPUT POINTER OFFSETTST OPEFLG IS LOCATION OPEN BNE 2 YES, MUST BE DATACMPA num 4 NO, ADDRESS BUFFER OVERFLOW LBEQ OPERR YES, ERRORPSHS X NO, SAVE CONTENTS OF XLDX ZOPEBUF POINT TO START OF ADDRESS BUFFERBRA PACK AND STORE INPUT 2 CMPA num 6 DATA BUFFER OVERFLOW LBEQ OPERR YES, ERRORPSHS X NO, SAVE CONTENTS OF XLDX num OPEDAT 1 POINT TO START OF DATA BUFFER 1CMPA num 4 iIS THIS THE FIRST DIGIT OF DATA BNE PACK NO, GO ONCLR OPEDAT YES, ZERO DATA IN CASE ONLY 1 DIGITPACK LDA num 4 i4 SHIFTS TO DO 1 ASL 1,X SHIFT LOW ORDER BYTE LEFTROL ,X MOVE ANY OVERFLOW INTO HIGH ORDER BYTEDECA DONE SHIFTING BNE 1 NOORB 1,X iOR IN LATEST NUMBER FROM KEYBOARDSTB XX1 X AND STORE INTO LOW ORDER BYTEPULS X RESTORE XINC OPEPNT INCREMENT INPUT POINTER OFFSETBRA FETCH READY FOR MORE INPUTWINDUP LBSR CRLF SEND FINAL CR LFPULS X.B RESTORE X AND B LBRA DONEll ALL DONE, RETURN TO NORMAL SECTION TO HANDLE CARRIAGE RETURN FOR OPEN MODECARRIAGE RETURN WRITES OUT THE CURRENT DATA AND CLOSES LOCA OPERET LBSR CLOSE iCLOSE LOCATION1 IF OPENLBRA NEWLOC iDONE iSECTION TO HANDLE LINEFEED FOR OPEN MODE LINEFEED WRITES OUT THE CURRENT DATA, CLOSES THE CURRENT LOAND OPENS THE NEXT LOCATIONOPELF LBSR CLOSE CLOSE CURRENT LOCATION, IF OPENLEAX 1,X INCREMENT ADDRESS COUNTEROPELOC CLR OPEFLG a INDICATE LOCATION NOT YET OPENLBSR CRLF PRINT CR LFTFR X1D FETCH NEW ADDRESSPSHS B SAVE B FOR LATERLBSR UNPACK PRINT LEADING 2 DIGITSPULS A RESTORE LOWER 2 DIGITSLBSR UNPACK AND PRINTLDB num LOAD A SLASHBSR PUTC AND PRINTLDB SPACE LOAD A SPACEBSR PUTC AND PRINT AND REFRESH BUFFER MEMORYLDA a X a FETCH CURRENT DATASTA OPEDAT STORE IN POINTER TABLEBSR UNPACK AND PRINTLDB SPACE LOAD ANOTHER SPACEBSR PUTC AND PRINTLDB num 4 LOAD OFFSET POINTER FOR READING DATASTB OPEPNTSTB OPEFLG a INDICATE THAT LOCATION IS OPENLBRA FETCH DONE, GET NEXT INPUT SECTION TO HANDLE UP ARROW FOR OPEN MODE aUP ARROW WRITES OUT THE CURRENT DATA, CLOSES THE CURRENT LOAND OPENS THE PREVIOUS LOCATIONARROW LBSR CLOSE CLOSE CURRENT LOCATION IF OPENLEAX 1,X DECREMENT ADDRESS COUNTERBRA OPELOC AND OPEN NEW LOCATION SECTION TO HANDLE SLASH FOR OPEN MODESLASH OPENS THE CURRENT LOCATION 1F THE LOCATION IS ALREADY OPEN, IT IS CLOSED FIRSTSLASH TST OPEFLG a IS LOCATION OPEN BEG 1 NO, GO ONBSR CLOSE , YES.CLOSEBRA 2 AND REOPEN LOCATION 1 LDA OPEPNT FETCH INPUT OFFSETBEQ 2 , NO CHANGE IN ADDRESS, SO OPEN AS ISLDX OPEBUF a LOAD NEW ADDRESS 2 BRA OPELOC OPEN LOCATIONSECTION TO START EXECUTION FROM CURRENT ADDRESSSTACK IS ZEROED AND FIRQ INTERRUPTS ARE ENABLED PRIOR TO EXGOMAN TST OPEFLG a IS LOCATION OPEN BNE OPERR , YES, NOT ALLOWED LDB num NUL PRINT EXTRA CHAR TO FLUSH OUTPUT BUFFERBSR PUTC , SC THAT G IS ECHOEDBSR PUTC , OUTPUT IS DOUBLE BUFFERED LDS num STACK a ZERO STACK TO REDUCE CHANCE OF STACK OVERFLTST OPEPNT , UBE CONTENTS OF X AS STARTING ADDRESS BEQ 1S , NO CHANGE IN ADDRESS, SO USE XLDX OPEBUF LOAD NEW STARTING ADDRESS 1 ANDCC CFMASK aRE ENABLE FIRQ INTERRUPTSJMP 1X START EXECUTIONSECTION TO HANDLE INVALID INPUT FROM TERMINAL aA IS PRINTED AND THE CURRENT ADDRESS AND DATA IS IGNORE a IF A LOCATION IS ALREADY OPEN IT IS CLOSED AND REOPENEDOPERR LDB LOAD A BSR PUTC AND PRINTTST OPEFLG IS LOCATION OPEN BNE OPELOC , YES, REOPENLBRA NEWLOC , NO, IGNORE COMMANDROUTINE TO GET INPUT FROM TERMINAL FOR OPEN MODEREGISTER U POINTS TO THE RELEVANT POINTER TABLEREGISTER B WILL CONTAIN THE INPUT CHARACTER ON RETURN GETC LDB C TTGSRX, UJ FETCH ACIA STATUSBITB 1 , INPUT BEQ GETC , NO, NOT YETLDE TPORTX, U , YES. READ CHARACTERANDB num 7F MASK OFF BIT 8RTS ROUTINE TO OUTPUT TO TERMINAL FOR OPEN MODEREGISTER U POINTS TO THE RELEVANT POINTER TABLE REGISTER B CONTAINS THE CHARACTER TO BE OUTPUTPUTC PSHS B a TEMP SAVE CHARACTER TO BE OUTPUT 1 LDB TTCSRX, U FETCH ACIA STATUSBITB num 2 , OK TO OUTPUT BEG 1 , NO, CHECK AGAINPULS B ,YES.RESTORE OUTPUT CHARSTB TPORTX, U3 AND OUTPUTRTSROUTINE TO PRINT CARRIAGE RETURN LINEFEED FOR OPEN MODETHE CONTENTS OF REGISTER B IS DESTROYEDCRLF LDB num CR LOAD CARRIAGE RETURNBSR PUTC AND OUTPUTLDB num LF LOAD LINEFEEDBSR PUTC AND OUTPUTRTSROUTINE TO OUTPUT CONTENTS OF REGISTER A AS TWO HEX DIGITSTHE CONTENTS OF REGISTER B IS DESTROYEDFOR OPEN LOCATION MODEUNPACK TFR A, B DUPLICATELSRB SHIFT TO GET FIRST DIGITLSRBLSRBLSRBADDB num 10 MAKE INTO A NUMBERCMPB 9 IS GREATER THAN 9 BLS 1 , NO.LEAVE AS ISADDB num A 9 1 YESw MAKE INTO A LETTER A F 1 BSR PUTC AND PRINTTFR A, B NOW FOR SECOND DIGITANDB num OF MASK OFF UPPER BITSADDB num O MAKE INTO A NUMBERCMPB num 9 , IS GREATER THAN 9 BLS 29 aNO, LEAVE AS ISADDB num A 9 1 , YES MAKE INTO A LETTER A F 29 BSR PUTC AND PRINTRTS a DONE ROUTINE TO CLOSE CURRENT LOCATION IF OPEN , DATA IS NOT WRITTEN IF NO NEW DATA WAS SPECIFIED iREGISTERS A AND B ARE USED AS SCRATCH CLOSE TST OPEFLG , IS LOCATION OPEN BEG 1 NO.RETURNLDA OPEDAT , QET ANY NEW DATALDB OPEPNT a IS THERE ANY NEW DATA CMPB num 4BLS 1 , NO. SKIP ITSTA , X , YES. WRITE NEW DATA 1 RTS RETURN SBTTL SELF TEST SECTIONSELF TEST MAY BE USER INITIATED OR HOST INITIATED.USER INITIATED SELF TEST IS VIA NMI NONmMASKABLE INTERRUPTSELF TEST REQUEST BY HOST.HOST INITIATED SELF TEST IS VIA PORT CONTROL ADDRESS 176XX A COMPLETE SELF TEST REQUIRES HOST ASSISTANCE. HOWEVER, MA BE CHECKED OUT WITHOUT AID OF A HOST SUCH AS ROM INTEGRITSBTTL HOST ASSISTED SECTION IT TAKES 4 COMPLETE PASSES OF THE MAINLINE IN ORDER TO SERV ONE PASS PER CHANNEL NORMAL FIRQ INTERRUPT ROUTINES ARE USED IRQ INTERRUPTS ARE NOT ENABLEDSPECIAL HOST CONTROL COMMANDS ARE STORED IN THE QUEUE ENT POINTER TABLE AND ARE AS FOLLOWS BIT 7 SET, INITIATES UNAIDED SELF TEST ROM, RAM, I BIT 6 IS ALWAYS SET BIT 5 IS ALWAYS CLEARED BIT 4 IS ALWAYS SET BIT 3 SET, ZEROES CHANNEL BUFFERS AND SPECIAL FLAGS BIT 2 SET, ENABLES ECHO BACK BIT 1 SET, DISABLES ECHO BACK i BIT O SET, SHIFTS BIT ONE POSITIONS LEFT IN UPPER 4 a REGISTER.MULTIPLE REQUESTS MAY BE PROCESSED IN ABOVE ORDER IN ONE WRITE. ALONG AS BIT 7 IS CLEARED.UNAIDED SELF TEST MAY ALSO BE STARTED VIA HOST REQUEST, BUT REQUEST VIRTUAL SELF TEST . COMMAND SUMMARY i 76543210 FUNCTION HEX OCTA 0101XXX1 SHIFT PORT STATUS BIT L51 121 0101XX1X DISABLE ECHO BACK 52 122 0101X10X ENABLE ECHO BACK 54 124 01011XX0 CLEAR TRANSMIT COUNTER C583 130 01011XX1 ZERO BUFFERS AND FLAGS C593 131 1101XXXX UNAIDED SELF TEST CD03 320 IN ADDITION, THE FOLLOWING PORT CONTROL COMMANDS ARE STILL 76543210 FUNCTION HEX OCTA 00011011 VIRTUAL SELF TEST 1B 033 00011100 DOWNLOAD MODE EACH 034 00011101 OPEN LOCATION MODE C1D3 035 00011110 SELF TEST MODE 1E 036 00011111 RESTART ElF3 037 IF ECHO BACK IS ENABLED, THE FOLLOWING IS TRUE i 1 THE LOWER FOUR BITS OF ANY ATTRIBUTE BYTE WILL BE FOUR BITS OF THE HARDWARE STATUS REGISTER OF THE 2 IF THE INPUT BUFFER CONTAINS ANY CHARACTERS STOR DISABLE , THEN THESE ARE AVAILABLE FOR READING UN OR A HOST DATA OUTPUT OCCURS. EACH CHARACTER MUS THE NEXT ONE IS MADE AVAILABLE. 3 EACH CHARACTER OUTPUT BY THE HOST IS COPIED TO TH i RBUF WITHOUT REGARD TO THE CURRENT DATA READY 4 THE TRANSMIT COUNTER HWCLR IS CLEARED AFTER E IF ECHO BACK IS DISABLED THE FOLLOWING IS TRUE 1 EACH CHARACTER OUTPUT BY THE HOST IS STORED IN TH 2 THE UPPER BYTE OF THE OUTPUT BUFFER WRITE POINTER CHANNEL O HOST INPUT REGISTER RBUFO FOLLOWING 3 THE LOWER BYTE OF THE OUTPUT BUFFER WRITE POINTER CHANNEL 1 HOST INPUT REGISTER RBUF1 FOLLOWING 4 THE UPPER BYTE OF THE INPUT BUFFER WRITE POINTER i CHANNEL 2 HOST INPUT REGISTER RBUF2 FOLLOWING i 5 THE LOWER BYTE OF THE INPUT BUFFER WRITE POINTER a CHANNEL 3 HOST INPUT REGISTER RBUF3 FOLLOWING 6 THE TRANSMIT COUNTER HWCLR IS NEVER CLEARED.QUERY LDS num STACK a ZERO STACKLBSR INIT a INITIALIZE POINTER TABLESHOSTED STA PICON DUMMY WRITE TO ENABLE PROGRAMMABLE INTERRUPLDX num STAT3 PRESET CHANNEL POINTER TABLE POINTERADJUST TFR X,D iMOVE CHANNEL TABLE POINTER TO ACADDB num 40 AND POINT TO NEXT CHANNEL TO BE SERVICEDTFR D, X a RETURN VALUE TO XLOCKON ANDCC num CFMASK ENABLE FIRQ INTERRUPT MONITORINGLDA QUEUEX, X LOAD LATEST PORT CONTROL REQUESTBEQ ECOBAK NOTHING, CHECK ON ECHO BACK NO ECHO BACKORCC num FMASK DISABLE INTERRUPT MONITORINGBPL 1 NOT UNAIDED SELF TEST REQUEST, GO ONLDU num 4080 a INDICATE ROM TEST AND HOST INITIATEDLBRA GUIDE START UNAIDED SELF TEST 1 CLR QUEUEX, X CLEAR REQUESTANDA num OF iONLY LOOK AT LOW 4 BITSBITA num 8 ZERO BUFFERS AND SPECIAL FLAGS OR TRANSMITBEG 2 NO, GO ONSTA TTCLRX, X RESET TRANSMIT COUNTERBITA num 1 CLEAR ONLY TRANSMIT COUNTER BEQ LOCKON YES, CHECK FOR MORE ACTION ON THIS CHANNEL LDD OBOTX,X LOAD POINTER TO START OF OUTPUT BUFFERSTD PUSHOX, X iAND STORE AS NEW OUTPUT BUFFER WRITE POINTESTD POPOX, X AND SAVE AS NEW OUTPUT BUFFER READ POINTERSTD RBUFO iAND COPY TO CHANNEL O AND 1 HOST INPUT REGIANDA num C8 CONVERT TO START OF INPUT BUFFER POINTERSTD XXPUSHIX,X AND STORE AS NEW INPUT BUFFER WRITE POINTERSTD POPIX, X AND STORE AS NEW INPUT BUFFER READ POINTERSTD RBUF2 AND COPY TO CHANNEL 2 AND 3 HOST INPUT REGILBSR CLRATT CLEAR ALL ATTRIBUTE BYTES IN OUTPUT BUFFERCLR INFLGX, X CLEAR INPUT WAITING FOR HOST FLAGCLR ECHOX, X CLEAR ECHO BACK INDICATIONBRA NEWBIT iINITIALIZE ROTATING STATUS 2 BITA num 4 AMENABLE ECHO BACK BEQ 3 , NO, GO ONLDA num 80 , YES MARKSTA ECHOX, X 3 BITA num 2 DISABLE ECHO BACK BEQ 4 , NO, GO ONANDA CBO iCLEAR ANY ECHO BACK ENABLE INDICATIONSTA ECHOX, X , MARK 4 BITA num 1 ROTATING STATUS REQUES BEQ LOCKON , NO.CHECK FOR MORE ACTIONROTATE ASL SHIFTX,X iSHIFT CURRENT ROTATING STATUSLDA SHIFTX, X AND FETCHBCC OLDBIT , OK AS IS NEWB IT LDA num 8 , RE INITIALIZE ROTATING STATUSSTA XSHIFTX8X AND SAVE FOR NEXT TIMEOLDBIT STA PSTATX, X COPY UPPER 4 BITS TO PORT STATUS REGISTERBRA LOCKON CHECK FOR MORE ACTION ON THIS CHANNELECOBAK TST ECHOX, X iIS ECHO BACK ENABLED OR DISABLED BEQ ADJUST , NEITHER, TRY NEXT CHANNELBPL QUIET DISABLED GO ONLDY POPOX, X LOAD OUTPUT BUFFER READ POINTERLDA 1, Y , HAS ATTRIBUTE BYTE BEEN WRITTEN BEQ 1 aNO, CHECK FOR INPUTASLA YES.MOVE LOW 4 BITS TO UPPER 4 BITSASLAASLAASLASTA PSTATX, X a AND WRITE TO HARDWARE PORT STATUS REGISTERCLRA CLEAR ATTRIBUTE BYTESTA 1, Y CLR INSTRUCTION IS NOT ALLOWED BRA LOCKON CHECK FOR MORE ACTION ON THIS CHANNEL 1 TST INFLGX, X IS INPUT ALREADY WAITING FOR HOST BNE 2 a YES, GO ONLDY X POPIX9X LOAD INPUT BUFFER READ POINTERCMPY PUSHIX, X IS INPUT SUFFER EMPTY BEG 2 YES, GO ONLDA ,Ys FETCH NEXT INPUT CHARACTERINC INFLGX, X SET INPUT WAITING FOR HOST FLAGSTA HRBUFX, X AND COPY CHARACTER TO HARDWARE REGISTERTFR Y,D MOVE READ POINTER TO ACANDA num C8 TAKE CARE OF ANY WRAP AROUNDSTD POPIX, X SAVE NEW POINTERLBRA LOCKON CHECK FOR MORE ACTION ON THIS CHANNEL 2 LDY POPOX, X LOAD OUTPUT BUFFER READ POINTERCMPY PUSHOX, X IS OUTPUT BUFFER EMPTY LBEQ ADJUST YES, CHECK NEXT CHANNELLDA sY FETCH OUTPUT CHARACTERSTA HRBUFX, X COPY IMMEDIATELY TO HARDWARE RECEIVER REGISTFR Y,D MOVE POINTER TO AC FOR UPDATINGANDA num C8 MAKE ROOM FOR ANY OVERFLOWADDD num 2 2 BYTES PER OUTPUTORA num 8 RESTORE BUFFER ADDRESS BITSTD POPOX, X iSTORE NEW OUTPUT BUFFER READ POINTERSTA TTCLRX, X RESET TRANSMIT COUNTERLDY XXPUSHIX,X KILL INPUT BUFFERSTY POPIX, XCLR INFLGX, X CLEAR INPUT WAITING FOR HOST FLAGLBRA LOCKON CHECK FOR MORE ACTION ON THIS CHANNELQUIET LDY POPOX, X LOAD OUTPUT BUFFER READ POINTERCMPY PUSHOX, X IS OUTPUT BUFFER EMPTY LBEQ ADJUST YES, CHECK NEXT CHANNELLDA , Y iFETCH OUTPUT CHARACTERPSHS A TEMP SAVETFR Y,D MOVE POINTER TO AC FOR UPDATINGANDA num C8 MAKE ROOM FOR ANY OVERFLOWADDD num 2 2 BYTES PER OUTPUTORA num 8 RESTORE BUFFER ADDRESS BITSTD POPOX, X STORE NEW OUTPUT POINTERLDY PUSHIX, X iLOAD INPUT BUFFER WRITE POINTERPULS A iRESTORE OUTPUT CHARACTERSTA wY iAND STORE IN INPUT BUFFERTFR Y, D MOVE POINTER TO ACANDA num C8 iCLEAR ANY OVERFLOWSTD PUSHIX, X SAVE NEW POINTERSTY RBUF2 iAND COPY TO CHANNEL 2 AND 3 HOST INPUT REGILDY PUSHOX, X LOAD OUTPUT BUFFER WRITE POINTERSTY RBUFO iAND COPY TO CHANNEL O AND 1 HOST INPUT REGILBRA LOCKON iCHECK FOR MORE ACTION ON THIS CHANNEL SBTTL UNAIDED SELF TEST SECTION TEST MESSAGES AND ERRORS ARE PRINTED THROUGH CHANNEL O TERM AT 2400 BAUD IF THE SELF TEST WAS USER INITIATED.iTHE RAM AND ROM TESTS ARE WRITTEN SUCH THAT NO SCRATCH RAM a IS REQUIRED. THIS MAKES THE TEST RESULTS SOMEWHAT RELIABLE iTHE RAM UNDER TEST IS NOT USED IN THE TESTING AND REPORTING REGISTER U IS USED FOR SELF TEST STATUS AS FOLLOWS BIT 15 SET, INDICATES THAT UNAIDED SELF TEST IS FINI BIT 14 SET, INDICATES THAT A ROM ERROR OCCURRED OR BIT 13 SET, INDICATES THAT A RAM ERROR OCCURRED OR BIT 12 SET, INDICATES THAT AN I O ERROR OCCURRED OR BIT 7 SET, INDICATES THAT SELF TEST WAS HOST INITIA OR VIRTUAL SELF TEST REQUEST VIA HOST BIT 3 SET, INDICATES THAT A CHANNEL 3 I O ERROR OCC BIT 2 SET, INDICATES THAT A CHANNEL 2 ISO ERROR OCC BIT 1 SET, INDICATES THAT A CHANNEL 1 ISO ERROR OCC BIT O SET, INDICATES THAT A CHANNEL O I O ERROR OCCAS EACH TEST IS ENTERED, THE CORRESPONDING TEST IN PROGRESS IT IS CLEARED AT THE END OF THE TEST1 PROVIDING THAT NO ERR IN ADDITION, THE RAM TEST USES THE FOLLOWING REGISTER U BIT BITS 11, 10, 91 AND 8 ARE USED FOR TEMPORARY RAM TES BIT 6 SET INDICATES THAT STOP ON ERROR IS IN EFFEC BIT 5 SET, INDICATES THAT LOOP MODE IS IN EFFECTTHE GLOBAL STATUS BITS 12 15 ARE COPIED INTO THE CHANNEL OAT THE BEGINNING OF EACH UNAIDED TEST AND UPON COMPLETION O OF SELF TEST.THE TERMINAL ISO TEST STATUS BITS 0 3 ARE COPIED INTO THE CREGISTER PSTRl UPON COMPLETION OF THE UNAIDED PORTION O ENTRY POINT FOR USER INITIATED SELF TEST SWI3 OR NMI INTERTESTME ORCC num IFMASK MAKE SURE THAT INTERRUPT MONITORING IS DISALDU num 4000 a INDICATE ROM TEST, USER INITIATED SELF TESTLDA num 1 POINT TO CHANNEL O PTM CONTROL REGISTERSTA CLOCKO 1LDA num SHOT iLOAD PTM CONTROL FOR BAUD GENERATIONSTA CLOCKO 2 WRITE BAUD CLOCK GENERATION CONTROLLDX DEFALT FETCH DEFAULT BAUD RATE CONSTANT 2400 STX CLOCKO AND WRITE TO TIMER LATCHESLDA num MRESET RESET CHANNEL O ACIASTA ACIAOLDA num TXROFF SET ACIA PARAMETERS NO INTERRUPTSSTA ACIAOSECTION TO CONTROL SELF TESTGUIDE STA PICOFF DUMMY WRITE TO DISABLE PROGRAMMABLE INTERRUTFR UwD FETCH CURRENT STATUS BITSSTA PSTRO AND COPY TO CHANNEL O HW REGISTERCLR PSTRI a INDICATE NO I O ERRORSLDY num MESG1 POINT TO START OF INITIAL MESSAGELDS num TEST1 LOAD RETURN ADDRESSLBRA WRITEM WRITE MESSAGETEST1 LDS TEST2A a LOAD RETURN ADDRESS FOR ROM TESTLBRA ROMTST AND TEST ROMTEST2A TFR U1 D a FETCH CURRENT SELF TEST STATUS EORA num 60 REFLECT ACTUAL ROM TEST ERROR STATUS AND ENTFR D, U A RESTORE USTA PSTRO COPY CURRENT STATUS TO CHANNEL O HW REGISTELDY num MESG2A POINT TO RAM MESSAGELOOPT2 LDS num MPART2 LOAD RETURN ADDRESSLBRA WRITEM AND PRINT FIRST PART OF MESSAGEMPART2 LDY num MESG2B POINT TO 0000 03FF MESSAGELDX num 0000 iPOINT TO START OF SCRATCH RAMLDS num RAMTST iLOAD RETURN ADDRESSLBRA WRITEM WRITE MESSAGE AND TEST SCRATCH RAMTEST2B LDY num MESG3 POINT TO E8000 BFFF MESSAGELDX num 8000 iPOINT TO START OF SCRATCH RAMLDS num RAMTST a LOAD RETURN ADDRESSLBRA WRITEM WRITE MESSAGE AND TEST BUFFER MEMORYEND2 TFR U, D FETCH CONTENTS OF UBITB num 60 a IS LOOP MODE IN EFFECT BEQ TEST3 , NO, GO ON TO NEXT TESTLDY num MESG4 iPOINT TO LOOPING... MESSAGEBRA LOOPT2 LOOPTEST3 LDS num STACK a INITIALIZE STACK POINTERTFR U, D FETCH CURRENT SELF TEST STATUSEORA num 30 REFLECT ACTUAL RAM TEST ERROR STATUS AND ENTFR D,U RESTORE UTSTB WAS SELF TEST HOST INITIATED BPL 1 , NO, GO ONBITA num 60 , YES, ANY RAM OR ROM ERRORS BNE FINISH , YES.DON T TRUST MEMORY END SELF TEST 1 STA PSTRO iCOPY CURRENT SELF TEST STATUS TO CHANNEL OLDY num MESG6 POINT TO TERMINAL I O MESSAGELBSR PRINTM PRINTLBSR IOTEST iAND TEST TERMINAL I OFINISH LDY num MESQ99 iPOINT TO START OF TEST COMPLETE MESSAGELBSR PRINTM AND PRINTLBSR INIT iINITIALIZE POINTER TABLESTFR U,D FETCH LATEST STATUSEORA num 90 REFLECT ACTUAL I O TEST ERROR AND SELF TESTSTA PSTRO AND MOVE TO CHANNEL O HW PORT STATUS REGISTASLB MOVE I O TEST ERROR STATUS TO UPPER BITSASLBASLBASLBSTB PSTR1 aAND COPY TO CHANNEL 1 HW REGISTERTFR U,D iFETCH STATUS AGAINTSTB , WAS SELF TEST HOST INITIATED LBMI HOSTED YES, RETURN TO HOST INITIATED SELF TEST MAI LDA num 80 iINDICATE NON TERMINAL INPUT STATUS IN HW STSTA NSFLGO CHANNEL OSTA NSFLGI CHANNEL 1LBRA RSTART RESTART LT 11 WITHOUT AFFECTING HW STATUS SBTTL ROM CHECKSUM TESTTHIS CHECKSUM ALGORITHM WAS FIRST USED IN THE TEKTRONIX 466 , PLOTTER.THE STORED CHECKSUM IS IN THE FIRST 2 LOCATIONS O iTHE ROM AND IS PLACED THERE BY THE ROM FORMATTER PROGRAM THE ALGORITHM GOES AS FOLLOWS 1 INITIALIZE CHECKSUM TO 0000 AND POINT TO FIRST RO 2 READ ROM BYTE 3 ADD TO CHECKSUM WITH CARRY 4 ROTATE CHECKSUM LEFT 1 WITH CARRY 5 POINT TO NEXT ROM LOCATION 6 REPEAT STEPS 2 5 UNTIL ALL ROM LOCATIONS ARE READ 7 COMPARE CHECKSUM WITH STORED CHECKSUMEXCEPTIONS TO THE ABOVE ALGORITHM ARE AS FOLLOWS i 1 IF THE ADDRESS IS FFEO FFE3, FF IS USED AS DATA 2 IF THE ADDRESS IS FFFO FFF9, THEN THE DATA COMES , 3 IF THE ADDRESS IS NOT INCLUDED IN ABOVE STEP 2. A RANGE FFE4 FFFF AND EITHER ADDRESS BIT 2 OR BIT 3 THEN ADDRESS BITS 3w 2.AND 1 ARE COMPLEMENTEDTHESE EXCEPTIONS ARE DUE TO THE PROGRAMMABLE INTERRUPT CONTREGISTER S CONTAINS THE RETURN ADDRESS ROMTST LDD num 0000 a INITIALIZE CHECKSUM TO 0000LDX num START POINT TO FIRST ROM LOCATIONLDY num VECLST LOAD POINTER TO SUBSTITUTE DATA LIST 1 CMPX num OFFEO DOES ADDRESS CONFLICT WITH INTERRUPT CONTROBLO 5 aNO, NO SPECIAL HANDLINGCMPX num OFFE4 a IS IN RANGE FFEO FFE3 BHS 2 aNO, GO ONADDB num OFF , YES.USE FF AS DATA BECAUSE CAN T READ REALBRA 6 2 CMPX num OFFFO 18 ADDRESS IN THE RANGE FFFO FFF9 BLO 3 NO, GO ONCMPX num OFFFA MAYBE, CHECK UPPER LIMITBHS 3 aNO, GO ONADDB , Y iYESss USE SHADOW BYTEBRA 6 a AND GO ON 3 EXG X,D iMOVE ROM ADDRESS POINTER TO ACCUMULATORSBITB num 4 COMPLEMENT ADDRESS BITS 3, 2, AND 1 BEG 4 YESBITB num 8 iTEST AGAINBEQ 4 , YES. COMPLEMENTEXQ X, D NO.USE ADDRESS AS ISBRA 5 4 EORB num OE COMPLEMENT ADDRESS BITS 3, 2, AND 1EXG X,D RETURN X TO X AND D TO DADDB ssX , ADD ROM BYTEEXG X,D RESTORE ROM ADDRESSEORB num OEEXG X,DBRA 6 USE NEW DATA 5 ADDB , X ADD ROM BYTE 6 BCC 7 , NO CARRY, GO ONINCA ADD IN END CARRYBNE 7 , NO OVERFLOW, QO ONINCB ADD IN OVERFLOW CARRY 7 ASLB SHIFT LEFTROLA SHIFT CARRY, IF ANY, INTO HIGH BYTEBCC 8 , NO END AROUND CARRYINCB , ADD END AROUND CARRY 8 LEAX 1,X END OF ROM BNE 1 , NO. NEXT LOCATIONCMPD VERIFY , YES. DOES CHECKSUM AGREE WITH STORED CHECKSBEQ 9 , YES.NEXT TESTEXG U,D PREPARE TO REFLECT ERROR IN STATUSANDA num C40 a INDICATE ROM ERROREXG U,D AND WRITE BACKLDY num ERR1 iPOINT TO START OF ROM ERROR MESSAGELBRA WRITEM AND WRITE MESSAGE 9 JMP ,S RETURN TO MAINLINE SBTTL RAM TESTTHIS IS A MODIFIED MARCH TEST WITH COMPLEMENT ADDRESSINGSCRATCH RAM IS NOT USED BECAUSE IT IS UNDER TEST. RETURN ADDRESS FOR SUBROUTINE CALLS IS STORED IN REGISTER S DEPENDING ON THE ROUTINE . 9 PASSES ARE REQUIRED TO TEST ALL DATA PATTERNS THE ALGORITHM USED IS AS FOLLOWS STARTING WITH TEST DATA 00, 1 WRITE TEST DATA TO CONSOLE CHANNEL O PORT 2 WRITE LOCATION WITH TEST DATA 3 COMPLEMENT ADDRESS AND WRITE WITH TEST DATA i 4 COMPLEMENT AND INCREMENT ADDRESS AND WRITE WITH T i 5 REPEAT STEPS 3 4 UNTIL ALL RAM LOCATIONS ARE WRIT 6 READ, VERIFY, AND COMPLEMENT THE DATA OF EACH OF LOCATIONS IN ORDER 7 DELAY APPROXIMATELY 1 SECOND TO CHECK FOR DROPOUT 8 VERIFY THE COMPLEMENTED DATA IN EACH LOCATION WIT i COMPLEMENT ADDRESSING SCHEME i 9 REPEAT STEPS 1 8 WITH TEST DATA OF 01,02,04,08,10 , AN S RECEIVED FROM THE CHANNEL O PORT WILL LOOP THIS TEST iAN L RECEIVED FROM THE CHANNEL O PORT WILL LOOP THIS TEST AN E RECEIVED FROM THE CHANNEL O PORT WILL END THIS TESTRAMTST TFR U,D FETCH STATUS WORDANDA num OFO a ZERO LOWER 4 BITS OF UPPER BYTEADDA num OA INITIALIZE PASS COUNTTFR D,U RETURN TO ULOOPR TFR U,D FETCH PASS COUNTDECA DONE WITH RAM TEST BITA num OF IT S IN THE LOWER 4 BITS OF UPPER BYTELBEQ ENDTST , YES.DETERMINE WHERE TO RETURN TOTFR D,U SAVE UPDATED PASS COUNTANDA num OF ONLY LOOK AT PASS COUNTLDB num 80 NOW FIGURE OUT WHAT TO USE FOR DATAASLB WILL BE 80,40,20,10,08,04,02,01, OR 00 1 RORB DEPENDING ON PASS COUNTDECA FINISHED BNE 1 NOEXG U.D FETCH CURRENT STATUSTSTB WAS HOST INITIATED SELF TEST EXG U,D RESTORE U AND D BMI WRITE1 YES. NO TERMINAL OUTPUTTFR D, S TEMP SAVE DATATFR B,A MOVE DATA TO ALDY num ENDLNE LOAD RETURN ADDRESSLBRA HEXOUT AND DISPLAY IN HEXENDLNE LDA ACIAO , OK TO SEND SPACE BITA num 2BEQ ENDLNE aNO, CHECK AGAINLDA num SPACE , YES.LOADSTA ACIAO 1 AND WRITETFR S,D RESTORE DATAWRITES TST 0000 REQUEST REFRESH OF BUFFER MEMORYSTB, X STORE DATAEXQ X, D MOVE ADDRESS POINTER TO DCOMB COMPLEMENT LOW BYTECOMA COMPLEMENT HIGH BYTEBPL 1 BUFFER MEMORY ADDRESS, GO ONANDA num 3 SCRATCH RAM IS 10 BITS ONLYBRA 2 iGO ON 1 ANDA num 03F BUFFER MEMORY IS 14 BITSORA 80 , MAP INTO BUFFER MEMORY SPACE 2 EXG X,D RESTORE D AND X WRITES TST 0000 REQUEST REFRESH OF BUFFER MEMORYSTB , X iSTORE DATAEXG X,D iMOVE ADDRESS POINTER TO DCOMB COMPLEMENT LOW BYTECOMA COMPLEMENT HIGH BYTEBPL 1 BUFFER MEMORY ADDRESS, GO ONANDA num 3 SCRATCH RAM IS 10 BITS ONLYBRA 2 iGO ON 1 ANDA num 03F BUFFER MEMORY IS 14 BITSORA num BO iMAP INTO BUFFER MEMORY SPACE 2 EXG X,D RESTORE DLEAX 1,X iPOINT TO NEXT ADDRESSWRITE3 CMPX num 200 WRITTEN ALL SCRATCH RAM LOCATIONS BNE 1 NO. CHECK BUFFER MEMORYLDX num 0000 YES. RESTORE START OF SCRATCH RAMBRA RMWl READ MODIFY, AND WRITE DATA 1 CMPX num 0A000 WRITTEN ALL BUFFER MEMORY LOCATIONS BNE WRITE1 iNOw NEXT LOCATIONLDX num 8000 YES, RESTORE START OF BUFFER MEMORYRMW1 TST 0000 iREFRESH BUFFER MEMORY REQUESTCMPB , X iDOES DATA VERIFY BEQ ERET1 YES. GO ONLDS num ERET1 ERROR LOAD RETURN ADDRESSLBRA RAMERR AND PRINT ERROR MESSAGE ERETI COMB COMPLEMENT DATATST 0000 REFRESH BUFFER MEMORY REQUESTSTB .X a STORE COMPLEMENTED DATACOMB RESTORE DATA FOR NEXt VERIFYCMPX num 400 END OF SCRATCH RAM BNE 1 NO. GO ONLDX num 0000 YES, RESTORE START OF SCRATCH RAMBRA DELAY AND VERIFY COMPLEMENTED DATA 1 CMPX num OCOOO END OF BUFFER RAM BNE RMW1 NO. CHECK NEXT LOCATIONLDX num 8000 , YES.RESTORE START OF SCRATCH RAMDELAY LDA num 3 NUMBER OF OUTSIDE LOOPS FOR I SECOND DFLAYLDY num 0000 ZERO DELAY COUNTER 1 LEAY 1,Y INCREMENT COUNT BNE 1 , INSIDE LOOP NOT FINISH DECA OUTSIDE LOOP FINISHED BNE 1 NOEXG U,D FETCH CURRENT STATUSTSTB WAS HOST INITIATED SELF TEST EXG U1D RESTORE U AND DBMI FLIP YES, NO TERMINAL OUTPUTLDS num FLIP LOAD RETURN ADDRESSCLRA a INDICATE COMING FROM RAMTST LBRA CHECK CHECK FOR KEYBOARD INPUTFLIP COMB COMPLEMENT DATA FOR VERIFYREAD1 TST 0000 REFRESH BUFFER MEMORY REQUESTCMPB , X iDOES DATA VERIFY BEQ ERET2 , YES.GO ONLDS num ERET2 ERROR, LOAD RETURN ADDRESSBRA RAMERR AND PRINT ERROR MESSAGEERET2 EXG X,D iMOVE ADDRESS POINTER TO DCOMB iCOMPLEMENT LOW BYTECOMA ssCOMPLEMENT HIGH BYTEBPL 1 BUFFER MEMORY ADDRESS, GO ONANDA num 3 SCRATCH RAM IS 10 BITS ONLYBRA 2 iGO ON 1 ANDA num 03F BUFFER MEMORY IS 14 BITSORA num 80 MAP INTO BUFFER MEMORY SPACE 2 EXG X,D RESTORE DREAD2 TST 0000 REFRESH BUFFER MEMORY REQUESTCMPB , X DOES DATA VERIFY BEQ ERET3 YES.GO ONLDS num ERET3 LOAD RETURN ADDRESSBRA RAMERR AND PRINT ERROR MESSAGEERET3 EXG X1D MOVE ADDRESS POINTER TO DCOMB COMPLEMENT LOW BYTECOMA COMPLEMENT HIGH BYTEBPL 1 BUFFER MEMORY ADDRESS, GO ONANDA num 3 SCRATCH RAM IS 10 BITS ONLYBRA 2 GO ON 1 ANDA num 03F BUFFER MEMORY IS 14 BITSORA num 80 , MAP INTO BUFFER MEMORY SPACE 2 EXG X,D RESTORE DLEAX 1,X POINT TO NEXT RAM ADDRESSCMPX num 200 VERIFIED ALL SCRATCH RAM LOCATIONS BNE 3 a NO, GO ONLDX num 0000 iYES, RESTORE START OF SCRATCH RAM POINTERBRA 4 iAND START NEXT PASS 3 CMPX num OAOOO VERIFIED ALL BUFFER RAM LOCATIONS BNE READ1 NO. CHECK NEXT LOCATIONLDX num 8000 YES.RESTORE START OF BUFFER RAM POINTER 4 LBRA LOOPR iSTART NEXT PASSENDTST CMPX num 0000 ADJUST FINISH TESTING SCRATCH RAM LBEQ TEST2B , YES. RETURN TO CONTROL BACK LBRA END2 iJUST FINISHED BUFFER MEMORYABORT LBRA TEST3 iABORT RAM TEST iERROR ROUTINE FdR RAM ERRORS iTHE ERROR MESSAGE IS IN THE FORM RAM ERROR AT ADDRESS XXXX EX XX RE XX iWHERE THE X S ARE REPLACED BY ERROR DATA EX IS EXPECTED DATA, RE IS RECEIVED DATA REGISTER X POINTS TO ERROR LOCATION REGISTER B CONTAINS EXPECTED DATA ,REGISTER S CONTAINS THE RETURN ADDRESS ,REGISTERS A AND Y ARE SCRATCHRAMERR EXG U,D FETCH CURRENT STATUSTSTB WAS HOST INITIATED SELF TEST EXG U,D RESTORE U AND DLBMI SETERR , YES. NO TERMINAL OUTPUTLDY num ERR2A iPOINT TO START OF ERROR MESSAGE RAM ERROR 1 LDA ACIAO iOK TO PRINT CHARACTER BITA num 2BEQ 1 NOT YETLDA aY FETCH CHARACTER TO BE PRINTEDBEQ 2 DONE WITH THIS PART OF ERROR MESSAGESTA ACIAO 1 PRINT ITBRA 1 READY FOR NEXT CHARACTER 2 TFR B,DP TEMP SAVE BTFR X,D FETCH ERROR ADDRESSLDY num PRINT1 POINT TO RETURN ADDRESSLBRA HEXOUT iAND OUTPUT UPPER BYTE IN HEXPRINT TFR X,D RE FETCH ERROR ADDRESSTFR B, A a PREPARE LOWER BYTELDY num PRINT2 POINT TO RETURN ADDRESS LBRA HEXOUT AND OUTPUT LOWER BYTE IN HEXPRINT2 LDY num ERR2B POINT TO EX MESSAGE 1 LDA ACIAO iOK TO PRINT CHARACTER BITA num 2BEQ 1 iNOT YETLDA ,Y FETCH CHARACTER TO BE PRINTEDBEQ 2 DONE WITH THIS PART OF ERROR MESSAGESTA ACIAO 1 PRINT ITBRA 1 , READY FOR NEXT CHARACTER 2 TFR DP, A RESTORE EXPECTED DATALDY num PRINT3 POINT TO RETURN ADDRESSLBRA HEXOUT AND OUTPUT DATA IN HEXPRINT3 LDY num ERR2C POINT TO RE MESSAGE 1 LDA ACIAO OK TO PRINT CHARACTER BITA num 2BEQ 1 NOT YETLDA , Y iFETCH CHARACTER TO BE PRINTEDBEQ 2 iDONE WITH ERROR MESSAGESTA ACIAO 1 PRINT ITBRA 1 iREADY FOR NEXT CHARACTER 2 TST 03FF REFRESH BUFFER MEMORY REQUESTLDA , X iFETCH RECEIVED DATALDY num PRINT4 POINT TO RETURN ADDRESSLBRA HEXOUT AND OUTPUT DATA IN HEXPRINT4 LDY num ERR2D , POINT TO END OF ERROR MESSAGE 1 LDA ACIAO OK TO PRINT CHARACTER BITA num 2BEQ 1 iNOT YETLDA ,Y iFETCH CHARACTER TO BE PRINTEDBEQ 2 iDONE WITH ERROR MESSAGESTA ACIAO 1 iPRINT ITBRA 1 , READY FOR NEXT CHARACTER 2 TFR DP,B RESTORE DATACLRA , RESTORE DPTFR A, DPSETERR EXG U,D FETCH STATUSANDA num C20 a INDICATE RAM ERRORBITB num 40 IS STOP ON ERROR BIT SET BNE 1 YES, GO ONEXG U,D RESTORE U AND D CLRA a INDICATE COMING FROM RAMTST BRA CHECK iCHECK FOR KEYBOARD INPUT AND RETURN 1 ORA ZOAO a INDICATE RAM ERROR AND SELF TEST COMPLETESTA PSTRO AND MOVE TO CHANNEL O HW PORT STATUS REGISTLDY num ERR3 POINT TO MESSAGE NOTIFYING USERLDS num STOP POINT TO RETURN ADDRESSLBRA WRITEM WRITE MESSAGESTOP LDS num STACK APPOINT TO VALID STACK IN CASE OF OPEN MODE RANDCC num CFMASK ALLOW FIRQ INTERRUPTS TO SAVE USSTA PICON ENABLE PROGRAMMABLE INTERRUPT CONTROLLERHANG BRA HANG AND HANG ,SECTION TO TEST FOR KEYBOARD INPUT FOR RAMTST AND IQTEST , IF S IS RECEIVED, THEN RAMTST IS LOOPED WITH STOP ON ER , IF L IS RECEIVED, THEN RAMTST IS LOOPED WITH NO STOP ON , IF E IS RECEIVED, THEN RAMTST IS ENDED , CTRL S TEMPORARILY STOPS OUTPUT , CTRL Q RESTARTS OUTPUT NO KEYBOARD CHECK IS MADE IF SELF TEST WAS HOST INITIATEDREGISTER A CONTAINS ORIGINATING ROUTINE INDICATOR PLUS RA iNO B , L , OR E CHECK IS MADE IF ORIGINATING ROUTINE WA ,REGISTER S CONTAINS THE RETURN ADDRESSREGISTER A IS USED AS SCRATCHCHECK EXG U,D a FETCH SELF TEST STATUSTSTB WAS SELF TEST HOST INITIATED EXG U,D RESTORE U AND DBMI 6 aYES, NO KEYBOARD INPUT CHECKASLA SAVE ORIGINATING ROUTINE INDICATOR IN CARRYLDA ACIAO ANY KEYBOARD INPUT BITA num 1 CARRY IS IN USE BEQ 6 NO, RETURNLDA ACIAO 1 YES, READ INPUTANDA num 7F MASK OFF BIT 8BCS 4 NO S , L OR E CHECKCMPA num S IS INPUT AN S BNE 1 aNO, GO ONEXG U,D YES, FETCH STATUS WORDORB num 60 AND SET STOP ON ERROR AND LOOP BITSEXG U, D RESTORE U AND DBRA 2 START LOOPING 1 CMPA num L IS INPUT AN L BNE 3 NO. GO ONEXQ U, D YES, FETCH UANDB num C40 CLEAR STOP ON ERROR BITORB num 20 iAND SET LOOPING MODE BITEXG U,D RESTORE 2 LBRA GOBACK RESTART LOOPING 3 CMPA num E IS INPUT AN E LBEQ ABORT YES.END TEST 4 CMPA num XOFF IS INPUT A CTRL S BNE 6 NO, RETURN 5 LDA ACIAO WAIT FOR MORE INPUTLSRABCC 5 NOTHING YETLDA ACIAO 1 READ INPUTANDA num 7F MASK OFF BIT 8CMPA num XON IS CTRL Q BNE 5 NO, IGNORE IT 6 JMP , S RETURNROUTINE TO OUTPUT CONTENTS OF REGISTER A IN HEXREGISTER B IS USED AS SCRATCHREGISTER Y CONTAINS THE CALL RETURN ADDRESS iNO OUTPUT OCCURS IF SELF TEST WAS HOST INITIATEDHEXOUT EXG U,D FETCH SELF TEST STATUSTSTB WAS SELF TEST HOST INITIATED EXG U,D RESTORE U AND DBMI 3 YES. NO OUTPUTLDB ACIAO PRINTER BUFFER EMPTY BITB num 2BEG HEXOUT iNOT YETTFR A,B DUPLICATELSRA MOVE UPPER 4 BITS TO LOWERLSRALSRALSRAADDA num O MAKE INTO AN ASCII NUMBERCMPA num 9 IS GREATER THAN 9 BLS 1 NO.OUTPUT AS ISADDA num A 9 1 YES, MAKE INTO HEX NUMBER A F 1 STA ACIAO 1 OUTPUTANDB num OF NOW LOOK AT LOWER 4 BITSADDB num O MAKE INTO AN ASCII NUMBERCMPB num 9 IS GREATER THAN 9 BLS 2 NO. OUTPUT AS ISADDD num A 9 1 YES, MAKE INTO HEX NUMBER A F 2 LDA ACIAO OK TO OUTPUT BITA num 2 BEG 2 NOT YETSTB ACIAO 1 YES, OUTPUT 3 JMP ,Y RETURN TO CALLING ROUTINE SBTTL TERMINAL I O TESTTHE POINTER TABLES, ACIA S PTM S AND HARDWARE REGISTERS ARTHE DATA PATH TO AND FROM EACH TERMINAL IS THEN TESTED WIT a INSTALLED ON J50 AT ALL VALID BAUD RATES WITH INTERRUPTS E 31 CHARACTERS ARE TRANSMITTED THROUGH EACH CHANNEL OO OFALSO, EACH PROGRAMMABLE TIMER IS TESTED AT 3 DIFFERENT DELA IMMEDIATELY AFTER THE 31ST CHARACTER AT THE HIGHEST 19200 INTERRUPT TRACKING IS STORED IN LOCATION TRACE BIT VALUES FOR TRACE ARE AS FOLLOWS BIT 7 SET, INDICATES CHANNEL 3 TIMER INTERRUPT BIT 6 SET, INDICATES CHANNEL 2 TIMER INTERRUPT BIT 5 SET, INDICATES CHANNEL 1 TIMER INTERRUPT BIT 4 SET, INDICATES CHANNEL O TIMER INTERRUPT BIT 3 SET, INDICATES CHANNEL 3 ACIA INPUT INTERRUPT BIT 2 SET, INDICATES CHANNEL 2 ACIA INPUT INTERRUPT BIT 1 SET, INDICATES CHANNEL 1 ACIA INPUT INTERRUPT a BIT O SET, INDICATES CHANNEL O ACIA INPUT INTERRUPT ALL CHANNELS ARE TESTED IN HOST INITIATED SELF TEST MODE iALL CHANNELS, EXCEPT CHANNEL O, ARE TESTED IN USER INITIATETHERE IS NO RECOVERY FOR AN UNIDENTIFIED INTERRUPTIOTEST LBSR INIT a INITIALIZE POINTER TABLES, ACIA 51 PTM1 S ATFR U, D a RESTORE HW STATUS REGISTERSTA PSTRO DUE TO INIT ROUTINE CLEARLDX num INSELF POINT TO SELF TEST INPUT SERVICE ROUTINESTX INPUTO SAVE FOR CHANNEL OSTX INPUT1 iAND CHANNEL 1STX INPUT2 a INITIALIZING ALL CHANNELS EARLYSTX INPUT3 a IN ORDER TO MONITOR UNEXPECTED INTERRUPTSLDX num STATO POINT TO CHANNEL O POINTER TABLECLR IOCHAN iSET INITIAL CHANNEL NUMBER TO OTFR U,D a FETCH SELF TEST STATUSTSTB iWAS SELF TEST HOST INITIATED BMI IOPREP iYES TEST ALL CHANNELSLDA num TXROFF iNO DISABLE CHANNEL O INTERRUPTSSTA TTCSRX, X SO THAT NORMAL PRINTING CAN BE PERFORMEDLBRA NEWCH iSKIP CHANNEL O PORTION OF TESTIOPREP CLR IOATT CLEAR THE ATTRIBUTE BYTELDA IOCHAN iFETCH CURRENT CHANNEL NUMBERADDA num O MAKE CHANNEL NUMBER ASCIILBSR PRINTC AND DISPLAYLDY num CLKTBL iPOINT TO START OF BAUD RATE TABLECLR IORATE a INITIALIZE RATE COUNT TO O LOAD LDD ,Y LOAD NEW BAUD RATESTD RATEX, X iWRITE TO PTM LATCHPTMPNT STY CLKPNT SAVE BAUD RATE POINTER FOR LATERCLRB iFIRST CHAR IS A NULLNEWDAT STB EXPDAT SAVE EXPECTED DATALDY PUSHDX, X POINT TO NEXT BUFFER LOCATIONLDA IOATT iLOAD ATTRIBUTE BYTESTA 1, Y iAND STORESTB ,Y RESTORE DATA AND UPDATE POINTERSTY PUSHOX, X SAVE NEW OUTPUT POINTER NO WRAP AROUND TOLDA num TXON iENABLE TRANSMIT INTERRUPTSTA L TTCSRX,X3 ANDCC num CIMASK iENABLE IRQ INTERRUPT MONITORINGLDY CLKPNT LOAD BAUD RATE TABLE POINTERLDY CLKMAX, Y iFETCH TIMEOUT CONSTANT 1 LDB TRACE iFETCH LATEST INTERRUPT STATUSBNE 3 GOT INTERRUPT S , EVALUATELEAY 1,Y NOTHING, TIMED OUT BNE 1 NO.CHECK AGAINORCC num IMASK DISABLE IRQ INTERRUPT MONITORINGLDB num 81 iINDICATE TIMEOUT ERRORTST IOATT iTIMER TESTING BEQ 2 aNO, GO ONANDB num CBO aYES, DON T DISPLAY EXPECTED DATA 2 LBSR IOERR AND LOGBRA 89 SKIP READ 3 ORCC num IMASK DISABLE IRQ INTERRUPT MONITORINGPSHS Y TEMP SAVE YLDY PUSHIX, X POINT TO INPUT CHARACTERLDA ,Y AND FETCHPULS Y RESTORE YLDB MARKX, X FETCH CHANNEL MARKERTST IOATT TIMER TEST BEG 4 NO. ACIA TESTASLB YES. SHIFT TO UPPER BITSASLBASLBASLBCLRA CLEAR RECEIVED DATA FOR VERIFY 4 STA RECDAT SAVE RECEIVED DATACMPB TRACE ONE AND ONLY ONE INTERRUPT AND CORRECT ONEBEQ 5 YES.GO ONLDA EXPDAT TEMP SAVE NORMALLY EXPECTED DATAPSHS ASTB EXPDAT SAVE EXPECTED INTERRUPT STATUS FOR ERROR MELDB TRACE ALONG WITH RECEIVED INTERRUPT STATUSSTB RECDATLDB num OC4 IDENTIFY AS UNEXPECTED INTERRUPT ERRORBRA 6 iAND LOG 5 EORB TRACE ONLY CLEAR OPERATION THAT CAUSED INTERRUPTSTB TRACE MONITOR INTERRUPTS BETWEEN CHARSTFR Y,D MOVE TIME SPENT WAITING FOR CHARLDY CLKPNT LOAD BAUD RATE CLOCK REFERENCE POINTERCMPD XCLKMINaY WAS MINIMUM CHARACTER TIME REACHED BLS 7 YES. CHECK FOR DATA VERIFYLDB EXPDAT SAVE EXPECTED DATAPSHS B IN ORDER TO USE COMMON CODE FOLLOWING IOERLDB num OC2 a INDICATE EARLY INPUT ERRORTST IOATT TIMER TESTING BEQ 6 NO. GO ONANDB num COCO YES.OMIT RECEIVED AND EXPECTED DATA IN ERR 6 BSR IOERR AND LOGLDA num MRESET RESET ACIASTA TTCSRX.X TO RE SYNCHRONIZE TO AVOID CAUSING MORE ERRLDA num TXOFF RESTORE DATA PARAMETERSSTA TTCSRX, X CLR TRACE CLEAR INTERRUPT STATUSPULS B RESTORE EXPECTED DATABRA 9 SKIP DATA VERIFY 7 LDA RECDAT LOAD RECEIVED DATACMPA EXPDAT , DID INPUT OUTPUT BEQ 8 YES. GO ONLDB num OCO aNO, INDICATE DATA COMPARISON ERRORBSR IOERR AND LOG 8 LDB EXPDAT RESTORE DATA 9 TST IOATT TIMER TESTING BNE NEWBOD YES. NO DATA UPDATEINCB INCREMENT DATACMPB num 10 a INCREMENTING UPPER 4 BITS LBLS NEWDAT NO. USE CURRENT DATAADDB 10 1 YES.INCREMENT UPPER 4 BITSLBNE NEWDAT AND OUTPUT NEWBOD LDY CLKPNT LOAD RATE POINTERLEAY 2,Y iPOINT TO NEXT BAUD RATEINC IORATE a INCREMENT RATE COUNTLDB IORATE FETCH RATE COUNTCMPB num TOPCLK CLKTBL 2 TESTED CHANNEL AT ALL BAUD RATESLBLS IOLOAD NO.ANOTHER TO GOLDA IOATT FETCH ATTRIBUTE BYTEINCA INCREMENTORA num 8 a INHIBIT CHARACTER OUTPUTSTA IOATT SAVE NEW ATTRIBUTE BYTECMPA num TSTMAX 4 DLYTBL 4 8 TESTED ALL DELAY TIMES LBLS PTMPNT aNO, TEST NEXT DELAY TIMENEWCH LEAX 40, X POINT TO START OF NEXT CHANNEL S POINTER TAINC IOCHAN INCREMENT CHANNEL NUMBERLDA IOCHAN FETCH CHANNEL NUMBERCMPA num 4 a TESTED ALL CHANNELS LBNE IOPREP aNO, MORE TO DORTS RETURN TO SELF TEST MAINLINE ERROR ROUTINE FOR I O ERRORSTHE ERROR MESSAGE IS IN THE FORM a ISO ERROR ON CHANNEL X RATE XX EX XX RE XX a OR ISO ERROR ON CHANNEL X RATE XX EX XX RE XX UNEXP a OR i I O ERROR ON CHANNEL X RATE XX EX XX RE XX EARLY a OR i I O ERROR ON CHANNEL X RATE XX EX XX NO INPUT WHERE THE X S ARE REPLACED BY ERROR DATARATE IS REFLECTED AS FOLLOWS i 00 150 BAUD i 01 300 BAUD 02 600 BAUD 03 1200 BAUD 04 2400 BAUD 05 4800 BAUD i 06 9600 BAUD 07 19200 BAUD 3 08 2 MSEC DELAY i 09 4 MSEC DELAY a OA 50 MSEC DELAY EX IS EXPECTED DATA, RE IS RECEIVED DATA IN THE CASE OF AN UNEXPECTED INTERRUPT ERROR, EX REFLECTS INTERRUPT PATTERN AND RE REFLECTS THE RECEIVED INTERRUPTTHE BIT VALUES FOR EX AND RE IN UNEXPECTED INTERRUPT ER BIT 7 SET, INDICATES CHANNEL 3 ACIA INTERRUPT BIT 6 SET, INDICATES CHANNEL 2 ACIA INTERRUPT BIT 5 SET, INDICATES CHANNEL I ACIA INTERRUPT BIT 4 SET, INDICATES CHANNEL O ACIA INTERRUPT BIT 3 SET, INDICATES CHANNEL 3 TIMER INTERRUPT BIT 2 SET, INDICATES CHANNEL 2 TIMER INTERRUPT BIT 1 SET, INDICATES CHANNEL 1 TIMER INTERRUPT BIT O SET, INDICATES CHANNEL O TIMER INTERRUPT REGISTER B CONTAINS ERROR PRINTOUT FORMAT INFORMATION AS FO BIT 7 SET, PRINTS EXPECTED DATA BIT 6 SET, PRINTS RECEIVED DATA a BIT 2 SET, PRINTS UNEXPECTED INTERRUPT ERROR MESSA BIT 1 SET, PRINTS EARLY INPUT ERROR MESSAGE IN PLA BIT 0 SET, PRINTS NO INPUT ERROR MESSAGE IN PLACE IOCHAN CONTAINS CURRENT CHANNEL NUMBER RECDAT CONTAINS RECEIVED DATA EXPDAT CONTAINS EXPECTED DATA CTRL S TEMPORARILY STOPS OUTPUT CTRL Q RESTARTS OUTPUT REGISTER X CONTAINS POINTER TO RELEVANT POINTER TABLECONTENTS OF REGISTERS A AND B ARE DESTROYEDNO OUTPUT OCCURS IF SELF TEST WAS HOST INITIATEDIOERR STB ERRFMT a SAVE ERROR FORMATPSHS Y SAVE REGISTER YLDY num ERR4A POINT TO I O ERROR PART OF ERROR MESSAGELBSR PRINTM AND PRINTLDA IOCHAN LOAD CHANNEL NUMBERADDA O MAKE ASCIIBSR PRINTC AND PRINTLDY num ERR4B POINT TO RATE PART OF ERROR MESSAGELBSR PRINTM AND PRINTLDA IORATE FETCH RATE COUNTLDY HEXEX LOAD RETURN ADDRESSLBRA HEXOUT AND OUTPUT IN HEXHEXEX ASL ERRFMT iPRINT EXPECTED DATA BCC HEXREC NO. GO ONLDY num ERR2B POINT TO EX PART OF ERROR MESSAGEBSR PRINTM AND PRINTLDA EXPDAT LOAD EXPECTED DATALDY HEXREC LOAD RETURN ADDRESSLBRA HEXOUT AND PRINT IN HEXHEXREC ASL ERRFMT DISPLAY RECEIVED DATA BCC INTRVP NO. GO ONLDY num ERR2C POINT TO START OF RE MESSAGEBSR PRINTM , AND PRINTLDA RECDAT LOAD RECEIVED DATALDY num INTRUP LOAD RETURN ADDRESSLBRA HEXOUT AND OUTPUT IN HEXINTRUP LDB ERRFMT FETCH UPDATED ERROR FORMATBITB num 4 4 PRINT UNEXPECTED INTERRUPT ERROR MESSAGE BEQ EARLY NO. GO ONLDY num ERR4E YES. POINT TO START OF ERROR MESSAGEBSR PRINTM AND PRINTEARLY BITB num 2 4 PRINT EARLY INPUT BEQ LOST NO. GO ONLDY num ERR4C YES. POINT TO START OF MESSAGEBSR PRINTM AND PRINTLOST BITS num 1 4 PRINT NO INPUT BEQ 1 aNO, GO ONLDY num ERR4D YES, POINT TO START OF MESSAGEBSR PRINTM AND PRINT 1 LDY num ERR2D POINT TO ERROR MESSAGE TERMINATIONBSR PRINTM AND PRINT EXG U,D iFETCH SELF TEST STATUSANDA num C10 AND INDICATE I O ERRORORB MARKX, X IDENTIFY CHANNEL FOR HOSTEXG U,D RESTORE U AND DTFR S,Y TEMP SAVE STACK POINTERLDS num ENDERR LOAD RETURN ADDRESSLDA num 80 a INDICATE COMING FROM IOTEST LRRA CHECK iCHECK FOR CCTRL S ENDERR TFR Y, S RESTORE STACK POINTERPULS Y RESTORE YRTS iAND RETURN ROUTINE TO OUTPUT CHARACTERS TO PORT O TERMINAL AFTER STAC REGISTER A CONTAINS THE CHARACTER TO BE OUTPUTNO REGISTERS ARE AFFECTED NO OUTPUT OCCURS IF SELF TEST WAS HOST INITIATEDPRINTC EXG U,D a FETCH CURRENT STATUSTSTB WAS HOST INITIATED EXG U, D iRESTORE U AND DBMI 2 YES, NO TERMINAL OUTPUTPSHS A TEMP SAVE CHARACTER TO BE OUTPUT 1 LDA ACIAO FETCH I O STATUSBITA num 2 OK TO OUTPUT BEQ 1 iNO CHECK AGAINPULS A YES.RESTORE OUTPUT CHARSTA ACIAO 1 AND OUTPUT 2 RTSROUTINE TO PRINT MESSAGES TO PORT O TERMINAL AFTER STACK ISREGISTER Y POINTS TO START OF MESSAGE IN MESSAGE STRING SENDS CR LFNULL IN MESSAGE STRING TERMINATES MESSAGE NO REGISTERS ARE AFFECTED NO OUTPUT OCCURS IF SELF TEST WAS HOST INITIATEDPRINTM PSHS A,X SAVE A AND XTFR StX SAVE STACK POINTERLDS num RETURN LOAD RETURN ADDRESSBRA WRITEM iAND WRITE MESSAGERETURN TFR X, S RESTORE STACK POINTERPULS X, A RESTORE A AND XRTS AND RETURN SECTION TO OUTPUT MESSAGES FOR SELF TEST BEFORE STACK IS INREGISTER Y POINTS TO START OF MESSAGEREGISTER A IS USED AS SCRATCH i IN MESSAGE STRING SENDS CR LF NULL IN MESSAGE STRING TERMINATES MESSAGE REGISTER S CONTAINS THE RETURN ADDRESS NO OUTPUT OCCURS IF SELF TEST WAS HOST INITIATEDWRITEM EXG U,D iFETCH CURRENT STATUSTSTB iWAS HOST INITIATED SELF TEST EXG U,D a RESTORE U AND DBMI 4 YES, NO TERMINAL OUTPUT 1 LDA ACIAO FETCH CHAN O TRANSMIT STATUSBITA num 2 ALREADY FOR ANOTHER CHARACTER BEQ 1 NOT YETLDA, Y YES, FETCH NEXT CHARACTERBEG 4 END OF MESSAGE, RETURNCMPA num iIS TIME FOR CR LF BNE 3 NO.OUTPUT AS ISLDA num CR YES, LOAD CRSTA ACIAO 1 AND OUTPUT 2 LDA ACIAO OUTPUT READV BITA num 2BEQ 2 NO, TRY AGAINLDA num LF YES, LOAD LF 3 STA ACIAO 1 PRINT CHARACTERBRA 1 CHECK FOR MORE CHARACTERS TO PRINT 4 JMP ,S RETURN TO CALLING ROUTINEROUTINE TO START PROGRAMMABLE TIMERREGISTER B CONTAINS DELAY CONSTANTREGISTER X POINTS TO RELEVANT POINTER TABLE REGISTERS A, B, AND Y ARE LOSTSETOFF LDY num DLYTBL 4 POINT TO TOP OF DELAY TABLE 4ASLB SHIFT FOR PROPER INDEXINGASLBLDA B,Y FETCH RELOAD COUNTSTA XRLOADXX AND SAVEINCB POINT TO COUNT VALUELDD B,Y FETCH ITSTD TIMERX, X AND WRITE TO HARDWARE TIMERLDA PTMONX, X FETCH COUNTER ENABLE CONTROL BYTESTA PTCTLX, X AND ENABLE COUNTERRTS RETURN INITIALIZATION SECTION FOR PRESETTING THE POINTER TABLES, AND HARDWARE REGISTERS OUTPUT ATTRIBUTE BYTES ARE ZEROEDINIT ORCC num IFMASK DISABLE ANY INTERRUPT MONITORING SWI2 OR SLDX num ENDRAM START FROM LAST NON STACK SCRATCH RAM ADDTFR X, Y USE AS LOCATION COUNTER TOO 1 CLR , X CLEAR LOCATION LEAY 1, Y CLEARED ALL SCRATCH RAM BNE 1 NO, IF NOT ZEROLDX num STATO POINT TO TOP OF FIRST CHANNEL POINTER TABLELDY num INBUFO FETCH START OF FIRST CHANNEL INPUT BUFFER CLRB START WITH CHANNEL OPRESET STX XPOINTX num X STORE POINTER TABLE ADDRESS INTO POINTER TASTY PUSHIX, X PRESET INPUT BUFFER POINTERSSTY XXPOPIX,X LEAY 800,Y LOAD THIS CHANNEL S START OF OUTPUT BUFFERSTY PUSHOX, X AND PRESET OUTPUT BUFFER POINTERSSTY POPOX, XSTY XOBOTX,X AND STORE IN POINTER TABLELBSR CLRATT CLEAR ALL ATTRIBUTE BYTES IN OUTPUT BUFFERPSHS Y TEMP SAVE YLDY num HOSTIN POINT TO POWER UP TERMINAL INPUT ROUTINESTY INPUTX,X AND SAVE IN TABLELDY OUTPUT LOAD POINTER TO TERMINAL OUTPUT ROUTINESTY OUTPTX, X AND SAVE IN TABLELDY num HWCLRO POINT TO CHANNEL O S TRANSMIT COUNTER ADDRELEAY B,Y , NOW POINT TO CHANNEL CURRENTLY BEING INITIASTY XTTCLRXuX AND STORE HARDWARE TRANSMIT COUNTER ADDRESSCLR , Y ALSO CLEAR COUNTERLEAY 1000, Y NOW REFLECT THE STATUS REGISTER ADDRESSSTY PSTATX, X AND SAVECLR IY ALSO CLEAR STATUS REGISTERLEAY 1000,Y NEXT IS THE HOST INPUT REGISTER ADDRESSSTY HRBUFX, X SAVELDY num ACIAO APPOINT TO CHANNEL O TERMINAL PORT ADDRESSCLRA MAKE SURE A IS ZEROEDEXG A, B UPDATE TO POINT TO CURRENT CHANNELASLALEAY D,Y EXG A, B RESTORE A AND BSTY TTCSRX, X STORE TERMINAL CONTROL STATUS REGISTER ADDRLDA num MRESET LOAD MASTER RESET VALUESTA IY AND WRITE TO ACIALDA XTXOFF a INITIALIZE TERMINAL PORT CONTROL REGISTERSTA , Y AND REFLECT TERMINAL PORT DATA ADDRESSSTY XTPORTX,X AND STORE INTO POINTER TABLELDY num CLOCKO POINT TO CHANNEL O S BAUD RATE LATCHLEAY B,Y , NOW POINT TO CURRENT CHANNEL S BAUD RATE LALSRB RESTORE BCMPB num 3 a IS THIS CHANNEL 3 BNE 1 iNO CONTINUELDY num CLOCK3 YES, THIS ONE IS ODD 1 STY RATEX,X AND SAVELDY DEFALT FETCH DEFAULT BAUD RATE CONSTANT 2400 STY RATEX, X AND SEND TO BAUD GENERATORLDA num DEFALT CLKTBL 2 num 10 MOVE DEFAULT BAUD VALUESTA SPEEDX, X TO POINTER TABLELDA num SSHOT FETCH TIMER INTERRUPT ENABLE CONSTANT BITB num 1 IS CHANNEL 1 OR 3 BEQ 2 NO, GD ONINCA i YESI ADJUST CONSTANT 2 STA PTMONX, X STORE INTO POINTER TABLELDA num MSHOT FETCH TIMER INTERRUPT DISABLE CONSTANTBITB num 1 IS CHANNEL 1 OR 3 BEQ 3 NO, GO ONINCA YES, ADJUST CONSTANT 3 STA PTMSKX, X a STORE INTO POINTER TABLETFR B,A PREPARE TO SET CHANNEL INDICATOR BITINCA MAKE SURE THAT AT LEAST ONE BIT IS SETCMPA num 2 LEAVE IT AT THAT BLS 4 YES, GO ONANDA num C1 NO CLEAR LSBASLA AND SHIFT 4 STA MARKX, X a AND SAVELEAX 40, X POINT TO START OF NEXT CHANNEL S POINTER TAPULS Y RESTORE YLEAY 800Y POINT TO NEXT CHANNEL S START OF INPUT BUFFINCB BUMP CHANNEL NUMBERCMPB num 4 DONE INITIALIZING ALL POINTER TABLES LBNE PRESET i NOPE LDX CLOCKO 2 POINT TO FIRST BAUD GENERATORLDA num FSHOT CONTINOUS OUTPUT CONSTANT FOR BAUD CLOCKSCLR 1, X POINT TO CHANNEL 2 CONTROL REGISTERSTA , X WRITE CONTROL TO CHANNEL 2 BAUD GENERATORINCA CHANNEL O IS AFTER 1STA 1, X WRITE CONTROL TO CHANNEL 1 BAUD GENERATORDECA MAKE SURE RESET BIT IS OFFSTA .X iWRITE CONTROL TO CHANNEL O BAUD GENERATORLDX num CLOCK3 6 NOW READY FOR CHANNEL 3CLR 1, X POINT TO CHANNEL 3 CONTROL REGISTERSTA ,X WRITE CONTROL TO CHANNEL 3 BAUD GENERATORLDA num 1 POINT TO CHANNEL 1 CONTROL REGISTERSTA 1, XCLR ,X AND CLEAR PTM INTERNAL RESET BITLDX num PTMO 2 DO THE SAME FOR CHAN 2,3 PTMSTA 1,X CLR, X NEEDED TO ENABLE TIMERSLDX num PTMO POINT TO CHANNEL O TIMER LATCH ADDRESSSTX TIMERO AND STORE IN POINTER TABLELDX num PTMO 2 NOW POINT TO CONTROL ADDRESSSTX PTCTLO AND ALSO STORE IN POINTER TABLELDX num PTM1 POINT TO CHANNEL 1 TIMER LATCH ADDRESSSTX TIMER1 AND STORE IN POINTER TABLELDX num PTM1 3 NOW POINT TO CONTROL ADDRESSSTX PTCTL1 iAND ALSO STORE IN POINTER TABLELDX num PTM2 POINT TO CHANNEL 2 TIMER LATCH ADDRESSSTX TIMER2 AND STORE IN POINTER TABLELDX num PTM2 2 NOW POINT TO CONTROL ADDRESSSTX PTCTL2 AND ALSO STORE IN POINTER TABLELDX num PTM3 POINT TO CHANNEL 3 TIMER LATCH ADDRESS STX TIMER3 AND STORE IN POINTER TABLELDX num PTM3 3 NOW POINT TO CONTROL ADDRESSSTX PTCTL3 aAND ALSO STORE IN POINTER TABLERTS a DONE AT LASTROUTINE TO CLEAR ALL ATTRIBUTE BYTES IN THE OUTPUT BUFFERREGISTER X CONTAINS THE POINTER TO THE START OF THE APPROPRUSER PROGRAM SHOULD ALLOW AT LEAST 20 MSEC ACTIVE RUN TIMOF THIS ROUTINE NO REGISTERS ARE AFFECTEDCLRATT PSHS X,Y,D SAVE X, Y5 AND D FOR RETURNLDY OGBTX, X LOAD OUTPUT BUFFER STARTING ADDRESSLEAY 1, Y POINT TO FIRST ATTRIBUTELDX num OTBUFO INBUFO 2 RELOAD BYTE COUNTCLRA PREPARE TO CLEAR ATTRIBUTE 1 LDB STATO REFRESH BUFFER MEMORY REQUESTSTA , Y CLEAR ATTRIBUTE AND POINT TO NEXT ONELEAX 1,x CLEARED ALL ATTRIBUTES FOR THIS CHANNEL BNE 1 aNO, KEEP GOINGPULS D, Y, X YES. RESTORE D Y1 AND XCLR LOOPX,X MAKE SURE THAT LOOP MODE FLAG IS CLEAREDRTS AND RETURN .SBTTL IRQ INTERRUPT SERVICE ROUTINES .SBTTL IRQ INTERRUPT SERVICE POLLING ROUTINE HUNTER IS THE POLLING ROUTINE TO DECIDE WHO CAUSED INTERR AND WHAT TO DO ABOUT ITDUPLICATION OF CODE IS FOR SPEEDY SERVICEHUNTER LDA ACIAO iSTART WITH CHANNEL O TERMINAL INTERRUPT LDBPL LOOKI iNO INTERRUPT FROM THIS PORTLDX num STATO YES.POINT TO BOTTOM OF POINTER TABLEBITA num Z1 a INPUT INTERRUPT BEG PUTOUT NO. OUTPUTLDB ACIAO 1 READ INPUTJMP INPUTX,X AND PROCESS LOOK1 LDA ACIA1 CHECK CHANNEL 1 TERMINAL PORT LDD ACIA1 NOBPL LOOK2 NO INTERRUPT FROM THIS PORTLDX num STAT1 YES, POINT TO BOTTOM OF POINTER TABLEBITA num 21 a INPUT INTERRUPT BEQ PUTOUT NO, OUTPUTLDB ACIA 1 READ INPUTJMP INPUTX,X AND PROCESSLOOK2 LDA ACIA2 iCHECK CHANNEL 2 TERMINAL PORT LDD ACIA2 NOBPL LOOK3 NO INTERRUPT FROM THIS PORTLDX num STAT2 YES, POINT TO BOTTOM OF POINTER TABLEBITA num 21 a INPUT INTERRUPT BEQ PUTOUT NO, OUTPUTLDB ACIA2 1 iREAD INPUT JMP INPUTX,X AND PROCESSLOOK3 LDA ACIA3 CHECK CHANNEL 3 TERMINAL PORT LDD ACIA3 NOBPL MISS NO, CHECK PTM SLDX num STAT3 YES, POINT TO BOTTOM OF POINTER TABLEBITA num 21 a INPUT INTERRUPT BEQ PUTOUT NO, OUTPUTLDB ACIA3 1 READ INPUTJMP INPUTX,X AND PROCESSPUTOUT JMP OUTPTX,X OUTPUTMISS LDB TRACE LOAD INTERRUPT TRACKING STATUSLDA PTMO 1 iIS IT CHANNEL O OR 1 TIMER INTERRUPT BPL 29 NO, GO ONBITA num 1 YES, IS CHANNEL O BEQ 1 NO, MUST BE CHANNEL 1LDX num STATO YES, POINT TO BOTTOM OF POINTER TABLEORB num 10 iSET INTERRUPT BIT FOR SELF TESTBRA 4 AND SERVICE INTERRUPT 1 LDX num STAT1 iPOINT TO BOTTOM OF CHANNEL 1 S POINTER TABLORB num 20 iSET INTERRUPT BIT FOR SELF TESTBRA 4 AND SERVICE INTERRUPT 2 LDA PTM2 1 iIS IT CHANNEL 2 OR 3 TIMER INTERRUPT BPL 5 NO, TRY TO IGNORE ITBITA num 1 YES, IS CHANNEL 27BEG 3 NO. MUST BE CHANNEL 3LDX num STAT2 YES.POINT TO BOTTOM OF POINTER TABLEORB num 40 SET INTERRUPT BIT FOR SELF TESTBRA 4 AND SERVICE INTERRUPT 3 LDX num STAT3 iPOINT TO BOTTOM OF CHANNEL 3 S POINTER TABLORB num 80 SET INTERRUPT BIT FOR SELF TEST 4 LBRA TYMOUT AND SERVICE INTERRUPT 5 RTI iTRY TO RETURN FROM UNDEFINED INTERRUPT .SBTTL TERMINAL INPUT INTERRUPT SERVICE ROUTINE BITHIS ROUTINE CONTAINS NO FRILLS BINARY IS ALLOWED DOUBLE CTRL Cs DATA OVERRUN, AND FRAMING ERROR DETECTION ARTHIS ROUTINE IS USED WHEN BINARY MODE IS ENABLED BY PORT CREGISTER X POINTS TO TOP OF RELEVANT POINTER TABLEREGISTER A CONTAINS THE CONTENTS OF THE ACIA STATUS REGISTEREGISTER B CONTAINS THE INPUT CHARACTER IRQ INTERRUPTS ARE DISABLED DURING THIS ENTIRE ROUTINE IT IS CRUCIAL THAT THIS ROUTINE BE AS SHORT AS POSSIBLE SOCHARACTERS ARE NOT LOST LTREAD LDY PUSHIX,X FETCH INPUT BUFFER POINTER AND REFRESH BUFFSTB , Y STORE CHARACTER INTO INPUT BUFFERANDA num 30 SAVE ONLY OVERRUN AND FRAMING ERROR BITS OFEXG Y,D MOVE UPDATED INPUT WRITE POINTER TO ACANDA num C8 TAKE CARE OF ANY WRAP AROUNDCMPD POPIX,X iIS INPUT BUFFER FULL EXG Y,D RESTORE Y AND DBNE 1 NO, GO ONORA num 20 YES, SET OVERRUN BITLDY PUSHIX,X AND RESTORE OLD INPUT WRITE BUFFER POINTER 1 ANDB num 7F MASK OFF BIT 8 OF INPUT CHARCMPB num ETX a IS CTRL C BNE 2 NO, GO ONTST CCFLGX,X YES. IS SECOND CTRL C BEG 3 NO. FIRSTORA num 40 YES.SET SECOND CTRL C BIT OF STATUS 2 CLR B PREPARE TO CLEAR CTRL C FLAG 3 STB CCFLGX, X STORE CTRL C FLAG STATESTY PUSHX,X STORE INPUT WRITE BUFFER POINTER FOR NEXT TWATCH ORA STATX,X OR IN CURRENT PORT TERMINAL INPUT STATUS BYSTA STATX,X AND WRITE BACKLDD POPIX,X FETCH INPUT BUFFER READ POINTERSUBD PUSHIX,X DETERMINE NUMBER OF FREE LOCATIONS IN BUFFE ANDA num 7 iONLY LOOK AT 11 BITS 2K CMPD num MAXRM FREE SPACE CRITICAL BHI 2 LOTS OF SPACETST FLAGDS,X a IS FLAGGED INPUT IN EFFECT BEQ 1 NO, FORGET ITTST FROZX,X a XOFF ALREADY SENT BNE 1 YES, LET S GO ALREADYLDA num XOFF 80 QUEUE XOFFSTA FROZX,XTST OTFLGX, X IS OUTPUT CURRENTLY IN PROGRESS LBEQ TRIGGR aNO, START NEW OUTPUT 1 RTI DONE WITH TERMINAL INPUT 2 LDB HOLDX,X TIMEOUT HOLD MODE IN EFFECT BITB num 3BEG 3 aNO, ALL DONETST RLOADX,X ALREADY TIMED OUT BEG 39 YES, SKIP ACTIVE BITLDA num 2 NO, INDICATE ACTIVESTA RLOADX,X 3 RTi ,DONE WITH TERMINAL INPUT .SBTTL TERMINAL INPUT INTERRUPT SERVICE ROUTINE NON BINARYTHIS ROUTINE CONTAINS SOME FRILLS...SUCH AS OUTPUT CONTROL CTRL S AND CTRL Q ALSO, CTRL C AND CTRL O KILLS THE OUTPUT BUFFERAND CTRL X KILLS THE INPUT BUFFER DOUBLE CTRL C , DATA OVERRUN, AND FRAMING ERROR DETECTIONTHIS ROUTINE IS USED WHEN BINARY MODE IS DISABLED BY PORTTHIS ROUTINE IS ALSO DEFAULT AT POWER UP RESET TIME REGISTER X POINTS TO TOP OF RELEVANT POINTER TABLE REGISTER A CONTAINS THE CONTENTS OF THE ACIA STATUS REGISTEREGISTER B CONTAINS THE INPUT CHARACTER IRQ INTERRUPTS ARE DISABLED DURING THIS ENTIRE ROUTINE IT IS IMPORTANT THAT THIS ROUTINE BE AS SHORT AS POSSIBLE S CHARACTERS ARE NOT LOSTHOSTIN LDY PUSHIX, X FETCH INPUT BUFFER POINTER AND REFRESH BUFFSTB , Y STORE CHARACTER INTO INPUT BUFFERANDB num 7F MASK OFF BIT 8CMPB num CAN , IS INPUT A CTRL X BNE 1 NO, GO ONSTY KILLIX1X YES, REQUEST KILL INPUT BUFFER 1 ANDA num 30 ,SAVE ONLY OVERRUN AND FRAMING ERROR BITS OFEXG Y.D MOVE INPUT WRITE POINTER TO ACADDD num 1 a INCREMENT POINTERANDA num C8 ,TAKE CARE OF ANY WRAP AROUNDCMPD POPIX, X IS INPUT BUFFER FULL EXG Y, D RESTORE Y AND D BNE 2 NO, GO ONORA num 20 YESs SET OVERRUN BITBRA 3 DON T UPDATE THE BUFFER WRITE POINTER 2 STY PUSHIX, X STORE NEW BUFFER WRITE POINTER 3 CMPB num ETX IS CTRL C BNE 4 NO, GO ONCLR GOFLGX, X YES, CLEAR OUTPUT STOPPED FLAGORA num 40 DEFAULT TO SECOND CTRL C IN A ROWTST CCFLGX, X IS SECOND CTRL C BNE 8 YES, REQUEST KILL OUTPUT BUFFERSTB CCFLGX,X NO, SET CTRL C FLAGANDA num C40 ,CLEAR SECOND CTRL C RECEIVED BITBRA 8 AND REQUEST KILL OUTPUT BUFFER 4 CLR CCFLGX, X CLEAR CTRL C FLAG 5 CMPB num XOFF IS INPUT A CTRL S BNE 69 NO, GO ONSTB GOFLGX, X BYTES SET STOP OUTPUT FLAG 6 CMPB num XON IS INPUT A CTRL 07 BNE 7 NO.GO ONCLR QOFLQX,X YES, CLEAR STOP FLAG 7S CMPB num SI a IS INPUT A CTRL 09 BNE 9 NO, GO ON 8 TST KILLOX,X IS AN OUTPUT BUFFER KILL REQUEST ALREADY GUBMI 9 YES, GO ONLDY PUSHDX,X a REQUEST OUTPUT BUFFER KILLSTY XKILLOX,X 9 LBRA WATCH CHECK FOR FLAGGED INPUT MODE .SBTTL TERMINAL INPUT INTERRUPT SERVICE ROUTINE FOR SELF TETHIS ROUTINE CONTAINS ABSOLUTELY NO FRILLSNO ERROR DETECTION IS INCLUDED a INPUT IS STORED IN THE CHANNEL S INPUT BUFFERBUFFER POINTERS ARE UNCHANGEDREGISTER X POINTS TO TOP OF RELEVANT POINTER TABLEREGISTER A CONTAINS THE CONTENTS OF THE ACIA STATUS REGISTEREGISTER B CONTAINS THE INPUT CHARACTER IRG INTERRUPTS ARE DISABLED DURING THIS ENTIRE ROUTINEINSELF LDY PUSHIX,X LOAD INPUT BUFFER POINTERSTB ,Y STORE CHARACTERLDA TRACE FETCH INTERRUPT STATUSORA XMARKXX MARK CHANNEL WHO DID ITSTA TRACE AND SAVE FOR SELF TESTRTI DONE WITH TERMINAL INPUT APPENDIX BNo. Product Term Active Level 111111 5432109876543210 76543210 O LHLLLLL LLLHH . AA . A. A 1 L H L L L L L L L H H H A A A . . A A A 2 L H L L L L L L H L H H A . A . . . . A 3 L H L L L L L H L L H H . A A . . A . A 4 L H L L L L L L L H L H H H A A A . . A A A 5 L H L L L L L H H H L H H H A A A . . A A A 6 L H L L L L L L H H L H H H A A A . . A A A 7 L H L L L L L H L H L H H H A A A A . A . A 8 L H L L L L L H H L H H A A . . . A . A 9 L H L L L L L H H H H H A A A A A . .A 10 L H L L L L H L L L H L . A A . . A . A 11 L H L L L L H L L H H L A A A . . A A A 12 L H L L L L H L H L H L A . A . . . . A 13 L H L L L L H H L L H L . A A . . A . A 14 L H L L L L H L L H L H H L A A A . . A A A 15 L H L L L L H H H H L H H L A A A . . A A A 16 L H L L L L H L H H L H H L A A A . A A . A 17 L H L L L L H L H L H L A A A A . A . A 18 L H L L L L H H H L H L A A . . . A . A 19 L H L L L L H H H H H L A A A A A . . A 20 L H L L L H L L L L L H . A A . . A .A 21 L H L L L H L L L H L H A A A . . A A A 22 L H L L L H L L H L L H A . A . . . . A 23 L H L L L H L H L L L H . A A . . A . A 24 L H L L L H L L L H L H L H A A A . . A A A 25 L H L L L H L H H H L H L H A A A . . A A A 26 L H L L L H L H H L L H L H A A A . A A . A 27 L H L L L H L H L H L H L H A A A A . A . A 28 L H L L L H L H H L L H A A . . . A . A 29 L H L L L H L H H H L H A A A A A . . A 30 L H L L L H H L L L L L . A A . . A . A APPENDIX B Cont. No. Product Term Active Level 111111 5432109876543210 76543210 31 L H L L L H H L L H L L A A A . .A A A 32 L H L L L H H L H L L L A . A . . . . A 33 L H L L L H H H L L L L . A A . . A . A 34 L H L L L H H L L H L H L L A A A . . A A A 35 L H L L L H H H H H L H L L A A A . . A A A 36 L H L L L H H L H H L H L L A A A . A A . A 37 L H L L L H H H L H L H L L A A A A . A . A 38 L H L L L H H H H L L L A A . . . A . A 39 L H L L L H H H H H L L A A A A A . . A 40 H A A A . . A 41 L A A A . . A 42 H A A A . . A 43 H A A A . . A 44 L L A A A . . A .45 H H A A A . A .46 L L A A A . . A .47 H H A A A . . A .L LOW INPUT H HIGH INPUT DON T CARE INPUTA HIGH OUTPUT . LOW OUTPUTINPUTS 12 7 CORRESPOND TO UNIBUS ADDRESS LINES A10 A5