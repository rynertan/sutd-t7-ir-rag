# Data translation apparatus translating between raw and compression encoded data forms.

## Abstract
Data translation apparatus incorporates a two stage adaptive single modeling approach using a state generating model structure unit 1 or 83 feeding a parameter generating unit which is associated with an encoder or decoder. Both units are adaptive, the model structure unit developing a reference context from a base state by up to a predetermined number of additional directed context states from inputs presented for translation. A count state table 35 is accessed for each symbol presented, the count being incremented and the first so many counts to reach a threshold value having their associated states incremented. Runs of more than a preset number of indentical symbols are separately detected and so signalled, the raw state superceding the table generated state.

## Claims
CLAIMS 1. Data translation apparatus of the kind referred to characterized in that the model structure unit 1 83 is adapted to modify a stored universal base context in discrete increments, up to a predetermined number of increments, in response to each discrete received raw data element or symbol and to output, to the adaptive statistics unit, a state indication in terms of the last received symbol and the resultant context structure. 2. Apparatus as claimed in claim 1 wherein the model structure unit for a symbol set of N elements, augments a single state universal base context by an additional directed context state as each of the first K l symbols to be received m times is received for the mth time, and outputs to the adaptive statistics unit 3 81 , for each received symbol, either the corresponding additional directed context state or, by default, the base context state together with the symbol in the case of the encoder form of the apparatus . 3. Apparatus as claimed in either preceding claim wherein the model structure unit is additionally adapted to detect that an input symbol is identical to the next previous r l input symbols and to generate a temporary run context state, superceding but not modifying the existing context, so indicating. 4. Apparatus as claimed in any preceding claim wherein the model structure unit includes a count table memory 35 having a location for each theoretical symbol containing a state field resettable to the universal base context state and a count field resettable to zero addressable in terms of input symbols on 5 , means 45 57 for incrementing the count field on each access, means for generating successive context state values, means 49, 51, 53, 57 for detecting that an accessed count field has attained a predetermined value and loading the corresponding accessed state field with the currently generated context state value and means not shown responsive to the generation of a predetermined context state value to disable the count field incrementing means and the detecting and state field loading means. 5. Apparatus as claimed in claim 4 including means 34 for storing the last input symbol, means COMP2 for detecting equality between the current symbol and the stored last input signal, means RUNCOUNT, COMP3 for detecting the presentation of a preset number or of a greater number of consecutive identical input signals and generating a run state signal on line 9 additional to and superceding the count table generated state signal.

## Description
DATA TRAt1SLATICK APPARATUS TRAD SLATING fiEIviEEN RAW AND COMPRESSION ENCODED DATA FORMS The present invention relates to data translation apparatus moving between a raw data form and a compressed data form.The invention has its seat in a unit which appears in the encoding form of the apparatus and in the decoding form of the apparatus since the one is, in effect the reverse of the other and thus, to simplify claiming the translation apparatus will be referred to as data translation apparatus of the kind referred to and this term implies apparatus which includes a model structure unit which is the unit with which we are concerned together with, in the case of an encoder, an adaptive statistics unit responsive to the model structure unit and to the current input to produce an input to an encoder unit, also responsive to the current input to produce a compression encoded output and, in the case of a decoder, an adaptive statistics unit and a decoding unit, the adaptive statistics unit generating the data output from, inter alia, inputs from both the decoding unit and the model structure unit. The problem solved by the invention as a whole is to produce a better form of translation apparatus than that that could be envisaged from a theoretical paper discussed hereinafter, such paper providing what can probably be regarded as the closest prior art. In broad terms, the prior art indicates the examination of an input extent at the encoder to select a model context in which to encode and subsequently to decode while the present invention assumes a universal base context which it continously modifies up to a limit in both encoder and decoder, the net result, if one can compare theory and practice, being nearly one level of efficiency higher. Langdon and Rissanen, Compression of Black White Images WithArithmetic Coding , IEEE Transactions on Communications, Vol. 29, No. 6,June 1981, describe a compression system having separate model and code units. The model approximates the statistical characteristics of the symbol source. Each symbol is simultaneously applied to the model and encoding units. Responsively, the model conditions the encoder with respect to encoding one or more subsequent symbols. A model comprises a finite state machine FSM and statistics of the symbol source. An encoder is also a finite state machine as for example described in Rissanen and Langdon, Arithmetic Coding , IBMJournal of Research and Development, Vol. 23, No. 2, March 1979, at pp.149 162. Together, the model and encoding units execute a coding function. In this regard, a coding function maps each string in a source alphabet to a counterpart string in a code alphabet. To reduce computational complexity, the mapping of an arbitrarily long source string is not made to its image in the set of code strings in a single step. Rather, most coding functions are recursive in that the next function value depends upon the instantaneous function value, source symbol, and other attributes. Typically, a function consists of a series of operations, applied to each successive symbol of the source string from left to right. In order to be physically realizable, recursive functions have a finite amount of memory. Encoding and decoding functions are both performed by FSM s. For each encoding or decoding operation, the FSM accepts an input, delivers an output, and changes its internal state. The coder accepts a string of source symbols, one at a time, and performs an invertible transformation into a code string. Since the model and the coder are distinct FSM s, the model state is distinguished from that of the encoder state. In the design of a lossless data compression system, the source is initially modeled and then a code is devised for the modeled source.Illustratively, consider the natural alphabet in which strings are written consisting of eight bit binary symbols or bytes . Rarely do all 256 possible symbols for an eight bit byte appear in any given sequence. Depending upon the symbol source, only a minority in the order of 40 to 80 characters commonly occur. This permits an economy of internal states and memory size to be made. If the probability of generating any source symbol were completely independent of any previous source symbol, then the source is said to be a zero order MARKOV memoryless source. However, a memoryless source is rare, and more frequently the source symbols may exercise an intersymbol influence. This is reflected in sets of conditional events and probabilities. A more general information source with n distinguishable symbols is one in which the occurrence of the source symbol is affected by a finite number of m preceding symbols. Such a source is termed an mth order MARKOV source. For an mth order MARKOV source, the conditional probability of emitting a given symbol is determined by the m preceding symbols. At any one time, therefore, the m preceding symbols define the state of the mth order MARKOV source at that time.Since there are q possible symbols, then an mth order MARKOV source will have qm possible states. As symbols are emitted from the source, the state changes. Thus, for a 256 symbol alphabet, a second order MARKOV source or model thereof would require 2562 64,000 states.For this reason, higher order MARKOV modeling is frequently impracticable. The aforementioned Langdon, et al., reference describing blackwhite image compression discloses a two stage modeling in which the first stage is a neighborhood template for identifying the context which in turn identifies conditional probability distribution of the next pel to be encoded given the instantaneous pel. The notion context or conditioning class is a generalization of state . The actual statistics or counts determining the distribution in either case are derived on the fly from the input pel stream. That is, there exists a fixed model of the symbol source conditioning class or context and an adaptive modeling of the conditional probability distribution within each context within one pass of the data. In the past, attempts to manage first order MARKOV model requirements were handled in diverse ways. For instance, Mommens and Raviv, Coding For Data Compaction , IBM Report RC5150, Nov. 26, 1974, describes the use of a first order MARKOV model for decomposing a higher order character stream into a multiple of lower order character streams.This involved multiple passes. The first pass ascertained the conditional probability of a first full first order MARKOV model of the symbol stream. The number of states was reduced by forming equivalence classes having approximately equal conditional probability distribution.A compression code was then formed for each equivalence class. A second pass assigning the code to the symbols was required. Lastly, Arnold, et al., U.S. Patent 4,099,257, used a fixed partial first order MARKOV FSM to context encode characters common to two alphabets. For instance, if a t was always lower case, it would be encoded as an upper case t if the symbol preceding it was a The present invention provides data translation apparatus of the kind referred to characterized in that the model structure unit is adapted to modify a stored universal base context in discrete increments, up to a predetermined number of increments, in response to each discrete received raw data element or symbol and to output to the adaptive statistics unit a state indication in terms of the last received symbol and the resultant context structure. Although it was known that increasing the number of contexts or conditioning classes would enhance the fidelity of the model to the source symbol statistics, it was unexpectedly observed that a two level adaptive model could substantially approximate a full first order MARKOV model of a symbol source. At the first level, the conditioning contexts themselves are generated in an adaptive manner. At the second level, for each selected conditioning context, the symbol statistics are determined adaptively as the string is being encoded. The only predetermined aspect is the maximum number of conditioning states. Thus, to each state there corresponds a probability distribution for the next symbol which depends only on that state.State selection is accomplished in one pass by the steps of initially assigning all symbols to a single lump state for conditioning purposes and then adding frequently occurring symbols or strings thereof as additional conditioning states as a result of satisfying a selection criterion. As soon as a state has been created, the second adaptive process of determining the conditional state dependent probability distribution can begin. Indicators of the state dependent probabilities are passed to the coding unit as needed. More particularly, such an arrangement may adaptively model a high order MARKOV source using a preselected maximum number of states for data compression within a fixed implementation complexity by 1 ascertaining the first k l symbols, the parameter k not exceeding the alphabet size N, which occur a preselected number of times, M 2 pairing each of the k states, formed by the k l distinguished symbols and the lump state, with the next symbol and determining a conditional probability distribution associated therewith and 3 passing parameters indicative of the distribution to an extrinsic compression coding process. Clearly, the double adaptation permits single pass compression and a partial first order modeling using less memory than that required for a full first order model. If a first order model of N symbols required a table size to hold the nxn probabilities, this invention needs only kxn. For an eight bit byte or 256 symbol source having only 49 distinguished symbols, n 256 and k 50, and kxn 12800 while nxn 65536. The technical advance is to fix the number k and then find the k l most useful characters to act as states contexts . The k th context is where all remaining characters are lumped , and some additional states may be reserved for special run states. In order for a state to be considered useful , the state should occur frequently, and it should have a skewed conditional probability distribution for the next symbol. This latter requirement provides a low conditional entropy for said next symbol. Although these two requirements may be conflicting, it has been found experimentally that whenever compression is possible with first order MARKOV models, the most frequently occurring symbols also tend to have low conditional entropy. The terms symbol and state are used in several senses.Firstly, a symbol selects the state of the model. At the least, a symbol is a member of the lump state. Secondly, a symbol is an encoded object in its own right we sometimes refere to this role of the symbol as the next symbol, or we say that the symbol occurs in the state determined by the selected symbols. The invention will be described further by way of example with reference to embodiments of the apparatus as illustrations in the accompanying drawings in which FIG. 1 is a block diagram of one form of translation apparatus in the form of a compression sub system including a two stage modeling unit, FIG. 2 is a block diagram of another form of data translation apparatus in the form of a decompression subsystem, and FIG. 3 is a diagram the detailed logic of the adaptive context for model structure unit of either sub system.Theoretical Concerns A model consists of a structure and a set of probability parameters. The structure is defined by a finite set of contexts. The set of all finite strings s x l , x 2 ... of the symbols in an alphabet S is partitioned into contexts or conditioning classes. The notion context is a generalization of state . There exists a general recursive function f, which maps each string s to its context z f s . Associated with each context z, let i z denote a set of probability parameters, i.e., non negative numbers which add up to 1. Collectively, the parameters for a context are called the statistics. The model statistics function assigns P i f s as the conditional probability of the symbol following string s to be symbol i, given the context f s .The set of the contexts, or, more precisely the function f, together with the sets P i z defines a stationary model when P i f s depends only on the context f s and symbol i. With respect to adaptive statistics for a structure function f, let s z be the succession of symbols of string s which occur at context z.An adaptive function alpha recursively generates the conditional probability P i z,s z as a function of the string of the symbols at the past symbol occurrences of the context z in s Adaptive statistics alpha i,s,f s P i z,s z . This formulation is a two step process. The first step is the evaluation of the model structure function f which determines the context z for each symbol. The second step is the evaluation of the model statistics function which determines P i z,s zi for symbol i and the past history in its context. Adaptations for the statistics function involves in formation from the prior string s. In most configurations, alpha involves a counting mechanism in order to determine the relative popularity of the symbols. In bit oriented strings, the adaptive statistics may be reduced to a binary choice. In the above formulation of adaptation, each context is treated as an independent symbol source. Past symbols which occur in contexts other than z do not affect the assignment of the probabilities conditioned on z. In both the stationary and adaptive statistics models, the total number, k n l , of probabilities gives the complexity of the model. In this regard, k denotes the number of contexts and n the number of distinguishable symbols. Complexity clearly measures the size of the working tables that both an encoder and a decoder must access as a code string is being processed. This information may be viewed as being organized into k subtables of n l words where each word includes a coding parameter parenthetically, the complexity of the stationary and adaptive models so far considered is a function of the cardinality of the alphabet and the set of contexts. It is independent of the source symbol string. Structure f may be embodied by way of a finite state machine. In that case, it is desirable to distinguish between a state and context.However, the complexity of the model depends on the number of conditioning contexts, which may be less than the number of internal states of the FSM.Adaptation of Contexts Previously, adaptation was always restricted to an estimate of the conditional probabilities p i z,s x . It is considered to be a generalization of the statistics function. A first order of MARKOV model of a byte wide source symbol alphabet has 256 possible conditioning states. A limit kF256 of the distinct contexts that are allowed to occur on any string is equivalent to stating that k is the cardinality of the range of the model structure function f. It is possible to determine for each string, the maximum of k best contexts as the string is being encoded. This means that the effective complexity of the model is k n l as compared with n n l , which is the complexity of a full first order MARKOV model. Each value for a byte may be viewed as a leaf of a completely balanced binary tree of depth 8. The 256 leaves define the bytes. For each byte value, there is a unique path from the root to the leaf. The i th branch is selected by the value of the i th bit. Starting at the root and following the path defined by the byte, it is possible to maintain and update a corresponding branch count at each internal node passed. To form an FSM, each internal node corresponds to a state. As described in D. Knuth, The Art of Computer Programming , Vol 1,Fundamental Algorithms, Second Edition,, Addison Wesley, 1975, the path to a node defines the address of the node while its son s addresses are given by doubling the parent address for one son, and incrementing the double parent address by one for the other son.It is observed that each bit s statistics are conditioned on a joint context formed by two components. The first component is determined by structure function f which designates the context or conditioning class. To each context z, there corresponds a subtable of words. The second component for the bit s context is the internal node of the depth 8 binary tree. The node corresponds uniquely to the bit position within the byte and the previous bit values of the byte. Thus, the total context on which the binary events are conditioned consists of the adaptively determined symbol context z together with the prefix of the byte being processed.In order to update and maintain the statistics of each contextual binary symbol, the adaptive strategy produces two counts c 0 s and c l s for each binary symbol in the string. There is a computational advantage to control the value of the lower count, denoted c L s . Let L denote the less probable symbol while L is the more probable symbol. If the opposite symbol L is observed, the larger count c L s is updated by one to form the count c L s.l , where s.L means symbol L which is concatenated to string s. The lower count stays at one. Also, if the next symbol is L, there is no updating of c L sL into a value such as 2. Instead, this same ratio is obtained by halving c L sL . Should c L sL become less than one by this halving, it is rounded to one and the roles of the low probability and high probability symbol L and L are switched.Finally, the adaptive statistics function alpha summarizes the higher count c L s as a skew number K s . The skew number is an integer control parameter outputted from the second stage of the model unit an applied to the coder. This has been described in Helman, et al., Arithmetic Compression Code Control Parameter Approximation , IBMTechnical Disclosure Bulletin, Vol. 23, No. 11, April 1981, at pp.5112 5114. At this point, the count is converted to skew as follows Count 1 gives the skew number 1, Counts 2 and 3 give skew number 2,Counts 4, 5, 6 and 7 give skew number 3, etc. That is, the skew number increases as the log of the Count c L s . The adaptive strategy approximates the estimated ratio c L s c L s c L s by the special probability 2 s , and delivers the statistics of the symbol to be encoded in the form of a skew L s ,K s .Run Mode In order to encode runs using a single skew to describe the event of whether the symbol repeats or not, it is necessary to define a context within which to encode runs. Thus, a run mode may be defined whenever a symbol occurs r times in a row. Typically, r is taken to equal to 3. When not in run mode, the symbol may be considered in the symbol mode. When the last three symbols encoded have the same value, then the run mode is entered and the next event encoded means either continue or stop the run. If the event continue is encoded, the last r symbols have the same value while the next event occurs under run mode. The Count c L s is updated each time. The encoding process for run mode continues for each repetition of the symbol until the event stop is encoded. After the stop event, the run Count C L s is halved.The symbol mode is then entered. The symbol which stopped the run is encoded under the context of the previous run symbol. So far, there has been described a condition under which it is possible to enter the run mode. Also described was a method for encoding each repetition of the symbol using adaptive statistics gathering as for any other binary event encoding. However, it is necessary to locate the count value c L s when in the run mode. In one implementation, if a coding parameter table requires an 8 bit address, this consumes 256 words. However, word zero of the table may be unused. Therefore, a spare word in the subtable for each symbol context can then be assigned to the run mode. Consequently, in symbol mode one of the 255 words corresponding to an interior node is addressed beginning with the word one . The previously mentioned doubling technique is used to walk down the nodes of the tree.In run mode, word zero of the table is addressed, since only words 1 through 255 are used for the 8 bit bytes. Referring now to FIG. 1, there is shown a block diagram of a compression subsystem. Source 2 generates a symbol which is concurrently applied to the model structure unit 1, the encoding unit 17.Unit 1 responsive to the symbol determines its conditioning state. This information is passed to the adaptive statistics unit 3 along with the symbol. The ASU maintains the statistics conditional probability distribution for each state in an adaptive fashion on a bit basis. The symbol is encoded a bit at a time via the linearized tree structure described in Langdon, et al., Deblocking Method For Use With AnAdaptive Arithmetic Encoder Decoder , IBM Technical Disclosure Bulletin,Vol 23, No. 6, November 1980, at pp. 2528 2529. The linearized tree entry described in this reference provides the adaptive skew information discussed in Helman, et al. The tree entry is a count field c L s for the more probable symbol L , and a bid for theL value. The position of the leading one bit of the count field indicates the skew value. The bit value in the symbol to be encoded is compared with the L value in order to generate signal ISLPS on path 15 coupling the ASU 3 to encoder unit 17. Encoder unit 17 encodes the bit to the working end of the code stream, in accordance with the method set out in Langdon, et al., U.S. Patent 4,286,256, Method and Means forArithmetic Coding Utilizing a Reduced Number of Operations , issued 25Aug 1981. Thusly, the encoder unit passes a variable length string with its concomitant parameters such as carry, shift amount and strobe values over dedicated paths 23, 25, and 19, to a variable to fixed length buffer 27. Buffer 27 preferably includes a logic for blocking the encoded string. Carryover control in buffering is described in copending Langdon, et al., U.S. Patent application USSN 048,318 filed 14 June 1979, and entitled A Method and Means for Carryover Control in HighOrder to Low Order Pairwise Combining of Digits of a Decodable Set ofRelatively Shifted Finite Number Strings . Referring now to FIG. 2, there is shown a decompression subsystem.A fixed variable buffer 75 accumulates the code string over paths 29 and 31. The buffer 75 provides the decoding unit 79 with the working end of the compressed code string. The decoder receives the skew for each bit from the local ASU 81. The ASU 81 uses the state designator supplied by the local model structure unit 83 which determines the conditioning states of the next symbol to be decoded. On each subcycle, the decoding unit decodes another bit. In symbol mode, every eighth bit decoded changes the conditioning state being used by the ASU. Referring now to FIG. 3, there is shown one implementation of the model structure unit of either embodiment. Since more out signals are required in the case of compression ie SYMB LSBQ than are required in the case of decompression only STATES RUN STATE , the implementation is that for compression but an identical unit can be used for decompression, unwanted outputs being ignored. A 256 word table 35 includes one word for each distinct symbol value. The Count Table is involved in the determination of the conditioning context under which the symbol is to be compressed. As may be recalled, corresponding to each conditioning context, there is associated a conditional probability distribution located in ASU 3 or 81. However, the model structure unit must pass to the ASU a parameter identifying the conditioning state.The symbol value which addresses the Count Table determines the state for encoding the symbol following the instantaneous symbol. Each Count Table word includes two fields, namely, a count field and a state field. The count field represents the count occurrences of the symbols corresponding to the address. The state field contains the state designator for the symbol. When a word is read, these fields are respectively stored in register 45 count and register 43 state . The count register is a parallel loading register that can be counted up or incremented. The count field is used to count the symbol instances in order to determine the more popular symbols. The lump state has state designator zero . All symbols are initially compressed in that state. States are created by assigning a designator to the popular symbols. Each symbol to be compressed causes an access to the CountTable. The value in the count is incremented and then compared to a system controlled parameter N in register create 49. When a symbol count reaches the value in the create register such as 50 as determined by comparator 51, it is then assigned the next available unassigned state designator from register assign 61. The assign register is initialized to one . This is the next state designator to be assigned to a selected conditioning symbol. The state designator for the symbol is the value read from the Count Table Memory. Following the incrementing of the count and selection of the new designator from the assigned register, the new count and state designator are rewritten to the Count Table Memory. Following the creation of a new conditioning state, the assigned register is incremented. When the assigned register is incremented beyond the maximum number of allowable conditioning states, the count and assign mechanisms are disabled. From this point to the end of the symbol sequence, the state designators in the Count Table remain the same. Alternatively, the count and assign mechanisms could be reinitialized, say, every 4000 bytes. The run mode should now be considered. When a new symbol is stored in register symbol 33, the previous symbol value is stored in register LASYMB 34. The present and the previous symbols are compared in comparator COMP2 and if equal the run count register is incremented.This value is compared COMP3 with a predetermined value r, for example 3, and if greater than or equal, the structure is placed in run mode. When run mode is entered, the run event encoded begins with the symbol following the symbol in the symbol register which caused the run mode. At the beginning of a symbol cycle, a new value of symbol arrives.This is passed on to the ASU. This symbol is to be encoded under the state designator or context determined by the previous symbol. For this determination, the previous value in the symbol register was used to access the Count Table Memory in order to determine the state for the current symbol. If the conditions are met for the run mode, this takes precedence over the symbol mode. However, the ASU still uses location zero of the adaptive Count Table for the skew of the run. For each symbol cycle of the model unit 1, the ASU typically undergoes eight cycles. That is, one cycle for each bit of the 8 bit symbol. In run mode, the ASU undergoes one cycle, if the LSEQ last symbol equal 11 is active and nine cycles if it is inactive. In the nine cycle case, the first cycle indicates the end of the run and the next eight cycles encode the value of the symbol which broke the run. The model unit 1 passes the symbol to the ASU over path 5 from register 33. Run state information is passed from comparators COMP2 and COMP3 over paths 11 and 9 while the next non run state is passed frcm register 43 over path 7. Note that the updating of the count and state and assignment registers with respect to the contents of theMemory 35 is by way of logic element 57. The contents of the 4 bit state and assignment registers are multiplexed over unit 53 and concatenated with the 6 bit contents of the count register 45 to form the 10 bit word on path 59. The model structure unit supplies the symbol state or run mode indication and thus indicates which 256 word subtable is to be used by the ASU. In symbol mode, the ASU progresses through the indicated subtable and retrieves and updates each subtable word as previously described. The subtable word is used to determine the skew L s ,K s , which is passed to the compression encoder or decoder. In run mode, theASU retrieves and updates word zero of the indicated subtable. The arrangement can be used with any compression encoder or decoder capable of encoding decoding events under control of a parameter or suitable adaptive or nonadaptive approximation to the symbol of probabilities, including such adaptive Huffman code units as described by Gallager, variations on a Theme by Huffman , IEEE Transactions onInformation Theory, Nov. 1978, pp. 671 673. Decoding is executed event by event with the coding parameters for the next event supplied by the same ASU as for the encoder. In Gallager, the coding parameter is a set of codewords, determined for decompression as for the compression phase by the same two step process. That is, the structure function f assigns each byte to a context f s and to a symbol or run mode. Next, the statistic s function alpha accesses and updates the proper subtable to determine the coding parameter. As hereinbefore described, this invention does not depend on predetermined statistics. By using the most popular symbols as first order conditioning states, significant compression can be obtained within a memory constraint. It should further be appreciated that the invention requires only one pass on the data. This is accomplished despite the double adaptation in which 1 a model structure unit adapts by selecting and using popular symbols as conditioning contexts, and 2 the adaptive statistics unit adapts to the skew number for each bit.