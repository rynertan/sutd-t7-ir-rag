# HIGH PERFORMANCE COMPUTER SYSTEM

## Claims
Paralleles Prozessorsystem,

## Description
The invention relates to a parallel processor system according to the preamble of claim 1. In the past, data processing systems utilizing parallel processing have met with limited commercial success. Consider, for example, the Illiac IV, designed by Burroughs Corporation. The Illiac IV utilizes an array of 64 processors, each with a local memory, operating in parallel with each processor executing the same instruction. This is known as a single instruction stream multiple data stream SIMD system. The Illiac IV is a very powerful computer and has been used to solve difficult scientific problems such as those involving fluid flow. The Illiac IV system is difficult to program because of the SIMD architecture. A more important disadvantage, however, is that the system lacks reliability. The mean time to failure is measured in hours. Another SIMD system is described by Hillis in EP A 0 132 926 which shows an array processor having a hypercube topology, using a common clock and a central instruction fetching executing facility which is common to all nodes of the array. HILLIS uses synchronous communication between processor memories. Computing is halted, then all processor memories that want to communicate do so during a routing cycle set aside for that purpose. Computing is then resumed during a cycle set aside for computing. There are 32 processor memories fabricated on each chip. A common Communication Interface Unit CIU is also fabricated on the chip. The CIU and a routing circuit control the flow of message packets between the processor memories. A single instruction is issued from a single instruction stream stored at the computer to all nodes simultaneously. Each node receives the instruction and latches the instruction into a latch. A PLA decoder decodes the instruction and in accordance with its code, reads data from the local memory for manipulation by the ALU. During an execution cycle, all nodes of the parallel array are executing the same instruction replicated at the many nodes but each node operates on different parts of the whole data. The instruction stream is received from a common memory in the computer, and is not received from the local node memory RAM . The RAM only stores data, it does not store instructions and there are no means at each node for fetching instructions from either the local memory RAM A multiple instruction stream, multiple data stream MIMD approach to parallel processing is used in the COSMIC CUBE, described in the following publications A node in the COSMIC CUBE is made up of an Intel 8086 processor and Intel 8087 coprocessor or an Intel 80286 processor and Intel 80287 coprocessor. In either case, each Intel 8086 or 80286 processor is fabricated on a single chip that is driven by its own internal clock. Each chip is made up of a processor and a memory. Data are transferred between chips over a data bus subject to arbitration control. Data are routed between nodes via communication means that, like HILLIS, are under a synchronizing control which is external to the nodes. Other parallel systems have been built for specific applications and would not be useful in more general, scientific applications. The high performance data processing systems that have been successful fall within one of two categories. The first category are those that are very high speed uniprocessors that are heavily pipelined. The second category are special purpose, inexpensive array processors that off load data from a general processor for scientific processing. The Cray 1 and Cyber 205 fall within the first category, and the Floating Point systems AP 120 falls within the second category. These prior systems have several disadvantages. For example, the Cray 1 system approaches the limits imposed by physical constants. Wires must be kept short and the processor must be tuned to get full performance. Programs must be vectorized to take advantage of the pipeline structure. If this is not done, the Cray 1 will run much slower than its maximum speed. Finally, because of its size and sensitivity, the Cray 1 requires expensive, special handling such as reinforced floors, liquid cooling, and hand tuning. The second category of prior systems array processors is also subject to the physical limits imposed by the speed of the single or small number of processors that make up the array. Current attempts to utilize the multiple instruction stream, multiple data stream MIMD approach to parallel processing runs into two significant problems. The first is that by using standard emitter coupled ECL circuits, the size of the system is limited by reliability constraints, and therefore such a system would not be operable with tens or hundreds of processors. In the past when large arrays such as the Cosmic Cube have been attempted, they have failed to perform reliably because of barriers having to do with clock skew. Clock skew results in errors at one node caused by data lost during transmissions from another node. This is because each node is driven by its own internal clock, and these clocks do not operate at exactly the same frequency which is the cause of the clock skew. The second problem is that current systems use a single memory shared by all the processors. This has the advantage of allowing a programmer to keep all of the data in one memory, but has a major disadvantage of limiting the system performance to the bandwidth of a single computer system. It is the object of the present invention to provide a new data processing system utilizing parallel processing, with a system performance that is above the level of modern supercomputers, but is within the price range of a small mainframe computer. The above object is a accomplished in accordance with the invention by a parallel processor system comprising a plurality of first processing nodes, each of said first processing nodes including a processor and a memory, said memory having data and instructions stored therein, each of said processors including execution means for executing said instructions, and means connected to said execution means and to said memory for fetching said instructions from said memory, characterized in that a clock is common to all of said processing nodes, each of said processing nodes further includes internode communication means connected to said execution means and to said memory and, first means, connected to each of said internode communication means of said first nodes, for interconnecting said first nodes in the structure of a first array of processing nodes, said first array having a hypercube topology said internode communication means comprising an I O channel connected to and driven by said clock. The invention has the advantage that because of the unique relationship between the common clock and the I O channels for internode communication at each processing node, the invention achieves a result that is a significant advance over what is taught by the prior art. By using I O channels to interconnect the nodes, the apparatus is capable of communicating the results of operations between nodes without having to wait for a special clock cycle as required by HILLIS. In the past when large arrays have been attempted, such as the Cosmic Cube, they have failed to perform reliably because of barriers having to do with clock skew. Clock skew results in errors at one node caused by data lost during transmissions from another node. Using an I O channel at the nodes that are driven by a common clock as the internode communication mechanism has broken the theoretical limits. By fabricating on a single chip serial communication channels, memory interfacing logic, and all CPU functions including high speed, double precision floating point arithmetic, the component count is reduced to a minimum, thus reducing size and increasing the reliability of the system. By using arrays of processors with local memory, physical limits imposed on a single processor, or single memory system, are avoided and performance can thus be increased by simply adding processing nodes. A unique advantage flows from utilizing the hypercube topology, which consists of interconnecting all corners of an N dimensional cube. Since the number of interconnections per processor grows as Log 2 N , the distance across an array only grows as Log 2 N . The number of interconnections in a prior art array grows as SQRT N . Thus, random communication between nodes is much faster on a hypercube than on any array using a fixed number of interconnections per node. The hypercube is a recursive array since an N 1 dimensional array is constructed by interconnecting two N dimensional arrays. This makes it easy to partition a large array into smaller arrays for multitasking. Furthermore, since a small array is logically equivalent to a larger one, software can be written to run on any size array. This allows for very effective multitasking without programming overhead for task switching. This also results in highly reliable systems that gracefully degrade in the event of processor failures. Almost all high performance systems suffer from being I O bound that is, they compute so fast that moving data into and out of the system causes a bottleneck. In the present invention, the I O bind is alleviated by including an extra serial channel on each processor to handle system I O. This structure results in a very high I O bandwidth and improved fault tolerance. Since each node is accessible through the I O system, even if several processors fail the remaining processors can be logically reconfigured into an operational array. For background information see The Extension of Object Oriented Languages to a Homogeneous, Concurrent Architecture , Thesis by Charles Richard Lang, Jr., Computer Science Department Technical Report Number 5014, California Institute of Technology, Pasadena, California, May 24, 1982. The terms, syntax notation, etc., used in this specification conform to IEEE standards. Information about Ncube products referred to in this specification can be obtained by writing to Ncube Corporation, 1815 NW 169th Place, Suite 2030, Beaverton, OR 97006. Information about Intel products referred to in this specification can be obtained by writing to Intel Corporation, 3065 Bowers Ave., Santa Clara, CA 95051. The architecture of the system in which the present invention is embodied uses up to 1024 identical high speed processors processing nodes connected in an array to work on a single problem. Each node is a general purpose processor with 128K bytes of local ECC memory. There are 8 I O channels providing input to and output from the processing array. When a processing node fails the system can continue operation on a subset of the array with reduced performance thus providing fault tolerance through graceful degradation in addition to reliability. The array is interconnected in a recursive topology called a hypercube see Section 3.2 that can be divided into subarrays of 64, 128, 256, or 512 processors. The software can easily adjust to the number of processors in the system. One job can run on the entire array or several jobs can run at once on subsets of the array. This space sharing avoids the constant swapping overhead that occurs in conventional time sharing systems. The modularity of this design enhances extensibility. Simply by rewiring the backplane, the architecture can support a larger array. Also by connecting systems together with an Interprocessor Link it is possible to use multiple systems in parallel or as a very powerful pipeline. One embodiment of a system in which the principles of the present invention are practiced is described in detail in Part II of this specification. Briefly, it consists of an air cooled enclosure containing a backplane with up to 24 boards, a disk tape subsystem and power supplies. The backplane 16 shown in FIGURE 1 uses 16 slots to support a processor array of up to 1024 processors, each with 128K bytes of local memory. The other 8 slots are used for I O. Each I O slot is connected to a different subset of 128 processors in the array. Each processor node in the processing array has a 1 2 Megaflop floating point operations or 2 MIP integer operations processor. Thus a fully loaded system with 1024 processors has a potential performance of 500 Megaflops or 2000 MIPS. Each I O bus into the array consists of two unidirectional data paths one inbound, one outbound that operate independently and in parallel. Each path can transfer data at up to 140 Megabytes sec. The processing array consists of processors with local memory interconnected in a topology called a hypercube. One way to describe a hypercube is graphically. Hypercubes of low order can be illustrated as shown below circles are nodes and lines are communication links Another way to describe the hypercube is by a recursive definition. Each processor has a label that is a binary number. Two processors are connected if their labels differ in only one place. The low order hypercubes are listed below From an order N 1 hypercube it is very simple to define an order N cube. The N 1 hypercube will have nodes labeled as shown First another N 1 hypercube is constructed with nodes labeled And then all N 1 connections between the two N 1 hypercubes are made so that every pair of node labels that differ only in their most significant bit are connected e.g. 010...01 must be connected to 110...01 . This formulation of the hypercube illustrates two of its most important properties This allows for several beneficial features These advantages are not available in a typical toroidal grid lattice type of interconnection scheme. But since two and three dimensional grids are very useful in many applications, it is important to note that a hypercube can be mapped onto either grid simply by ignoring some of the available communication links. At least one System Control board 14 , shown in FIGURE 1, must be installed in every system and there can be up to 8 per system. Its primary purpose is to run the operating system described in section 5.3, including the cross compilers, assembler and linker and to control a wide range of peripherals. It uses an Intel 80286 with 4 Megabyte of memory for the operating software. There are also four sockets for an EPROM that contains the monitor and diagnostics software described in section 5.2. In addition to the main Intel 80286 processor running the operating system, the System Control board has eight RS 232 serial ports and one high speed printer port. It has the logic to control up to 4 SMD disk drives and three Intel iSBX multimodule connectors. These multimodule connectors support options such as tape drive controllers, ethernet interfaces and interboard buses for I O boards . This bus allows for users attached to different System Control boards to access a common file system that is spread across several disk drives controlled by different controllers. A block diagram of the System Control board is shown in FIGURE 12, and is described in detail in section 8.9. The sections below describe the architecture of the System Control in more detail. The central processor of the System Control is an Intel 80286. This is a high performance 16 bit processor that has a compatibility mode with the Intel 8086. In addition it can address 16 megabytes of memory and has memory management and protection built into the chip. It is the host for a multitasking multiuser operating system. For more details on programming the Intel 80286 see Intel s iAPX 286 Programmer s Reference Manual, which can be obtained from Intel Corporation, 3065 Bowers Ave., Santa Clara, CA 95051. The System Control has 8 sockets for PROM 72 which may be loaded with devices from Intel 2764 s up to Intel 27512 s. The PROM resides at location F80000 to FFFFFF in the Intel 80286 memory space. Since these are byte wide devices they are arranged in 2 banks with the following addresses. The PROM s are programmed by and contain a monitor described in section 5.2, that includes the following functions There is a local array interface 212 of 16 processing nodes on the System Control Board. Each node consists of a processor and 128 Kbytes of RAM. This memory is triple ported since it can be directly accessed by the local processor, the Intel 80286 and the SMD disk controller. All Intel 80286 and disk controller accesses to these local memories are 16 bits only. The main purpose of this array 214 is to provide communication an I O bus with the main Processing Array. Thus, 8 of the 11 channels on each node are dedicated to providing communication between the Processing Array and the System Control. The nodes on the System Control board are numbered 0,1,...,15 and their local memory resides in the Intel 80286 address space according to the table below. Since the local processing nodes on the System Control each have 3 communication channels uncommitted to I O, they are interconnected in two order 3 hypercubes. That is, nodes numbered 0,1,...,7 form one hypercube and nodes numbered 8,9,...,15 form another hypercube. This allows users to test their programs on the small hypercubes on the system control board before loading them into the main array, thus offloading most debugging tasks. It may appear that since the two hypercubes are not directly interconnected it would be difficult to move data from a node in one cube to a node in the other. However, since all the memory is in the Intel 80286 memory space, it is simple and fast to use the central processor or the DMA processor to move the data. There are three Intel iSBX connectors 78 on the system control board. Intel and other companies make a wide range of small boards for the SBX I O bus. There are boards for high speed math, graphics, tape drive controllers, floppy disk controllers, network controllers, etc. If a system contains more than one System Control then one of the SBX connectors on each board is reserved for implementing a local bus so that the operating system, and particularly the file system, can be spread over the disk drives controlled by all the System Controls. Thus a user need not be concerned with to which board a terminal is attached. The devices that are inserted into the SBX connectors appear to a programmer as locations in the 80286 I O space that can be read from and written into. They can also be controlled by the Intel 82258 ADMA Advanced Direct Memory Access chip. The boards can generate interrupts to the Intel 80286 for details on interrupts see section 3.3.2.1.10 . The data that is read or written can be either Byte or Halfword and each SBX connector has 32 reserved I O addresses 3 bits of address and 2 bits of chip select as shown below. There are two types of SBX devices, 8 bit and 16 bit, but both boards have the equivalent of two 8 bit registers that are activated by the chip select bits MCS0, MCS1 . The following table contains the data transfer details. The Device and Data columns refer to the number of bits in the device and in the data to be transferred respectively. There is one high speed printer I O port on the System Control Board. It supports the Centronics protocol with 8 bits of data and 4 bits of status. It is intended for a high speed peripheral such as a printer or plotter. It is in the I O space of the Intel 80286 at location 14 and also has DMA capability since it can be controlled by the Intel 82258 ADMA device 80 . When accessing this address the system performs the following functions. When Reading, bits 12 to 15 yield general system status, not printer status. The System Control Board has an Intel 82258 ADMA device 80 that controls the Direct Memory Access in the system. It is specifically intended to control the 3 SBX connectors and the Centronics parallel port. However, it is a very powerful processor and can control other DMA functions in the system including moving blocks of data in memory. Refer to Intel s 82258 Manual for details. The Intel 82258 has 4 DMA channels and each channel has a set of registers associated with it. Also there is a set of global registers. All of these registers are in the Intel 80286 I O address space as shown in the table below. The Channel Registers can be written by setting the Command Pointer to point to a command block in memory and then giving the Intel 82258 a START CHANNEL command from the Intel 80286. The format of the command block in memory is shown below The System Control Board shown in FIGURE 12 has 8 serial channels that are controlled by four Intel 8530 Serial Communications Controllers 82 , each device handling 2 channels. Each 8530 also has two baud rate generators and interrupt generation logic. There are a set of control Write registers and a set of status Read registers for each channel. The registers are all 8 bits and all accesses are byte only. A summary of the register functions is listed below unless noted two copies of each register exist, one for each channel The only registers that can be directly addressed in the I O space of the Intel 80286 are the two Data registers RR8 and WR8 and RR0 and WR0. In order to read or write any other register requires two steps 1 write the appropriate code into WR0 then 2 perform the read or write operation. After doing this, bits 0 through 4 of WR0 are automatically cleared so that WR0 points to WR0 or RR0 again. The I O addresses corresponding to the 8530 devices and the I O channels are listed in the table below. Each channel can generate four interrupts to indicate the conditions Tx empty, Status Change, Rx Ready and Special Rx. The interrupt vector addresses assuming the given vector bases are used are also listed below. To obtain the interrupt numbers divide the vector address by four. Each Serial Channel Controller 82 has an integrated baud rate generator that depends on the setting of a Time Constant, supplied by real time clock 84 . The equation and a baud rate table are given below. The System Control has an SMD disk controller unit 216 . It is capable of controlling up to four standard SMD disks drives. Data is accessed in blocks of 1024 bytes at a rate of 1 Megabyte per second. The disk controller unit consists of 6 registers in the I O address space which are described below. In addition to the registers listed above there are two more I O addresses and an interrupt associated with the disk controller. Writing to the I O addresses causes the disk controller to be enabled or disabled. Reading from these addresses yields a system ID see 3.3.2.1.10 . The interrupt indicates that a disk access has completed. The addresses and interrupt number are given below. There is a set of I O addresses associated with various aspects of system control. The controls include power supply monitoring and sequencing, error sensing and signaling, and board resets. All of the addresses and controls are described below The system contains sixteen temperature sensing devices located throughout the enclosure. They are used to prevent system damage caused by over heating. In order to trigger a sensor and take a measurement, software must perform the following steps The System Control board has a real time clock 84 that is controlled and sensed by writing and reading the following I O addresses. The interrupt associated with the Real Time Clock is The System Control has two timers in addition to the Real Time Clock. They are provided by an Intel 8254 that has 4 I O addresses associated with it. The two timers are called the Watchdog timer and the Schedule timer. They both use the same prescaler but the Watchdog generates a Non Maskable interrupt NMI while the Schedule timer generates interrupt 32. Their addresses are listed below. The Timer is set up by writing to the Control register. The time base is also given below. The System Control provides a full range of interrupts for various system control functions. These interrupts are handled by five Intel 8259A Interrupt Controllers. One of these devices is designated the Master Controller and it has two Slave Controllers Slave 0 and Slave 1 connected to it. The last two 8259As are used to signal error conditions in the main array and are connected to Slave 0. The Main Array Error Controllers must be used in polled mode. The following table lists the controllers, their addresses, and defines the interrupts they handle. Section 3.3.2.1.14 lists the interrupts and vector addresses that are generated by these controllers. Programming details for the 8259A can be found in Intel s Data Catalogue. The System Control generates and handles a complete set of interrupts for managing the system. The interrupts are defined in the table below. The System Control Board supports the Intel 80287 Math Coprocessor 90 as an option. The I O addresses listed below are activated by invoking the Intel 80286 Escape opcodes used by the Intel 80287. The details on the 80287 are in Intel s Microprocessor Manual. The System Control Board is initialized on system reset. The following tables summarize the memory and I O address space of the System Control. A Graphics Processor is used to control a raster scan CRT display. This provides a very effective way for displaying and dealing with the very large amount of data that can be computed and output by the system. The graphics system consists of up to 2 megabytes of RAM organized as a 768 by 1024 by 8 bit frame buffer, 16 processing nodes to handle local display processing, a color lookup table, and the logic to handle display refresh and panning. The output of the graphics system is standard RS 343 RGB video data that can be connected to any high performance 40 mHz color CRT monitor. The I O channel bandwidth allows the main processor to output a new frame of display data in excess of 60 times a second faster than the display refresh rate . This makes the system ideal for a wide range of graphics applications. Two or more systems are interconnected through an I O channel an order 7 subcube in each system. This permits the implementation of arbitrary graphs of systems including pipelining of multiple systems where the output of one machine feeds the input of the next and the last system drives the displays. The processor array is made up of 2 The processor recognizes two main classes of data integers and reals. Integers are represented in standard 2 s complement form and come in three types byte B 8 bits , halfword H 16 bits and word W 32 bits . There two types of reals. The 32 bit format, called real R , has an 8 bit exponent and 24 bits of significance. The longreal L format is 64 bits with 11 in the exponent and 53 in the significand. The longreal format is used for computations that need high accuracy and for intermediate computations with real variables when the computation is particularly sensitive to roundoff error. Both of these formats conform to the IEEE Binary Floating Point Standard P754 . In addition to the various data formats, the processor recognizes and manipulates addresses. Addresses are simply 32 bit unsigned values that point to individual bytes in a linear address space. The processor s instructions operate on data in main memory as described above or on data in 32 bit registers. The processor contains three types of registers the general registers, the processor registers and the communication control registers. The 16 general registers are 32 bits long and are used for both operands and addresses. Since they are general they can be used interchangeably in all operations and addressing modes. The processor registers are special purpose and can only be read from or written into by Load Processor Register LDPR and Store Processor Register STPR instructions respectively. The exact formats and detailed descriptions of these registers are given in section 4.4.3. The processor registers are shown in FIGURES 7, 9A and 9B and include The I O ports on the processor are unidirectional Direct Memory Access DMA channels and each channel has two 32 bit write only registers an address register for the buffer location and a count register indicating the number of bytes left to send or receive. Communication is performed by setting the registers of the desired channel to the appropriate address and data length and then the DMA channel takes over and communicates a message without processor intervention. Interrupts can be used to signal when a channel is available i.e. when the count reaches zero the channel is ready . A separate interrupt vector is provided to indicate to a receiver that an error occurred during the data transmission. In addition to communication synchronization and error reporting the processor uses vectored interrupts for An instruction consists of an operation code followed by zero and one or two data references All instruction operation codes opcodes in the processor are one byte long. The first four bits indicate the operation and number of operands e.g. ADD 2 operands, BRANCH 1 operand while the other four bits denote the operand size and type e.g. Halfword integer , Real floating point . This symmetry makes an opcode map easy to read and code generation easier for a compiler. All of the standard instructions are available for each data type including arithmetic, logical, conversion, comparison, branch, call and trap instructions. Instructions can be preceded by a REPEAT prefix that causes them to be executed repeatedly until a termination condition is satisfied. This is a very powerful facility for vector and string operations. Repeats can also be used with both branches and calls in order to execute a block of code repeatedly. i.e. a REPEAT BRANCH is equivalent to a loop instruction . And for future extension each operand type has a reserved escape code. A few instructions have no operands e.g. BREAKPOINT and some have only one e.g. CALL but most have two address fields. All address fields begin with a one byte mode selector. For all modes involving the general registers the first four bits indicate the mode and the remaining four determine which register to use. If there is an offset indicated it follows the mode selector. Some of the modes provided are literal, immediate, direct and indirect with no registers involved and register direct, register indirect with and without offset, autoincrement and autodecrement and offset addressing with both the program counter PC and the stack pointer SP . As with instructions there is a reserved escape code defined for the mode selector field. The processor recognizes two classes of data integers and reals floating point numbers . There are three types of integers and two types of reals. The three integer data types are all represented in standard 2 s complement. They are called Byte B , Halfword H and Word W and are 8, 16 and 32 bits long respectively. The ranges for the three integer formats are specified as follows The floating point implementation in the processor conforms to the IEEE Binary Floating Point Standard P754 . With the floating point arithmetic not only are the rounded results as accurate as possible but it is feasible to compute guaranteed bounds on the errors using the special directed rounding modes. Also because of the high accuracy of Real 32 bits computations and the availability of Longreal 64 bits to back them up at crucial points, it will be possible to run many more programs in Real precision instead of automatically using Longreal everywhere. The representations for the two floating point types are illustrated below including the formulas for the value represented. In the formulas s is the sign, e is the exponent, f is the fraction and b is the bias in the exponent. The two formats are closely related the distinguishing characteristics being the exponent range defined by the parameter b and the fraction precision. The Real format has 24 bits of precision about 7 digits with a range of approximately 10 This implementation conforms to the IEEE Floating Point Standard which was carefully designed to provide accurate and reliable arithmetic. The following properties are a result of the standard. The floating point architecture of the processor implemented in accordance with the principles of the present invention includes much more than the data representations. All of the IEEE Standard requirements are either met in the hardware or are facilitated in software. Among these requirements is the provision of rounding modes. In the Program Status PS register are two bits that control the rounding mode in effect. The modes are Another important facility in the floating point architecture is exception handling. The following required faults are recognized All of these exceptions have an associated flag and Inexact has an interrupt enable in the PS register. If an exception occurs and its interrupt is enabled, the processor produces enough information for recovery. If the interrupt is disabled the flag is set and the processor takes predefined action The floating point architecture also provides all the standard instructions for all formats add, subtract, multiply, divide, compare and conversion. But in addition there are some unusual but crucial instructions. Square root is correctly rounded and as fast as divide. Remainder is an exact operation and permits argument reduction for periodic functions with no roundoff error. The following sections describe three types of registers in the processor the General registers, the Input Output registers and the Processor registers. The 16 General registers 128 , shown in FIGURE 9A, are labeled R0 to R15. They are 32 bits wide and are used for data and addresses. They are consistently symmetrical with no special designations or uses for any of them. When integer data shorter than 32 bits is moved to a General register it is sign extended to 32 bits. When data longer than 32 bits are stored in the registers, the low order part of the data goes in the designated register, Ri, and the high order part resides in Ri 1. The numbers wrap around so that if a Longreal is moved to R15 the high order section is found in R0. In a processor, each of the 11 input and output ports 48 , shown in FIGURE 5, is an independent Direct Memory Access DMA channel and has two 32 bit registers an address register and a count register. The address register contains a pointer to the least significant byte of the next halfword to be transferred. If it is an output port the data is moved from memory out to the port. If it is an input port the data is moved to memory that has been received from the output port of the sending processor. In both cases the count register is set to indicate the number of bytes to be sent or received. As data is sent or received, the appropriate address and count registers are incremented and decremented respectively by the number of bytes transferred. When the count reaches zero the ready flag in the Input or Output Status register see below is set and an interrupt is generated if an interrupt has been enabled. The DMA channels operate independently of instruction processing. They begin functioning whenever a count register is set to a nonzero value. All of the ports are general except one input and one output port are designated host H and are normally used to communicate over the I O bus to the System Control Boards. The Processor registers are the third type of register in the processor. All Processor registers are 32 bits wide. They contain all the special purpose and miscellaneous information and can only be loaded or stored by the Load Processor Register LDPR and Store Processor Register STPR instructions, respectively. These registers are labeled P0 to P11 but they also have unique names that denote their purpose C Carry is set on integer operations when there is a carry out of the most significant position. It is also set by floating point instructions and integer multiply and divide to indicate that the result is negative. This allows the use of the Unsigned Branches to implement the unordered branches required by the IEEE Floating Point Standard. V Integer Overflow is set when the integer result is too large in magnitude for the format. Z The Zero flag is set when the integer or floating point result is zero. N Negative is set when the integer or floating point result is negative. If there is an Integer Overflow the Negative flag will not agree with the sign bit of the stored result because the Negative flag is set according to the actual result before Overflow is determined. U The Not Comparable flag is set when floating point values are compared and one or both of the operands is Not a number Nan . INTERRUPT ENABLE FLAGS If a flag is set and the associated exception or event occurs an interrupt is generated. If the bit is zero the interrupt is suppressed until the interrupt condition is cleared or the interrupt is enabled. The floating point interrupt conditions are cleared as soon as the subsequent instruction begins execution. TO Timeout Enable if this flag is zero the interrupt that would be generated by a zero value in the Timeout Register is suppressed. II Input Enable if this flag is zero any interrupt associated with an input channel is suppressed. IO Output Enable if this flag is zero all output channel interrupts are suppressed. IE Interrupt Enable if this flag is zero then all interrupts that can be disabled by other flags are disabled T Trace this flag, if set to one, causes an interrupt as soon as the current instruction finishes this is used for single step debugging. RC Round Control this field controls the rounding mode for real operations. REP REG Repeat Register if the repeat mode is not 00 then every time the instruction the following repeat type operation code is executed the value in REG is decremented REG can be any of the General registers. The processor has a powerful vectored interrupt facility and generates several kinds of interrupts program exceptions, software facilities, I O signals and hardware errors. The program exceptions include integer overflow and zero divide, the floating point exceptions, stack overflow and address and reserved opcode faults. The software facility interrupts are trap, breakpoint and trace. The Input Ready, Output Ready, Input Parity and Input Overrun interrupts are the I O signals. And the hardware errors are Corrected and Uncorrectable memory errors and Processor Self Test errors. All interrupts including the TRAP and breakpoint BKPT instructions have the same convention. There is an unsigned number associated with the interrupt the argument of the trap instruction that is multiplied by eight to give the absolute location in low memory of the interrupt vector. Each vector is eight bytes the first four bytes contain the absolute address vector VA of the interrupt handing routine and the next four bytes are a new Program Status NPS value. When an interrupt is generated the processor pushes the Program Counter PC and the Program Status PS on the stack, sets the Program Status register to NPS and the Program Counter register to VA. If the interrupt is signaling a program exception interrupts 3 through 12, see below instead of saving the PC, the processor pushes the address of the offending instruction previous PC on the stack so that the exception handler can decode the instruction. One reason decoding may be necessary is because the IEEE Floating Point Standard requires the ability to construct a result, store it where the instruction would have and then continue the computation. When the interrupt handler is finished it executes a Return from Interrupt REI instruction that pops the old PS and PC values off the stack and into their respective registers. A TRAP instruction with the appropriate number as its argument can simulate any interrupt except that the PC is always pushed on the stack with TRAP regardless of its argument . All interrupts are defined below. The number at the left is the interrupt number. There is an internal Error flag that is tied to the Error pin that indicates that the processor is in an unknown, inconsistent or failure state. On resetting the processor the Error flag is initialized to one and if the on chip initialization sequence and subsequent diagnostic software run successfully it can be cleared by software EROF . It is also set by consecutive unserviced Uncorrectable ECC errors. The Error flag and pin can also be set and reset by the ERON and EROF instructions respectively. There are 22 unidirectional direct memory access DMA I O channels on each processor, 11 for input and 11 for output. The Input ports are numbered 0,1,...,9 and 31 while the Output ports are numbers 32,33,...,41 and 63. The input and output ports are normally used in pairs to form 11 full duplex I O channels as shown below Each of the I O channels has an address register, a count register, a ready flag and an interrupt enable flag. In addition each input channel has a parity error flag, an overrun error flag and a DMA pending flag. Besides the enable for each channel there are two global enable flags in the Program Status PS register. The II flag disables all input interrupts including errors even if the corresponding channel flag is enabled and the IO flag disables all output interrupts. In order to send a message from a memory buffer on a given output channel one first either checks its ready flag or enables its interrupt and waits for a ready interrupt. As soon as the channel indicates that it is ready idle , the address register is set to point to the first low byte of the message, which must begin on an even boundary, by executing a LPTR Load Pointer instruction. The source operand of this instruction is the address of the message buffer and the destination operand is an integer whose value determines which of the channel registers is to be loaded In order to start the automatic message output, the corresponding count register must be set to the number of bytes in the message. In this version of the processor the low order bit is forced to zero in both the address and the count registers thus the message buffer must start on an even byte boundary and be an even number of bytes long. No error is signaled if a program violates this requirement. This is done by executing a LCNT Load Count instruction. The destination operand indicates the register to be loaded as explained above for the LPTR instruction and the source operand is the count value an unsigned 32 bit integer . The LCNT instruction also resets the parity and overrun error flags when setting up an input port. The message transmission is automatic and as data is sent the address register is incremented and the count is decremented by the number of bytes transferred. When the count becomes zero the output stops, the ready flag is set and if enabled the ready interrupt is generated. In addition to sending a message on a single channel, the processor has a powerful BROADCAST facility. In order to send a message over several channels at once, one must first ensure that the desired output channels are ready. Then a BPTR Broadcast Pointer instruction is executed. Its source operand is the address of the message as in LPTR but its destination operand is a 32 bit mask. Every bit position that is set to one will cause the corresponding output channel address register to be loaded. Bit position 0 corresponds to output channel 32, position 1 to channel 33, etc. The message broadcast is started by executing a BCNT Broadcast Count instruction whose destination operand is a mask as explained above for the BPTR instruction and whose source operand is an unsigned 32 bit integer equal to the number of bytes in the message. The major advantage of broadcasting is that the sending processor only has to access each transmitted datum once thus reducing the memory bandwidth used by the DMA facility. The processor can only handle one broadcast at a time so if a subsequent broadcast is attempted, even on different channels, before the current one is finished the results will be undefined. In order for a message to be transmitted successfully the corresponding input channel of the receiving processor must first be set up with an address to an input buffer and the same count as the output channel. One way this can be accomplished is by using a software protocol that always sends a single halfword as the length of the desired message and waiting for the receiving processor to respond with a halfword code that indicates ok to send message . This protocol will work because the last halfword that is sent remains available for DMA even if the receiving processor s input channel is uninitialized count zero . The presence of this data in the input channel is indicated by the corresponding bit in the INPUT DMA PENDING register which can be tested by software being set. Thus as soon as the count register is set to one, the halfword either the length or on ok to send is stored in memory. Before attempting to DMA the data to memory that is in an uninitialized input port the error Overrun and Parity flags must first be checked or they will be lost. This is because the Load Count instruction clears the error flags. The processor recognizes two types of errors in communication. Each halfword is sent with a parity bit and on reception a parity check is made. Also if a halfword is received into a DMA channel before the previous one is stored in memory an input overrun error is detected. Overrun can occur when the input count goes to zero before the output count a software error, or when too many messages are being sent to the processor at the same time. If either type of error occurs the corresponding flag is set and when the input count reaches zero instead of ready , an input error interrupt is generated if II is set . A software error that is not detected by the processor occurs when the output count is smaller than the input. In that case, after the message is sent the input channel will simply hang. This condition can be avoided by correct software or by setting up timeout conditions using the Timeout Register. The processor is designed to be as simple and symmetric as possible. Most instructions work on all supported data types the General registers are interchangeable in all operations all address modes work with all instructions including Branches. An instruction consists of an operation code opcode followed by zero, one or two address fields. The representation of a two address instruction in memory is illustrated below In the physical representation shown above REFERENCE 2 is both one of the operands and the result. For example, if the OPCODE indicated Subtract then the operation performed would be All opcodes are one byte long and each operation type group has at least one reserved code for future expansion. The byte is divided into two fields of four bits each. The first field, TP, specifies the length and type of the operands e.g. 8 bit integer, 32 bit real and the second field, OP, determines the operation and number of operands e.g. Add 2 operands, Call one operand . Each of the operations is described in detail in chapter 4.8 but most are evident from their name in the opcode table below. The first field is represented horizontally with the even values above the odd values. The second field is displayed vertically and is repeated twice. The Opcode Map illustrates a number of symmetries that are explained in the table below. If an instruction has operands, the address fields always have at least one byte. The first byte, called the Mode Specifier, encodes the addressing mode and for most of the instructions the first four bits specify the general register to be used in the address evaluation while the next four bits indicate the mode. The format is as shown below The modes are listed below with their encodings and mnemonics. The assembler will chose the shortest reference form possible. The addressing modes are described in detail below. First note the following If a literal is used in a Branch, Call or Move Address instruction, the literal is added to the PC i.e. a relative Branch or Call results . If a literal or immediate is used as a destination an Operand Error is signaled. In this mode the operand is contained in the indicated register. The value is interpreted according to the instruction real for floating point instructions, integer for integer operations and bit string for logical instructions. If a longreal operand is expected the low order part is in Rn and the high order part in Rn 1. When a byte or halfword is moved to a register it is sign extended. The indicated register contains the address of the low order byte of the operand. The indicated register is decremented by the length in bytes of the operand and then the contents becomes the address of the operand. This mode can be used to build a software stack or to access consecutive array elements. The data addressed by Rn is first accessed and then Rn is incremented by the number of bytes in the operand. This mode is used to step through arrays and, with Autodecrement, to build software stacks. The register Rn points to a 32 bit value that is the address of the operand. After the operand is accessed Rn is incremented by four, since addresses are four bytes long. After the operand addressed by the contents of Rn is fetched, the value in Rn 1 is added to Rn. If n 15 then n 1 0. This mode allows for automatically skipping through an array by an amount in Rn 1 that can be calculated during program execution. For example if a matrix is stored by columns this mode permits automatic references to successive row elements. This mode calculates the address of the operand by adding the value in Rn to the offset which is a signed integer whose length is determined by the mode setting A byte, B halfword, C word . The offset immediately follows the mode indicator and is sign extended for the effective address calculation. These modes are also available for the PC and SP in place of a general register see below . The contents of Rn are added to the offset in this mode only a 32 bit offset is allowed and the 32 bit value at that address is the address of the operand. This mode is also available with either PC or SP instead of a general register see below . The address is calculated by adding the address of the instruction the value of PC before the current instruction is executed to the sign extended value of the offset which can be a byte, halfword or word. This mode is used to access operands relative to PC and with branch instructions to jump relative to PC. The Literal mode with branch instructions also is relative to PC. This permits compiling position independent code. The address of the instruction the contents of PC is added to the word offset and the 32 bit value at that address is the address of the operand. The address is calculated by adding the SP and the sign extended offset. The offset can be a byte, halfword, or word. This mode is often used to access local variables in an activation record on the stack. The SP and the word offset are added together and the 32 bit value at that address is the address of the operand. The address is the unsigned value of the offset byte, halfword or word depending on the mode that follows the mode specifier. The word that follows the mode specifier points to a 32 bit value that is the address of the operand. In this mode the operand follows the mode specifier For arithmetic and logical operators the length and type of the value is indicated by the instruction. Thus, ADDB Add Byte will assume an 8 bit signed integer while MULL Multiply Longreal will expect to find a 64 bit floating point operand as the value . An immediate operand used with a branch or move address instruction causes an invalid operand fault. If this mode is used as the destination the second address in a two address instruction an Operand error is signaled. When this mode is the first specifier it takes the operand from the top of the stack and then increments pops SP by the length of the operand. So the instruction The instructions are listed alphabetically by mnemonic and are grouped according to operation e.g. all the ADD instructions are grouped together . The memory format of all of the instructions is shown below. The source and destination specifiers are optional. While most instructions have two addresses, there are a few with zero or one address. The source src address is always evaluated first and all addressing operations e.g. autodecrement are performed before the destination dsrc, des address is evaluated. In the above notation dsrc refers to the operand before the operation is performed and des refers to the contents of that address after the operation. This does not apply to stack addressing modes where the SP at the beginning of the instruction is always used. Any addressing mode that refers to the PC or SP uses the value of the PC or SP at the beginning of the instruction. The source operand is never changed except when using the stack addressing mode. If an instruction with byte or halfword operands references a general register, the high order part of the data is ignored if it is a source and if it is a destination the high order part is sign extended. The unique exception conditions for each instruction are included in the information below. There are a set of exceptions that are independent of the particular instruction It is important to remember that the Negative N Flag is always set according to the sign of the correct result. Thus on integer overflow, the destination may appear positive even when N indicates negative. A processor can be initialized by either asserting the reset pin or by executing a RSET instruction. The resulting initialization is significantly different in the two cases. They are both described below. Hardware initialization is done by asserting the reset pin and proceeds in several steps The code in the on chip shadow ROM is listed below with comments. There are two levels of operating software in the system the Monitor in EPROM and the Operating System. The Monitor is a simple, single user system that is in effect when the system is powered on. The Monitor uses terminal 0 and provides extensive diagnostic and management functions. The Operating System, IX IX is a trademark of NCUBE Corporation , is automatically invoked if the system is in Normal mode and passes the diagnostic tests. IX is a fully protected multiuser, multitasking operating system with complete resource management including memory, main array, graphics and file system. The file system has a hierarchical structure and is distributed across all the disk drives in the system. Thus, a user can access his files regardless of which terminal or Peripheral Controller he uses. In many ways the Operating System is similar to UNIX UNIX is a Bell Laboratories trademark , and therefore will not be described in detail herein. The IX System does, however, have additional facilities including The IX System is described in section 5.3. The Monitor is contained in the system EPROM and is invoked when the system is powered on. The Monitor always communicates with Terminal 0 on Peripheral Controller 0 the System Console for displaying messages and receiving commands. When the system mode switch on the front panel is in the Normal position, the Monitor rung the diagnostics and boots the Operating System if the diagnostics run successfully . If the mode switch is set to Diagnostic , the Monitor goes into a single user system after successfully running the diagnostics. The Monitor system provides a large range of offline diagnostic and backup facilities. The Monitor consists of two parts the ROM Monitor and the RAM Monitor. They are both in the system EPROM but the ROM Monitor uses no RAM even for stack space while the RAM Monitor, when invoked, is copied to RAM and uses RAM for data. The ROM Monitor starts the system and executes the diagnostics up to the memory test phase. If memory test passes, the RAM Monitor is automatically invoked but if it fails, the system stays in the ROM Monitor and a few simple commands are available see 5.2.3 . The facilities tested by the Monitor diagnostics are listed below in order. If the system is in Normal Mode and a disk is connected then Since the ROM Monitor does not use RAM, its commands are few and simple. They are listed below and are invoked by typing the first letter in the command name. A return causes a new prompt to be displayed. A c can be typed at any time and whatever is happening will be aborted and a new prompt displayed. The operand specifications for the commands are defined as follows SEG MAX is the number of 64 Kbyte segments of memory to be tested starting from memory address 0 . The value in memory at ADDR is displayed and can be altered by typing a new value. A line feed advances to the next word in memory and repeats the command. A return terminates it. The RAM Monitor is invoked automatically if the diagnostics pass the memory test or explicitly by typing g in response to the ROM Monitor prompt. The RAM Monitor Commands are of four types general, debugging, disk control or tape control. The general commands are invoked by typing the first letter of the command name. The debugging, disk control and tape control commands are invoked by first typing y , x or t respectively, followed by the first letter of the specific command name. If return is the first character typed, a new monitor prompt, , is printed and the command analyzer is restarted. A c can be typed at any time and regardless of what is happening, it will be aborted and a new prompt will be displayed. The operand specifications are the same as the ROM Monitor s see 5.2.3 but with several additions. The operating system, IX , is a high performance UNIX style interface to the hardware. It supports multiple users, including password and billing, and multitasking. The editor, NMACS, is screen oriented and is similar to a simplified version of EMACS. The file system is the most prominent feature of the operating software because nearly every system resource is treated as a type of file. The file system is hierarchical like UNIX but has extensive mechanisms for file protection and sharing. The operating system treats memory as a collection of segments that can be allocated and shared. Processes are created and scheduled priority, round robin by the system and provide part of the protection facility. There is a debugger and a linking loader. One of the unique facilities of the IX system is the management of the main processing array. It is managed as a device and each process requests subsets of the array which are allocated according to availability. Fault tolerance is supported by the system since it periodically runs diagnostics on the array and if any nodes fail, they are mapped out of the allocatable resource and the operator is informed of the fault. Only the facilities listed above which are essential to an understanding of the present invention are described in more detail below. The file system is the user s uniform interface to almost all of the system resources. The two main entities in the file system are directories which provide the structure and files which contain the data. Most resources e.g. printers, terminals, processing array are treated as devices which are simply one type of file. A file has a name which both uniquely identifies it and indicates its position in the file structure. Files have a set of operations defined that can be performed by a user having the requisite privileges. There are three editors in the IX system. One is a line editor called ed . It is compatible with the ed line editor in UNIX. Another is a stream editor whose name is sed . Sed is also compatible with the UNIX stream editor of the same name. For detailed information see the extensive literature on standard UNIX systems e.g. B. W. Kernighan s books A Tutorial Introduction to the ED Text Editor and Advanced editing on UNIX . The third editor is a screen editor called nm NMACS . It is similar to the widely used screen editor EMACS. The system of the present invention provides a segmented virtual memory environment. The virtual address space is 2 bytes. Main memory is treated as a set of segments on 256 byte boundaries. The operating system provides allocation, deallocation, extension segments can grow to 64 Kbytes , compaction and swapping functions. The system relies on the Intel 80286 memory management hardware. Memory is allocated and deallocated with the system call core . Processes are managed by the operating system as the fundamental units of computation. They are created, scheduled, dispatched and killed by the system in a uniform way for all processes. When the operating system is booted the primary, highest priority system process, called the MCP Master Control Program , is dispatched. It initializes the system including dispatching background system processes like a print spooler that it gets from a system initialization file, watches terminals and creates processes. It also cleans up and shuts dawn the system when power failure or overheating is detected. Whenever a user logs on the system, the MCP checks his name and password. If he is an authorized user and the password is correct, the MCP creates a process for him. The parameters of the process are taken from his log on file that is created by the system administrator. These parameters include the priority, the initial program usually the shell , the preface user s root directory and billing information. The logon file for user1 is named sys acct user1. A process is represented by a data structure in memory. This structure, called a process object, has the following entries All processes in the system are linked together in the process list. When it is time to dispatch a new process the list is searched starting from the process that was most recently running. The search finds and dispatches the highest priority process that is in runnable condition. If there is more than one the last one found is dispatched. The process runs until one of three events occurs Thus, the process management system implements preemptive, priority, round robin scheduling. There are a set of operations for process management. These system calls are frun run a file The system treats almost all resources as devices which are simply a special type of file. The devices include disk drives, tape drives, printers, graphics hardware, interboard bus, SBX interfaces and the hypercube array. Devices are managed as are other files with open, close, read and write calls. For special operations that do not fall easily in those categories, the operating system supports a special operation call. These special operations are things such as setting terminal parameters and printer fonts. The system treats the hypercube array as a device type file. Consequently, it is allocated with an open command, deallocated with close and messages are sent and received with write and read respectively. One of the powerful features of the hypercube is that it is defined recursively and so fill orders of cube are logically equivalent. When allocation is requested the user specifies in the open call the subcube order N he needs. If a subcube of that order is available, it is initialized and the nodes are numbered from 0 to 2 The graphics boards are also treated as device files and are allocated and managed by each user with file system calls. The special operations that are defined for the graphics devices are the graphics operations that the hardware itself supports such as line and circle drawing, fill in, panning, etc. Each System Control board in a system has three SBX connectors. One is used for the cartridge tape controller and another is dedicated to providing the Interboard Bus a bus for moving data between Peripheral Controllers . The last SBX connector is available for custom parallel I O applications. There are many potential uses for the SBX Interface including networking, 9 track tape drive controller, etc. Regardless of what it is used for, it will be treated as a device by the operating system. Consequently, it is only necessary to write the appropriate device driver in order to use the standard file system calls for device management. The first level initialisation is accomplished by simply turning on the system in Normal mode. When the operating system is booted, it looks for a configuration file called In addition, the system administrator must perform certain functions such as creating logon files for each user. In addition to initializing the operating system, the hypercube array must be initialized. The initialization of individual processors is discussed in section 4.9. In this section an algorithm for initializing the system is described. The algorithm is based on a tree structure and can be more easily illustrated than described. The diagram below shows the initialization responsibility for each processor assuming there are 16 processors. The binary numbers are the processor ID s and the decimal numbers represent the stage in time of the initialization. The assembly language code that implements this algorithm is listed below. This section specifies the commands in alphabetic order that are implemented in the operating system In this section the data structures that are used in the operating system are specified. Most of the structures are used for managing To fully understand some of these structures it is necessary to have a working knowledge of the 80286 see iAPX 286 Programmer s Reference Manual from Intel for details . Some of the important characteristics of the 80286 are In the specifications below the abbreviations have the following meanings C Constant, B Byte, H Halfword, W Word, D Double Word. If a Word is an address in memory then it consists of the two parts described above. If a Word is a disk address then it has three parts that designate cylinder, head and sector. The process statistics can be used for billing and are accessed with the getpcs system call. The process parameters are set at process creation from the log on file or they are inherited from the creating process. The open file table contains open file descriptors. Whenever a file is opened a descriptor for it is entered in this table and its index channel number is returned. Whenever a new segment is allocated to a process, a descriptor for it is entered in the LDT. There are several system variables that are used in process management. These include There is a small nucleus that runs in each node of the hypercube array. The main function of the nucleus is to provide communication and synchronization facilities. However, there is also a simple debugger and a program loader and scheduler. The model of computation assumed by the system is that the user will explicitly separate a program and data into parts that run on separate processors. It is also assumed that any synchronization that is necessary will be accomplished by waiting on communication. Therefore, the key functions are the communication routines. Communication at the user level is done with two simple system calls send and receive . They both have three arguments a set of nodes, a message and a message length. A message is a string of bytes and the set of nodes is the destination or origination of the message. Both routines are blocking functions and do not return until the message is sent or received. To avoid waiting when synchronization is unnecessary, there is a test for message function which returns immediately with a flag indicating whether there is a message waiting for reception. There are also timed versions of send and receive that have an additional time out parameter. They return after the message is received or sent or time out is reached, whichever comes first. They return a flag indicating which condition caused the return. The underlying system level handshaking and buffer management breaks a message up into small blocks and sends receives one block at a time. For messages that must be routed through more than one node, this is much more efficient than trying to handle the whole message at once. Also, it prevents a waiting for buffer type of deadlock. There is a simple debugger that runs in each node. In response to messages from the Peripheral Controller that is managing the subcube, a node can set breakpoints and read and set memory and registers. The node nucleus has system calls that, in response to messages from the Peripheral Controller currently managing the node, allows a node to load a program and its data and schedule it for execution. This section specifies the calls that a program running in a node can make on the nucleus. It also shows how a program running in the Peripheral Controller that is managing a node can, through sending and receiving messages, access some of the system calls. The list of system calls includes In this section a method for initializing the system is presented, especially how to propagate the initializing software through the array. There is more than one acceptable algorithm. The one we present here is a very simple one with high efficiency. The algorithm is based on a tree structure. The diagram below shows the initialization responsibility for each processor assuming there are 16 processors. The binary numbers are the processor ID s and the decimal numbers represent the stage in time of the initialization. The assembly language code that implements this algorithm is In order to program the system effectively a user must think of a particular problem as a set of smaller problems. In some applications, particularly in the physical sciences, this is relatively easy. Most science problems involve solving equations in a 2 or 3 dimensional space and one can simply divide the space into pieces and solve the equations in these divided spaces, matching the solutions at the edges. In other applications dividing the problem into smaller pieces may not be as straight forward. However, almost all large problems must be subdivided, just to be manageable. A large proportion of important problems can be solved effectively on the system of the present invention. One difference between the system of the present invention and the more traditional pipelined approach to high performance computing is that one must divide both the program and the data into smaller pieces. This is sometimes more difficult than having many programs working on a large shared memory, but it more accurately models the real physical world of local phenomena and it is the only way to overcome the memory speed bottleneck of shared memory systems. Many problems will require a modification of the hypercube interconnection scheme. Therefore, the following section describes how to map the hypercube onto some of these different interconnection patterns. The hypercube interconnection system was chosen for three main reasons Since many physical problems split naturally onto lattices, algorithms for mapping the hypercube onto grids up to dimension 4 will be described. All of the hypercube mappings are most easily described using some variant of Gray code. A gray code is a one to one mapping between integers such that the binary representations of the images of any two consecutive integers differ in exactly one place. The domain is assumed to be finite and the largest and smallest integers in the domain are consecutive . One example of a gray code for three bit integers is One may intuitively see that a gray code is important by realizing that in a hypercube, if processor x is connected to processor y, then the binary representations of x and y must differ in exactly one place. There is a unique gray code implemented with the following algorithm As will be seen below, the inverse mapping is also needed. In other words if z is a gray code image we will need to be able to calculate the value x whose gray code is z. The inverse mapping for the gray code algorithm given above is implemented in the following code Although the gray code above is unique, there are many mappings between integers that have the property of mapping consecutive intergers to images that differ in one place. Any such mapping can be used in the algorithms described below. A one dimensional grid or ring is simply a string of interconnected processors as shown This interconnection is often useful when the problem does not have to solved in real time and can be broken down into steps that can be pipelined. Non realtime filtering is an example. The mapping in this case is simply any gray code as described in section 7.2.1. Thus, if F is the gray code and G is its inverse then the neighbors of processor x are Steady state problems involving two space dimensions e.g. boundary value problems map naturally onto a two dimensional grid. To define a two dimensional mapping, assume that the grid is 2 Many real physical problems are mapped onto three dimensional grids. An example is fluid flow whether in airplane wing design turbulent, compressible flow or oil reservoir modeling incompressible flow . A three dimensional mapping is analogous to the two dimensional case except the processor ID numbers are divided into three parts instead of two and there are six neighbors instead of four. If a problem involves both time and space it may be conveniently mapped onto a four dimensional grid. In this case a processor ID number is divided into four parts and each processor has eight neighbors. In this section programming to solve a typical problem is presented. Simultaneous linear equation problems are categorized according to the structure of the matrix representing the problem. The two main types are Below programming is shown for solving the dense matrix Gaussian elimination. The method involves computing factors of a matrix so that the problem is solvable in two steps. For example, suppose we want to solve In the algorithms for dense matrices the matrix is broken up into equal rectangles as close to squares as possible . Also the hypercube is mapped onto a two dimensional grid. Thus, in the ideal case where there are M Gaussian elimination with partial pivoting is a relatively stable and fast method to solve a set of dense linear equations that have no special structure. This method computes a factorization of A called LU i.e. A LU where L is lower triangular and U is upper triangular . Gaussian elimination can be used efficiently on the system of the present invention and pivoting does not slow the algorithm down appreciably. The following user program computes L and U using partial pivoting with actual row interchanges. The elements of L and U replace the elements of A. FIGURE 1 is a diagram of a multiprocessing system in which the present invention is embodied. A clock board 10 , a number 1 to k of processor array boards 12 , and a number 1 to x of system control boards 14 , are plugged into slots J1 J24 in a backplane 16 . The backplane shown in FIGURES 2A and 2B is wired in such a way as to interconnect the k processors boards into an order P hypercube, where each processor board has m processor nodes connected in an order n hypercube, and where K 2 One of the processor array boards 12 is shown in more detail in FIGURE 3, and is described in Section 8.1. One of the system control boards 14 is shown in FIGURE 12, and is described in Section 8.9. Refer to FIGURE 3. Each processor array board is 16 by 21 and contains 64 processing nodes i.e., m 64 each processing node having 128K bytes of local memory and 11 I O channels. The processing nodes are connected in an order 6 hypercube on the board i.e n 6 . This interconnection uses 6 of the 11 I O channels on each processing node. The other 5 I O channels are brought to the edge of the hoard for access to the backplane. 4 of these 5 channels are routed via backplane interconnections to other array boards to build larger hypercubes as described in Section 8.2 below. The remaining one channel on each processing node is connected to one of the eight I O slots in the backplane which receive eight system control boards. Thus each one of the eight system control boards 14 in the I O slots of FIGURE 1 is able to communicate directly with up to 128 processing nodes. One of the 64 processing nodes on the processor array board of FIGURE 3 is shown in FIGURE 4. Each one of the 64 processing nodes includes an Ncube processor integrated circuit 30 , a local memory 32 , a system host serial I O channel 34 , and 10 i.e., p 10 serial I O channels 36 . The wiring on the processor array board shown in FIGURE 3 , interconnects the 64 nodes on the board in an order 6 n hypercube comprised of 64 2 The Ncube processor block 30 of FIGURE 4 is shown in more detail in FIGURE 5, and is comprised of Floating Point Unit 40 , Address Unit and Instruction Cache 42 , Instruction Decoder 44 , Integer Execution Unit 46 , I O Ports 48 , and Memory Interface 50 , which are attached to either or both of a common address bus 52 , and data bus 54 . These units are described in sections 8.3 through 8.8 below. FIGURE 2a is a detailed diagram of the arrangement of the serial communications interconnect on the backplane of the multiprocessing system shown in FIGURE 1. Processor array boards are inserted into one or more of the 16 slots 0 through F to form hypercube structures according to the following list The backplane wiring routes signal lines to connect groups of board together as shown in FIGURE 2A. For example, an order 7 hypercube is achieved by inserting 2 boards in slots 0 and 1, or 2 and 3, or 4 and 5, etc. An order 8 hypercube is achieved by inserting 4 boards in slots 0 through 3 or 4 through 7, etc.. An order 9 hypercube is achieved by inserting 8 boards in slots 0 through 7 or 8 through 15. An order 10 hypercube is achieved by inserting 16 boards in slots 0 through 15. The I O interconnect wires are shown at the bottom of FIGURE 2A. Each line includes 128 I O channels which are connected from a system control board in an I O slot and fan out to up to 8 processor array boards, 16 channels going to one of the 8 boards. Each one of the 16 channels go to the host serial channel 34 , FIGURE 4, on a processing node. Since there are a total of 64 such nodes on a processor array board, four system control boards in I O slots 0 through 3 of FIGURE 2A provide the 64 channels on each processor array board in array board slots 0 7, and four system control boards in I O slots 4 7 of FIGURE 2A provide the 64 channels on each processor array board in array board slots 8 15. FIGURE 2b is a detailed diagram of the system control interconnect on the backplane of the multiprocessing system shown in FIGURE 1. The control lines include system reset lines, clock lines, and array error lines. As shown, the clock board 10 of FIGURE 1 is inserted in a slot between slots J12 and J13. Refer to FIGURE 6. The floating point unit 40 shown in FIGURE 5 is comprised of four input operand registers 56 which receive data from the data bus 54 . The operand select MUX 58 selects, from the appropriate input operand register, the sign and exponent portion and the significand portion. The sign and exponent portion is delivered to the sign and exponent logic 60 . The significand portion is delivered to the significand logic 62 . The logic blocks 60, 62 perform the floating point arithmetic specified by the instruction definition in Section 4.8. The sign and exponent logic 60 and the significand logic 62 outputs are connected to the operand register 64 which returns the data to the data bus 54 . Refer to FIGURE 7 which is a detailed block diagram of the address unit and instruction cache 42 shown in FIGURE 5. The refresh address register 100 contains a pointer to memory which is the value of the address in memory which is to be refreshed next. After each refresh cycle is taken, this pointer is incremented. The Stack Pointer Register 102 contains a pointer which points to the top of the stack. The stack pointer register is described in Section 4.2.2 above, under General Registers. The operand address register 104 is an internal register to which computed effective addresses are transferred before a memory cycle is performed. The operand address register is connected to the address bus. The program counter 106 points to the next instruction to be executed. It is incremented the appropriate number of bytes after the instruction is executed. It is also affected by call, return, and branch instructions which change the execution flow. The program counter is connected to the instruction fetch address register 108 which is a pointer into the memory location from which instructions are currently being fetched. These instructions are loaded into the instruction cache 114 . The instruction cache allows for fetching several instructions ahead of the instruction that is being executed. The shadow ROM 110 is described in Section 4.9. It contains instructions that are executed prior to the transfer of control to user code upon system initialization. The instruction cache provides a buffer for data after prefetch and before the actual execution of the stored instruction. It also provides some retention of the data after it has been executed. If a branch is taken back to a previous instruction for reexecution, and if that previous instruction is in within 16 bytes of the currently executing instruction, the data corresponding to that previous instruction will still be stored in the cache. Thus, a memory fetch cycle will not have to be taken. The instruction cache is both a look ahead and look behind buffer. The MUX 112 is a multiplexer that multiplexes between instructions coming from the shadow ROM or coming from memory after initialization. Refer to FIGURE 8. The instruction decoder 44 shown in FIGURE 5 receives an instruction stream from the instruction cache of FIGURE 7. The instruction decoder includes an opcode PLA 101 which decodes static information in connection with the opcode of an instruction, such as number of operands, type of operands, whether the instruction is going to take a single cycle to execute or many cycles to execute, and what unit the instruction is going to execute in the instruction execution unit or the floating point unit . This information is latched in the opcode latch 103 . The operand itself is latched into the operand latch 105 . The operand sequencer PLA 107 is a state machine whose main function is to supervise the decoding of operands. The operand decode PLA 109 is a state machine whose main function is to compute effective addresses for each of the addressing modes and to supervise the execution of instructions. The execute PLA 111 is a state machine whose main function is to execute the instruction in conformance with the definition of instructions as given in Section 4.8 above. Refer to FIGURES 9A and 9B which together comprise a detailed block diagram of the integer execution unit shown in FIGURE 5. The exact formats and detailed descriptions of the registers are given in section 4.4.3. The Processor Status Register 126 contains flags, interrupt controls and other status information. The Fault Register 124 stores the fault codes. The Configuration Register 120 stores the model number read only and the memory interface parameters. The Processor Identification register 122 contains a number that identifies the processor s location in the array. The Timer register 116 contains a counter that is decremented approximately every 100 microseconds and generates an interrupt if enabled when it reaches zero. The refresh timer 118 is a time out register used to time the period between refreshes. This register is initialized from eight bits out of the configuration register and it decrements those eight bits. When the timer goes to zero, a refresh is requested. The register file 128 is described in Section 4.4.1 above It includes 16 addressable registers that are addressable by the instruction operands. The temporary register 130 is an internal register used during the execution of instructions. It is connected to the integer ALU 132 which is used during the execution of integer instructions. The sign extension logic 134 takes the result from the ALU block and, according to the data type of the result, extends the sign to a full 32 bit width. It also checks for conversion overflows. The barrel shifter 136 , the shift temporary register 134 , and the shift count register 140 are used to execute the shift and rotate instructions. The port select register 142 is an internal register in which the register number of the serial I O port to be selected for the next operation is stored. The control register select register 144 is an internal register in which the address of the control register to be selected for the next operation is stored. The memory data register 146 is an internal register used for the temporary storage of data which is destined to be written into memory. It is an interface register between the instruction execution unit and the memory interface. FIGURES 10A and 10B comprise a composite block diagram of a single I O port representative of one of the 11 I O ports 48 on each processor shown in FIGURE 5. Each port has all the circuitry necessary to both receive and transmit serial messages. The format of the messages is described in Section 5.4.1 above. Data are received on the serial data in line 150 and are framed in the input shift register 152 . The information is then transferred in parallel to the input latch 154 and is stored there until it is transferred to the memory on the memory data in lines 156 . Similarly, data to be transmitted is brought in from the memory data out lines 158 , stored in the output latch 160 , and then transferred to the output shift register 162 , and transmitted serially on the serial out line and combined with parity bits from the parity bit generator 164 . The input port and the output port both contain an address pointer and a byte counter. The address pointers 166, 170 point to the locations in memory where the message will be written to or read from. The input and output byte counters 168, 172 are utilized to specify the length of message to be sent or received. All of these four registers are initialized by the appropriate instruction the load address pointer instruction, and the load byte counter instruction. After a message packet is received, the input address pointer 166 is incremented by two bytes and the input byte counter 168 is decremented by two bytes. After a message packet has been sent, the output address pointer 170 is incremented by two bytes and the output byte counter 172 is decremented by two bytes. The control portion of the serial port is shown in Figure 10A. There is an input controller 174 and an output controller 178 which control the timing of the serial transmission. These controllers control the timing of when the parity bit is sent out and when the parity bit is to be checked on incoming data. They also control the various flags. The parity error flag 180 is set by the input controller when there is a parity error detected on an input message. The full flag 182 is set by the input controller during the time that the input latch 154 is buffering a message which has not yet been transferred into memory. The overflow flag 184 is set by the input controller when the input latch is holding a message to be sent to memory and the input shift register 152 finishes receiving a second message which overrides the first message before it is transferred to memory. The input enable flag 186 is a flag which is both readable and writable by the user to enable interrupts that occur when the input port becomes ready, i.e. when the byte count goes to zero. On the output port there is an output enable flag 188 which, when enabled, will generate an interrupt when the output port ready line becomes true, i.e., when the byte count goes to zero when the message has been fully transmitted . This signals the user that it is necessary to reinitialize the port with a new message. The full flag 190 on the output port controller is set for the period of time when there is data in the output latch which has not been transferred to the output shift register. The broadcast flag 192 is initialized by the broadcast count instruction. When this flag is set, it indicates that this particular output port is a member of the current broadcast group. When an output port is a member of the current broadcast group, then any data coming over the memory data out bus 158 for broadcasting will be transmitted out of this port and simultaneously out of all other ports that have their broadcast flags on. The port interrupt logic 194 generates interrupts if enabled when the input or output ports have finished transmitting or receiving messages, as signaled by the appropriate byte counter being decremented to zero. The port memory arbitration logic 196 performs the function of arbitrating for memory with all the other I O ports. The winner of this arbitration must again arbitrate with other units on the chip in the memory interface unit described in Section 8.8. When an arbitration is successful and a memory grant is given, the memory grant line indicates that data either has been taken from the memory data in bus or that the data is available on the memory data out bus shown in Figure 10B. Refer now to Figure 11, which is a block diagram of the memory interface logic shown in FIGURE 5. The memory interface logic interfaces between the several internal units which need to access memory and the memory itself. The memory control block 200 receives the memory request lines from the various internal parts of the chip and memory requests external to the chip via the memory request pin. The memory request pin allows the Intel 20286 to request a memory cycle of a processor s memory in which case the memory interface logic performs the function of a memory controller providing the RAM control lines from the timing generator 202 while allowing the Intel 20286 to actually transfer the data in and out of the memory . The memory control prioritizes these requests according to a given priority scheme and returns memory grants back to the individual requesting unit when it is that unit s turn to use the memory. The memory control specifies to the timing generator when access is to begin. The timing generator provides the precise sequence of RAM control lines as per the memory specifications for the particular RAM chip. The memory control also specifies when the address is to be transferred from the address bus through the address latch 204 to the address pins of the memory chip. The memory control also controls the transfer of information from the data collating registers 206 and the internal buses to and from which data is transferred internally. The data collating registers 206 perform two functions. First, they bring many pieces of a data transfer together, for example, for a double word transfer the registers will collate the two single words into a double word. Second, the data collating registers align the data with respect to the memory, such that if data is being written to an odd location in memory the data collating registers will skew the data to line up with memory. The ECC check generate logic 208 is used to generate the ECC during a write operation and to check for errors during a read operation. The ECC syndrome decode 210 operates during a read operation to flag the bit position that is in error as determined by the ECC check logic. A single bit error can be corrected by the error correction code and this bit position will be corrected automatically by the ECC syndrome decode logic. FIGURE 12 is a detailed block diagram of the system control board 14 shown in FIGURE 1. It includes an array interface 212 , shown in more detail in FIGURE 13, a 2MB System RAM 214 , SMD disk drive controller 216 , parallel I O interface 218 , System I O Interface 220 , CPU and Control 222 , Auxiliary I O Interface 224 , and SBX and EPROM 226 . The address buffers 354 and the data buffers 356 are connected via the data lines and the buffer lines to the local RAM 352 . The SMD controller 216 is connected to the local memory 352 and is also connected to the system RAM 214 for the transfer of data from disk to memory. FIGURE 13 is a detailed block diagram of the the dual ported processing nodes and serial communications interconnect on the system control board array interface shown in FIGURE 12. The system control board includes r r 16 dual ported processing nodes 300 , connected on the board as shown in FIGURE 13. As shown in FIGURE 14, each dual ported processing node includes a processor 350 , a local dual ported memory 352 and s s 3 I O channels. The channels are interconnected such that the s s 3 channels 351 communicate with other nodes on the system control board through the order 1, order 2 and order 3 interconnect shown in FIGURE 13 to form two order 3 hypercubes. The 16 r dual ported processing nodes on an I O board are therefore connected as two order 3 hypercubes. The remaining v v 8 serial I O channels 353 communicate with processing nodes on array boards through host channels in the backplane I O interconnect shown in FIGURE 2A. FIGURE 14 is a detailed block diagram of one of the 16 dual ported processing node of the system control board interface shown in FIGURE 13. The dual ported processing nodes use the same NCUBE processor integrated circuit as the array processor of FIGURE 4. The System Control Boards 14 of Figure 1 use the 8 I O slots on the backplane. Through backplane wiring, these boards are allowed to access up to a 128 processor node subset of the array. Each System Control Board FIGURE 13 has 16 processing nodes 300 and each node has 8 of its I O channels 0,1,...,7 dedicated to communicating with the Processing Array through the array interface 212 . Referring to FIGURE 1, let each Processor board slot J1 J24 be numbered xxxx in binary. Also assume that the board in that slot contains the hypercube xxxx yyyyyy where yyyyyy is a binary number that can range from 0 to 63. i.e. the ID s of the processors on board xxxx are xxxxyyyyyy where xxxx is fixed. Then the following diagram illustrates the mapping between the nodes in the Main Array and the nodes on a system control board. Note the following from with respect to the above chart In the following table, variables are defined for purposes of generic claim language. The actual number for the specific embodiment disclosed in this specification is shown in the table opposite the corresponding variable.