# SEARCH APPARATUS

## Claims
Suchgerät mit einem Speicher 20 , der eine Vielzahl von Speicherplätzen aufweist, deren jeder eine Anzahl b Bits enthält, wobei jedes Bit einen Knoten in einer Baumstruktur darstellt und der durch ein Bit y des Speicherplatzes x dargestellte Knoten b Subordinatenknoten hat, die durch die Bits im Speicherplatz bx y dargestellt sind, und der ein Adressenregister 21 aufweist, das eine Adresse zum Adressieren des Speichers 20 zum Auslesen des Inhalts der Speicherplätze enthält,

## Description
This invention relates to search apparatus for locating, in a collection of items, an item which satisfies a predetermined criterion. The invention is particularly, although not exclusively, applicable in a parallel data processing system in which instructions are not executed sequentially, as in the conventional Von Neumann architecture, but may be executed at any time after they become ready for execution, e.g. when all the necessary operands are available. In such a system, there may at any given instant be several instructions ready for execution, and it is necessary to provide some way of rapidly locating these instructions. This could be done by maintaining a list of identifiers pointing to those instructions that are ready for execution. However, this implies a considerable overhead in terms of storage costs and store access required to maintain the list. An alternative way would be to mark those instructions eligible for execution with an indication flag. The problem is then to locate, among all the instructions in the store, those with their flags set. This could be done by scanning through each location of the store in turn, but this would take an excessively long time. Alternatively, the flags could be stored in a contents addressable memory, but such memories are very expensive. A similar problem arises in the allocation of storage in a parallel data processing system. Generally, the store is organised as a set of cells, which are allocated as required and are released into a pool of tree cells when no longer required. The task of locating a free cell is precisely analogous to that of finding an executable instruction. An object of the invention is to provide an improved search apparatus which does not suffer from the disadvantage referred to above. The present invention makes use of a data structure referred to as a tree. Tree structures are well known in the art. In particular, reference is made to IEEE TRANSACTIONS ON COMPUTERS, Col C 20, no 4, April 1971, pages 404 418, IEEE, New York, US K J BERKLING A computing machine based on tree structures , which describes a technique for storing a tree structure in random access memory RAM and for addressing the tree structure using a shift register. According to the invention there is provided search apparatus comprising a memory 20 having a plurality of locations each containing a plurality b of bits, each bit representing a node in a tree structure wherein the node represented by bit y of location x has b subordinate nodes represented by the bits in location bx y, and an address register 21 containing an address for addressing the memory 20 to read out the contents of one of said locations, characterised by One embodiment of the invention will now be described by way of example with reference to the accompanying drawings. Figure 1 is a diagram representing a tree structure. Figure 2 is a block diagram of a search apparatus in accordance with the invention. Figure 3 is a logic diagram showing part of the apparatus in more detail. Referring to Figure 1, this shows a tree structure consisting of a number of nodes, represented by circles, arranged in four levels. The highest level level 0 contains a single node, referred to as the root node, and the lowest level level 3 contains 64 nodes, referred to as terminal nodes or leaves. Each non terminal node i.e. each node other than a leaf is connected to four subordinate nodes at the next lowest level of the tree that is, the tree has a branching factor of four. The 64 leaves correspond respectively to 64 items, and are set to indicate whether these items satisfy a predetermined criterion. For example, the leaves may correspond to instructions in a store, and are set to indicate whether the instructions are ready for execution. Alternatively, the leaves may correspond to data storage cells, and are set to indicate whether the cells are free. Each node other than the root is allocated a number x,y as shown in Figure 1. As can be seen, the four nodes at level 1 are allocated the numbers 1,0 to 1,3 the four nodes subsidiary to node 1,0 are allocated the numbers 4,0 to 4,3 and so on. In general, the four nodes subsidiary to node x,y are allocated the numbers 4x y, 0 to 4x y, 3. A non terminal node is set if any one of its subordinate nodes or leaves is set. For example, if the leaf 21,2 is set, then the nodes 5,1 and 1,1 and also the root node must be set. It can be seen that a set leaf node can be quickly located by tracing a path through the tree, starting at the root node and passing from each node to one of its subordinate nodes which is also set, until a leaf is reached. Such a path is indicated by a heavy line in figure 1. Whenever the status of an item changes, it is necessary to update the corresponding leaf of the tree. For example, when an instruction becomes available for execution, the corresponding leaf is set conversely, when an instruction has been executed, the corresponding leaf is reset to its original unset state. Whenever a leaf is updated, the change must be propagated up to the higher levels of the tree, according to the following rules For example, if the leaf 22,1 in figure 1 is set, then the change must be propagated up to the next level by setting the node 5,2 at level 2. It is not necessary to propagate the change any further, since the relevant node 1,1 at level 1 is already set, as a result of the previous setting of node 21,2. Referring now to figure 2, this shows search apparatus which utilises the tree structure described above. The tree structure is held in a random access memory RAM 20, having 32 locations 0 31 each having four bit positions 0 3 . Each node of the tree structure, except for the root node, is represented by one bit of the RAM. Specifically, each node x,y in Figure 1 is represented by bit position y of location x of the RAM. Thus, it can be seen that the four nodes at level 1 are represented by the four bits of location 1 in the RAM the sixteen nodes at level 2 are represented by locations 4 to 7 and the 64 leaves at level 3 are represented by locations 16 to 31. The other locations of the RAM are unused. It should be noted that the node corresponding to bit y of location x has its four subsidiary nodes or leaves stored in the four bits of location 4x y. The RAM 20 is addressed by the five least significant bits of an eight bit address register 21. This register has a RESET control which resets it to the value one a LOAD control which causes it to be loaded in parallel from an input path 22 and SHIFT LEFT and SHIFT RIGHT controls which cause it to be shifted left or right. The data output of the RAM 20 is fed to a four bit data register 23. It is also fed to a priority encoder 24 which produces a 2 bit priority code representing the position of the first i.e. leftmost set bit in the data output. If none of the data bits is set, the encoder produces a signal NBS. The 2 bit priority code can be inserted into the two least significant i.e. rightmost bit positions of the address register 21. Alternatively, the contents of these two least significant bit positions can be loaded into a 2 bit control register 25. The data input to the RAM comes from a logic circuit 26, which in turn is connected to the data register 23 and is controlled by the contents of the control register 25 and by a control signal SET. Referring now to figure 3, this shows the logic circuit 26 in detail. The circuit includes four selection circuits 30, the outputs of which are connected to the data input of the RAM 20. The first inputs of the circuits 30 are connected to receive data from the data register 23. The other inputs all receive the SET signal. The logic circuit 26 also includes a decoder 31 which decodes the contents of the control register 25 to produce a signal on one of four lines 32. This causes one of the four circuits 30 to select its second input, while the other three all select their first inputs. Thus, it can be seen that the logic circuit receives the data output of the RAM by way of the data register 23. It then updates the data by setting the bit specified by the control register 25 to the value specified by the signal SET, the other bits being unchanged. The updated data can then be written back into the RAM. The four input data bits to the logic circuit 26 are combined in an OR gate 33 to produce a signal BWS which indicates that at least one of the data bits was already set prior to updating by the circuit. The four output bits are combined in an OR gate 34 to produce a signal BAS to indicate that at least one of the data bits is set after updating. The signals BWS and BAS are combined in a non equivalence gate 35 to produce a signal PROPAGATE. It can be seen that this signal is true wherever an update has to be propagated to the next higher level of the tree in accordance with the rules specified above. The way in which the search apparatus is operated in order to find a set leaf is as follows On the other hand, if the contents of the address register are less than 64, the above sequence is repeated from step 2 . It can be seen that step 4 selects a set node from the currently addressed location of RAM 20. Step 5 then updates the address register 21 so as to point to the location containing the four nodes subordinate to the selected node. This cycle is repeated, progressing to the next lower level of the tree at each cycle, until eventually a leaf node is selected. The procedure therefore traces a path through the three from the root node to a set leaf. The way in which the tree structure is updated will now be described. It can be seen that the update procedure first updates the specified leaf node. It then traces a path up the tree towards the root node, until it reaches a node which does not need to be updated i.e. one for which PROPAGATE is not true . It will be appreciated that the apparatus described above can easily be extended to accommodate any desired number of items by a suitable choice of tree structure. In general, if the branching factor of the tree is b assumed to be equal to a power of 2 for simplicity , and the depth of the tree i.e. the number of times the tree branches is d, then there are N b It can be seen that, in general, the number accesses to the RAM required to locate a set leaf will be log