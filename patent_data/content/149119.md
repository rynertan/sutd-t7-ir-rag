# METHOD FOR ROTATING A BINARY IMAGE

## Claims
Verfahren zum Drehen eines bin√§ren Bildes in eine Lage um 90 Grad, mit den Schritten

## Description
The present invention relates to digital image processing methods and more particularly to methods for image rotation. The following are systems representative of the prior art. U. S. Patent 3,976,872 shows a method of rotation of an image by 90 degrees among other functions performed. However, the patent does not show a method for rotating an image by 90 degrees which includes testing groups of bits in the image to determine whether the group of bits is all the same value as does the present invention. U. S. Patent 3,968,475 shows a digital processor for extracting data from a binary image in which the image is divided into an array of sample areas each sample area containing an array of binary data spaces. Although the patent demonstrates image rotation by any one of a number of predetermined angles, the patent does not show a method for rotating an image by 90 degrees either clockwise or counterclockwise including testing the sample group to determine if all bits of the sample group are the same as does the method according to the present invention. U. S. Patent 4,052,699 relates to an image processing system wherein video data is stored in a matrix having n rows and n columns. The image is rotated 90 degrees in a piece meal fashion by vertically accessing word by word video data previously stored as horizontal words. However, the method and apparatus of the patent do not test the group of words to be rotated to determine if all bits in the group are the same as does the method according to the present invention. U. S. Patent 4,168,488 shows hardware for image rotation of a word organized image buffer where the buffer is divided into a number of square sections each storing a portion of the full image. Although the patent shows apparatus for image rotation through an angle of 90 degrees, the patent does not show a method which includes testing a subimage to determine if all bits in the subimage are the same value as does the method according to the present invention. U. S. Patent 4,225,929 relates to a code converter including means for rotating an image about a center point. The patent does not include testing of bits in a subimage to determine if all bits are the same as does the method according to the present invention. U. S. Patent 4,271,476 relates to apparatus for rotating horizontal scan format images into vertical scan format images for printing or other processing. The patented apparatus divides the image into a number of sections and then rotates each section in sequence. The patent does not show a method including testing each section to determine if all bits are the same as does the method according to the present invention. EPO published patent application no. 081,096 relates to an image rotation control circuit for controlling printing of an image on a printer. The published control circuit does not store the entire display but merely a single line at a time which is converted from a horizontal line to a vertical line or vice versa for printing. The publication does not show a method for rotating an image by 90 degrees including testing a portion of the image to determine if all bits representing picture elements are the same as does the method according to the present invention. An article in the IBM Technical Disclosure Bulletin, Vol. 18, No. 8, January 1976, p. 2640 shows a method for rotation of images using contour compressed data. However, the article does not include testing portions of an image to determine if all bits are the same as does the method according to the present invention. An article in the IBM Technical Disclosure Bulletin, Vol. 13, No. 11, April 1971, p. 3267 shows a method for performing a fast transformation of axes on two dimensional binary images. The article does not include testing portions of an image to determine if all bits are the same as does the method according to the present invention. An article in the IBM Technical Disclosure Bulletin, Vol. 18, No. 8, January 1976 at page 2633 shows a shift register system for image orientation which among other functions rotates an image in 4 x 4 arrays of characters. The article does not include testing portions of an image to determine if all bits are the same as does the method according to the present invention. JP A 59 167 772 relates to a picture data rotating device in which digital picture data is divided in squares and each square is rotated as a fundamental rotation unit to obtain a rotated image. A hardware circuit is provided for testing to determine if all bits in the square are the same value. When the square has a uniform level, no rotation is performed. The prior art discussed above does not teach nor suggest the present invention as disclosed and claimed herein. Therefore, it is an object of the present invention to rotate an image by a method including the steps of storing said image in raster form as a sequence of bytes in an image buffer, said bytes representing said image in the form of r rows by c columns and each byte having b bits, r being a multiple of b, dividing said image vertically into a series of blocks, each block having r rows by n column s with n less than c copying one block of said image bytes into a temporary storage buffer, rearranging the uncopied bytes in the image buffer to make available a region having an area equal to that of the copied block, in which region said copied block will fit after rotation, separating said copied bytes in said temporary storage buffer into groups of mxm bits for rotation, determining for each said group if all bits have the same value, copying each group having all bits the same value to appropiate location in said available region of said image buffer, rotating each group that does not have all bits the same value, and storing each rotated group in raster form in the appropiate location in said available region of said image buffer, repeating said steps of copying, rearranging, separating and storing on the successive blocks of said uncopied image bytes without desturbing the already copied data blocks to finally store said image in said image buffer in rotated form. The foregoing and other objects, features and advantages of the invention, which is defined in the attached claims, will be apparent from the more particular description of the preferred embodiments of the invention, as illustrated in the accompanying drawings, in which In the drawing, like elements are designated with similar reference numbers, and identical elements in different specific embodiments are designated by identical reference numbers. The method according to the present invention rotates an image clockwise or counterclockwise ninety degrees. Images are considered to exist in storage reading from left to right across the rows, from the top of the image to the bottom. Rotation is performed in situ. It is possible to extract a rectangular portion of a larger image, rotate it, and store it as a portion of another larger image, if desired. The present method performs an in situ rotation. The calling routine supplies the same address for the original and output images. In the example shown in FIG. 1, the rotated image occupies the storage which contained the original image before rotation. For this type of rotation, the number of rows r must be a multiple of eight, since the bits in a vertical column are packed into bytes by the rotation and a row of the output image must not end with a fraction of a byte. The program embodying the present invention requires a single parameter PARM which gives the address of a list of six parameters controlling the rotation. These parameters are stored in a 24 byte buffer all parameters are full 4 byte words. FIXED 31 specifies a 4 byte value PTR 31 indicates variables which will be addresses. The six parameters are The problem considered here is that of rotating a binary image in storage clockwise or counterclockwise by ninety degrees. The rotation algorithm proposed uses a novel combination of techniques such as a fast rotation algorithm for an eight by eight bit unit and exploitation of the fact that a binary image typically includes large areas containing only zero white picture elements to produce code which is significantly four to 12 times faster than current methods. We describe the counterclockwise case in detail the required modifications for the clockwise case are summarized at the end of this document. The bits making up the image are assumed to be stored packed eight to a byte. Since bit operations are computationally expensive, the image is divided into eight by eight bit blocks. The bits in an eight by eight bit block may be rotated relatively efficiently the blocks are rearranged in storage to complete the rotation process. The block rearrangement for in situ rotation proceeds as illustrated in Figured 2. The first 32 bytes of each row of the input image are copied into temporary storage. The number 32 is arbitrary it controls the amount of temporary storage required to perform the algorithm. The remaining bytes in each row of the input image are moved up in storage, filling in the space left by the removal of the first 32 bytes of each row and leaving a space at the end of the input image which will accommodate the data from the temporary buffer which must be moved into it. This empty space is cleared for reasons explained below and the data from the temporary storage area is rotated and stored in the empty space, producing the last 256 lines of the output image. Since the rotation of the image is counterclockwise, the data from the left edge moves to the bottom of the image 32 bytes, or 256 bits, of data was taken from each row, so that 256 lines of output are produced. Next, the next 32 bytes from each row are copied into temporary storage, and the remaining data in the rows of the input image are compressed as before. The 256 lines of output image already produced are not disturbed. An empty space now exists immediately before the last 256 lines of the output image this area is cleared and the data from the temporary buffer are rotated into it. This process continues until no data is left in the input image. The size of a row of the original image need not be a multiple of 32 if it is not, the last rotation operation acts on only the number of leftover bytes which were in the input image. Rotation of the bits in the individual eight by eight bit blocks occurs as the data from temporary storage are rotated into their final positions in the output array. The data in the temporary storage area are processed in four byte wide columns. The case in which the number of bytes of data in each row is not a multiple of four is treated separately but the process is essentially the same. Eight lines of the input image are processed at a time. The basic problem is thus to take a four by eight byte 32 by 8 bit image, rotate the four eight by eight blocks within it, and position them in the output array. The first step in the process is to determine whether all of the bits in the 32 by 8 bit block are zero. In this case, no processing is necessary, since the output from the rotation will be a block of zeroes, and the area in the output array where the rotated block would be stored has already been zeroed. Recognizing that no processing is necessary for this case is an important element in gaining speed in the algorithm, since most of the execution time would normally be spent in the rotation of the eight by eight bit blocks, and the case where a 32 by 8 bit block consists entirely of zeroes occurs for from approximately one third of the image for kanji or dense text to over four fifths of the image for some drawings and relatively sparse text, e.g. memos . If a 32 by 8 bit block contains some nonzero bits, it is broken up into four eight by eight bit blocks. Each of these blocks is then checked to see if it consists entirely of zeroes if it does, it can be skipped as described above. Otherwise the block is rotated using the algorithm illustrated in Figured 3. Briefly, the eight bytes are broken up into nibbles, which are used to index into a set of lookup tables shown in Figure 4 and 5. These tables are constructed so that when the values looked up for the low or high order nibbles are summed, the result gives the first or last four bytes in the rotated block. See Fig. 6. In order to perform a clockwise rotation, we would simply perform the copy compress process moving from right to left rather than from left to right i.e. copy the last 32 bytes from each line into temporary storage at each stage , rotate the data from temporary storage into the output image so that the rightmost rather than the leftmost eight by eight bit blocks are rotated to the bottom of the output image, and change the lookup tables used in the rotation of eight by eight bit blocks to produce a clockwise rather than a counterclockwise rotation.