# Enhanced speed digital computer and method of speed enhancement.

## Abstract
Microinstructions are stored in a control store 307 . All microinstructions are conditional. In the frst half of an instruction execution cycle the sequentially next microinstruction is prefetched by a program counter 301 , with incrementer 303 , into a prefetch register 308 . In the second half of the execution cycle the branch address from the current instruction register 310 is utilized via a multiplexer 302 and address forwarding circuit 313 to prefetch the target microinstruction from the control store 307 . This prefetched target microinstruction is fed to a prefetch buffer 309 and, depending upon the resolution of the condition, either the sequentially next prefetched microinstruction is strobed out of the prefetched register 308 into the instruction register 310 , or the prefetched target microinstruction is passed by the prefetch buffer 309 into the instruction register 310 .

## Claims
CLAIMS 1. A method of operating a stored program digital computer utilizing conditional instructions and prefetching of instructions, characterised in that, in the case of a conditional instruction, both the sequentially next instruction and the target instruction determined by the conditional instruction are prefetched, and one of the prefetched instructions is selected for execution when the condition of the conditional instruction is resolved. 2. A stored program digital computer comprising a prefetch register 308 into which sequentially next instructions are prefetched, characterised by a prefetch buffer 309 , means 302, 313 responsive to a conditional instruction to prefetch a corresponding target instruction into the prefetch buffer 309 , and means 1301, 1401, 310 for selecting between the two prefetched instructions for execution in dependence upon the resolution of the condition. 3. A computer according to claim 2, characterised in that the sequentially next instruction is prefetched in the first part of the current execution cycle and stored in the prefetch register 308 , the target instruction is passed to the prefetch buffer 309 in the latter part of the current execution cycle, and the selecting means 1301, 1401, 310 transfer the stored instruction from the prefetch register 308 to an instruction register 310 or enable the prefetch buffer 309 to pass its instruction to the instruction register, in dependence upon the resolution of the condition.

## Description
Description of the Prior Art A stored program computer typically includes a device for storing the memory address, or the equivalent thereof, of the next instruction to be executed by the central processing unit this device usually takes the for of a register, and is typically called the program counter, or ZPC . The program counter typically is loaded with the starting address of a desired sequence of inotructions, and is incremented from that point to point to successive addresses of the subsequent instructions. The next instruction to be executed is typically the next sequential instruction in the memory device. Rovever, some of the instructions may be branch or jump instructions, which result in next executing an instruction other than the next sequential instruction. Such other instruction is known as the target instruction of a branch. A conditional branch instruction specifies that r target instruction other than the next sequential instruction will be executed if a certain specified condition such as a machine state condition or a variable being equal to a certain value is met. If the specified condition is not met, the next sequential instruction is executed In a rudimentary digital computer, an instruction to be executed is fetched from the memory location indicated by the program counter.The program counter is then incremented to point to the next sequential instruction to be fetched. If execution of the current instruction indicates that branching is to occur, the program counter contents are overwritten by the branch address specified by the current branch instruction. Using the program counter to indicate the address in memory of the next instruction1 the correct next inStruction is then fetched. Another situation in which instructions are executed in an order other than that in which they are arranged in memory occurs in conjunction with subroutine calls and returns. Instruction subcequences that may be needed repeatedly may be written as subroutines . Then, when it is desired to execute one such subsequence, a CALL instruction appears in the instruction sequence the call instruction specifies the starting address of the subroutine as the instruction to be executed next. The last instruction in the subroutine is a RETURN instruction, which indicates that the subroutine has run to completion and that the sequence which called the subroutine is now to be resumed at the instruction immediately following the CALL instruction the instruction which invoked the subroutine . To facilitate call and return instructions, computers typically employ z LIFO last in, firct out memory1 usually called a Ustackla. to store return addresses i.e., the addresses of instructions following call instructions1 which are the addresses at which execution is to be resumed after executing return instructions .While executing a call instruction, the program counter contains the address of the next sequential instruction1 having been incremented as mentioned above after being used to fetch the call instruction The program counter contents are then usually placed in the next available location in the stack often referred to as the top of the stack The program counter is loaded with the address specified in the call instruction as the starting address of the cubroutine, and execution of the subroutine proceeds from there.When the return instruction is encountered, the program counter is loaded with the address of the instruction at which execution is to be resumes1 i.e. the address of the instruction following the call instruction which invoked the subroutine. This address is found on top of the stack1 for it was placed there as part of the execution of the call instruction. Associated with the stack is a stack pointer , typically a multibit register with provision for incrementing and decrementing by one. A register containing the address of one item is commonly said to point to that item. The stack pointer initially points to the first location in the stack1 is incremented by one whenever anything is placed on the stack1 and is decremented by one whenever anything is retrieved from the stack Thus1 the stack pointer always points to the next available location in the stack.This scheme allows for Pected subroutine calls 1 i.e. for a subroutine to call another subroutine. If, for example, an instruction sequence has called subroutine A which has called subroutine B, then when subroutine B encounters a return instruction, the address to which it is to return in subroutine A is retrieved from the top of the stack1 and the stack pointer is decremented by one when subroutine A encounters a return instruction, the address to which it is to return in the main sequence is retrieved from the new top of the stack, the location to which the stack pointer has been decremented to point. Calls may be nested over as many levels as there are available locations in the stack. The stack portions of prior art machines typically hold the address of the next memory location to be accessed in the stack. For each memory access, the contents of the stack pointer must be decoded usually accomplished by gating logic to select the corresponding memory location.Additional gating must be employed to determine whether the stack has overflowed i.e., an attempt was made to exceed its capacity or underflowed i.e., an attempt was made to retrieve non existent contents . Throughout this document, the term branchiJts will be used to denote the Situation that exists when the next instruction to be executed is other than the next sequential one, regardless of whether this is because of a branch instruction, a call instruction, or a return instruction. Efforts to speed up the operation of digital computers have included such improvements as instruction prefetching , wherein the next instruction to be executed is fetched from memory while a current instruction is still executing. Thus, execution of an instruction can commence immediately upon the completion of the execution of the previous instruction and the central processing unit is not delayed while memory accesses, bus transfers and the like take place. A problem in extracting the full benefit from instruction prefetching occurs in conjunction with conditional branch instructions. It usually cannot be known whether a conditional branch is to take place until some point near the end of execution of the conditional branch instruction by which time the next sequential instruction not the target instruction should already have been fetched.A delay then ensues while fetching the target instruction Various approaches have been tried to limit this delay in fetching the target instruction, such as mechanism6 for predicting the outcome of a conditional branch see, for example, U.S. Patent 4,430,706 issued to Sand , or assuming that conditional branches will always be taken or never be taken , and requiring the programmer to construct his programs in as close conformance as possible to the assumption For example, in coding a loop that is to be executed twenty times, the programmer can employ an exit branch that is not taken twenty times and then taken once, or alternatively a return branch that is taken twenty times and then not taken once. Despite these various approaches, the prediction or assumption is not always correct the wrong instruction has been prefetched. and a delay ensues while fetching the correct next instruction. SUMMARY OF TEE INVENTION This invention is embodied in a microinstruction controlled microcomputer including a control store for storing microinstructions which may include conditional branch instructions. The invention provides a dual prefetch path for prefetching both the next sequential microinstruction and the target microinstruction specified by a branch microinstruction. The invention also provides for selecting, prior to the completion of execution of the conditional branch instruction, which of the two prefetched microinstructions is to be executed nest. This permits execution of microinstruction without delays attributable to fetching of the next microinstruction, even in the presence of conditional branch instructions. It is thus an object of the present invention to provide improved digital computers. It is another object of the present invention to provide faster digital computers. It is a further object of the present invention to provide computers in vhich, during the execution of an instruction, both possible next instructions are prefetched in order that execution of the correct next instruction may begin immediately. Other objects of the present nvention will be understood by those of ordinary skill in the art, after referring to the description of the proferred embodiments and the appended drawings. In the Droviot Figure 1 is a block diagram of the microcode control scheme of a prior art machine employing microinstruction prefetching.Figure 2 is a tiling chart depicting the timing of an assumed microinstruction sequence running on the prior art machine ofFigure 1.Figure 3 is an overview of the microinstruction fetching scheme of the present invention.Figure 4 is a timing chart depicting the timing of an assumed microinstruction sequence running on a machine embodying the.present invention.Figures 5 and 6 depict the circuitry which comprises the branch address multiplexor of the present invention.Figure 7 shows the circuitry which comprises the branch latch and branch address incrementing means of the present invention.Figure 8 shows the circuitry comprising the program counter and program counter incrementing means of the present invention.Figure 9 shows circuitry comprising the program counter input multiplexor of the present invention.Figure 10 shows circuitry for branch address forwarding of the present invention.Figure 11 depicts the control store address input multiplexor of the present invention. Figure 12 depicts the microinstruction control store of the present invention. Figure 13 depicts the microinstruction prefetch register of the present invention Figure 14 depicts the microinstruction prefetch buffer of the present invention. Figure 15 depicts the microword register of the present invention. Figure 16 is a detailed timing chart of a hypothetical microinstruction sequence running on the machine of the present invention. Figure 17 shows a memory addressing scheme of the prior art. Figure 18 is a high level overview of the stack addressing scheme of the present invention. Figure 19 depicts the stack pointer circuit of the present invention. Figure 20 shows the stack of the present invention. Figure 21 shows certain gating circuits of the present invention. DETAILED DESCRIPTION Table 1 outlines pertinent portions of a hypothetical microinstruction stream that will be used for illustrative purposes throughout this description TABLE 1 LOC CONTENTS 100 COND. BRANCH TO 400 assume NOT taken 101 COND. BRANCH TO 200 assume TAKEN 102 microinstruction not reached 200 COND. BRANCH TO 500 201 microinstruction Figure 1 shows the microinstruction fetching and execution portions of a prior art machine employing instruction prefetching. Program Counter PC 101 is initially loaded with the starting address of s desired sequence of microinstructions b initial load means 102.Control store 104 contains sequences of microinstructions. During a microinstruction cycle, the contents of PC 101 are forwarded to control store 104, which fetches the icro instruction from the location whose address was received from PC 101, and forwards the fetched microinstruction to prefetch register 105. Increment means 103 increments PC 101 so that PC 101 is ready to addr Cs a the next sequential microinstruction on the next fetch During the next microinstruction cycle the microinstruction from prefetch register 105 is transferred to microinstruction register 106 where it is decoded and then executed by ALU 108. ALU denotes , arithmetic and logic unit , that portion of a computer central processing unit that actually performs the operations specified by the instructions. Concurrently with executing the microinstruction presently in microinstruction register 106, the next sequential microinstruction is prefetched by means described in the preceding paragraph. If a microinstruction is to branch either br uce it specifies an unconditional branch, or because it specifies a conditional branch and the condition is met the branch address contained within or specified by a field of the branch microinstruction is input over line 109 to PC 101, so that the next prefetch will be of the target microinstruction specified by the branch microinstruction. Figure 2 shows the timing that would result when the prior art machine depicted in Figure 1 executes the microinstruction sequence of Table 1. Assuming that microinstruction 100 has been prefetched prior to cycle 1, it will be in the microinstruction register 106 and will be executed during cycle 1. Also during cycle 1, microinstruction 101 will be prefetched from the control store 104 under control of the PC 101, which, as deccribed above, has been incremented to 101 after fetching microinstruction 100.After microinstruction 101 has been prefetched, the PC 101 is incremented to 102. Hieroinetruction 101 will be placed in the prefetch register 105 . At the start of cycle 2, microinstructi6n 101 is transferred from the prefetch register 105 to the microinstruction register 106. It is executed during cycle 2.Also during cycle 2, microinstruction 102 will be prefetched and the PC 101 will be incremented to 103. During execution of microinstruction 101, ALU 108 determines that the specified conditional branch is to take place, i.e. the next microinstruction to be executed is microinstruction 200. Tht number 200 from the branch address field of microinstruction 101 is loaded into the PC 101, overwriting the number 103 to which it had been incremented. Microinstruction 200 has not been prefetched microinstruction 102 has been prefetched because it was not known at the beginning of cycle 2 that the branch to 200 would take place. The specified conditions could not be examined until some point during cycle 2. Thus cycle 3 is lost to the ALU 108, since the microinstruction it should execute during cycle 3 has not yet been fetched from control store 104.Cycle 3 must be devoted to prefetching microinstruction 200 from control Store 104. PC 101 is incremented to 201, which is the instruction that will be fetched during cycle 4. Microinstruction 200 is tran.ferred to the microinstruction register 106 at the start of cycle 4 for execution by ALU 108 during cycle 4. The prefetch scheme of the present invention, which eliminates the problem of lost instruction cycle time due to incorrect prefetches for conditional branches, is shown in high level block diagram form in Figure 3. Subsequent figures will disclose more detail. A major difference between the prior art and this invention is the dual prefetch path. comprising prefetch register 308 and prefetch buffer 309. In the present embodiment, every microinstruction is r conditional branch, conditional call, or conditional return microinstruction. Thus, every instruction has the potential to specify either of two instructions as its successor in execution.Therefore, two microinstructions are prefetched during every microinstruction cycle. In embodiments wherein some microinstructions do not have this potential. it would be possible to prefetch only one microinstruction during the execution of those microinstructions. During the first half of a microinstruction s execution cycle, prefetch register 308 receives the next sequential microinstruction from control store 307 during the second half, prefetch buffer 309 receives the branch target microinstruction from control store 307. Either prefetch register 308 or prefetch buffer 309 may load microvolt register 310 with the microinstruction to be executed next, depending on the determination made during the current execution cycle of whether the branch is to be taken. The addresses used to prefetch microinstructions are provided to control store 307 by MUX 306, which may obtain the addresses from any of three sources 1 branch addresses obtained from a the current microinstruction in microword register 310 or b from stack 315, one being selected and passed through branch HUX 302 and forwarding circuit 313 2 a previous branch address stored in branch latch 314, as incremented by branch 1 adder 304 and passed through PC MUX 305 or 3 PC program counter 301, as incremented by PC 1 adder 303 and passed through PC MUX 305. PCMUX 305 can load PC 301 to ready it for its next use,.loading it with either its former contents as incremented by PC 1 adder 303, or the branch address from branch latch 314 as incremented by branch 1 adder 304. The interactions between these three address source paths and the PC loading path will be discussed in detail below. When executing call instructions, the contents of PC 301 are retained in stack 315 for use by subsequent return instructions, in addition to being retained in PC 301. Stack pointer 316 controls the addressing of stack 315 as vilL be discussed further on. The microinstructions fetched by control store 307 are, as mentioned above, brought to microvolt register 310 either through prefetch buffer 309 or prefetch register 308. Once in microword register 310, they are executed by ALU 312. ALU 312, which executes the microinstructions contained in microword register 310, can be a conventional ALU and will not be described herein. Control store 307 is accessed twice per microinstruction cycle once to prefetch the microinstruction that is stored sequentially after the microinstruction which is currently executing, and once to prefetch the branch target microinstruction of the microinstruction that is currently being executed. At the conclusion of executing the current microinstruction, at which time it will be known whether a conditional branch is to take place, both possible next microinstructions have been prefetched and execution of the correct one of the two can commence without any delay to fetch a different microinstruction. Prefetching the next sequential microinstruction in done during the first half of the microinstruction execution cycle, and proceeds in one of two ways, depending on whether the currently executing microinstruction was reached sequentially from a previous microinstruction, or was reached by being a branch target. the reason for this distinction will become evident during the discussion of how branches are effected. First, consider the case where the currently executing microinstruction was reached because it was a branch target micro instruction Its address is stored in branch latch 314, for reasons that will be described later. The address of the currently executing microinstruction, now stored in branch latch 314, is incremented by one by branch 1 adder 304 to indicate the next sequential microinstruction in the path after the currently executing microinstruction. The incremented address is selected by PC MUX 305, in response to a timing signal, and passed to HUX 306 to control store 307, which will use that address to prefetch the next sequential microinstruction. Second, consider the case where the currently executing microinstruction was reached sequentially from a previous microinstruction, and not an a result of a branch. Its address is stored in PC 301 for reasons that will be described as the description progresses. PC 1 adder 303 increments the address by one so as to denote the next sequential microinstruction The incremented address is selected by PC MUX 305, in response to a timing signal, and passed through MUX 306 to control store 307, which uses that address to prefetch the next sequential microinstruction. The next sequential microinstruction regardless of whether its address was obtained from branch latch 314 or PC 301, in stored in prefetch register 308 pending the deterSiQation of whether the currently executing microinstruction is to branch, as discussed below. Prefetching the branch target microinstruction of the currently executing microinstruction is done during the second half of the current microinstruction cycle. Branch addresses 311, specified in the currently executing mictoinotruction contained in microword register 310 or obtained from stack 315, are forwarded to branch mux 302 which selects the appropriate one of the branch addresses in response to the ALU and bused upon the currently executing microinstruction and forwards it through branch address forwarding circuit 313 and through MUX 306 as the address input to control store 307.Control store 307 fetches and applies the 96 bit branch target microinstruction to the inputs of prefetch buffer 309. The branch target microinstruction is then available to be gated through prefetch buffer 309 in the event that it is needed i.e., that the conditional branch specified in the currently executing microinstruction is to be taken. The branch address from branch address forwarding circuit 313 is retained in branch latch 314 for possible use during the first half of the next microinstruction cycle. Near the end of the current microinstruction cycle, ALU 312 determines, from current conditions, whether the currently executing microinstruction is to branch. If it is, then the branch target microinstruction, which is now available at the inputs of prefetch buffer 309, is gated through prefetch buffer 309 and into microword register 310, where ALU 312 will execute it during the next cycle. Alternatively, if the current microinstruction is not to branch, then the next sequential microinstruction, which, as discussed previously, is stored in prefetch register 308, is gated into microvord register 310, where ALU 312 will execute it during the next cycle.Also, if the current microinstruction is not to branch, PC MUX 30S at this time Loads PC 301 with the addres. of the next sequential microinstruction, which as previously discussed is either the contents of branch latch 314 incremented by one, or the old PC 301 contents iucremented by one. Thus1 at the start of execution of the next microinstruction1 its address is contained in PC 301 if it was reached sequentially. Conversely then, if the next microinstruction was a branch target, the contents of PC 301 are disregarded and the microinstruction s address will be found, a. discussed above, in branch latch 314.Sequential execution from that point will proceed accordingly from either the PC 301 or the branch latch 314 addresses. Figure 4 shows the timing when executing the microinstruction sequence of Table 1 on the microcomputer using the present invention. During microinstruction cycle 1, microinstruction 100 is executing. In the present embodiment, the microinstruction cycles are each 140 nanoseconds ns in duration. During the first 70 ns of cycle 1, microinstruction 101 the next sequential microinstruction is prefetched, as previously discussed, to prefetch register 308. During the last 70 no of cycle 1, microinstruction 400 the target of the conditional branch of microinstruction 100 is prefetched, as discussed above, to prefetch buffer 309.At the conclusion of cycle 1 the execution logic determines as has been described that the conditional branch to 400 is not to be taken thus microinstruction 101 will be transferred from the prefetch register 308 to the microword register 310, and will be the microinstruction to be executed during cycle 2, the next cycle Microinstruction 400, available through prefetch buffer 309, is ignored. During the first 70 ns of cycle 2, microinstruction 102 the next sequential microinstruction is prefetched to the prefetch register 308, and during the second 70 ne microinstruction 200 the conditional branch target microinstruction is prefetched to the prefetch buffer 309. At the conclusion of cycle 2 the execution logic determines that the conditional branch to micro instruction 200 is to be taken microinstruction 200 is transferred through the prefetch buffer 309 to the microvolt register 310 and thus will be executed during cycle 3. Microinstruction 102, in prefetch register 308, is ignored. No time is lost between microinstruction cycles because of incorrect prefetches both possibilities of a branch are always prefetched. Now follows a detailed description of Figures 4 through 15, which depict the logic circuits implementing the present invention. Refer to Figure 3 while referring to there figures, and particularly to the reference signal names shown on Figure 3.Certain timing signals will be mentioned in the discussion.Timing constraints have been discussed above, and will be further discussed in conjunction with Figure 16. The generation of timing signals to conform to stated constraints is well known in the literature and vill not be detailed herein. Figures 5 and 6 together depict the logic of branch MUX 302.A MUX a common designation for multiplexor is a device for selecting one of a plurality of signals. Branch HUX 302 is used to select one of branch addresses 311. Since control store 307 has a capacity of 4096 locations, a 12 bit address is required to address any of those locations. Branch HUX 302, then, has the ability to select one of a plurality of 12 bit branch addresses.Figures 5 and 6 depict twelve similarly configured logic groups, each for handling a different one of the requisite twelve bits, numbered Or through 11. Group 501 on Figure 5 for handling bit 02 is deemed to be representative of the twelve logic groups it has multiple inputs, those inputs being bit 02 of each of branch addresses 311 originating from bit positions of microword register 310 or from stack 315 as will be discussed further on.By means of gating, group 501 selects one of those as the one to output as signal BRADRO2. Methodologies of laying out instruction sets, including methodologies of specifying branch addresses, are well knovn in the literature and will not be discussed herein. Designs for combinatorial gating to select one of a plurality of inputs are likewise well knows, and will Likewise oot be discussed herein.In the manner in which group 501 produces signal BRADR02, all twelve logic group working in concert produce the twelve bit branch address BLADROO through BRADR11, which is input to branch address forwarding circuit 313, depicted in Figure 10. Figure 7 shows the logic comprising branch Latch 314 and branch 1 adder 304. Elements 701 through 707 comprise branch latch 314. 701 and 702 are single latch circuits, and 703 through 707 are dual latch circuit, yielding a total of 12 latch circuits for containing the twelve bit address. A latch is a bistable circuit which, when its clock input is a logic high will simply pass the state of its data input through to the data output, and which stores the state of the data input at the time its clock input transits to s logic low. The twelve bit input to branch latch 304 is the address BRAD00 through BRADll from branch address forwarding circuit 313 Figure 10 , which is stored in branch latch 314 and then appears on signal lines BRL00 through BRL11.These signal lines are input to half adders 708 through 718, which comprise branch 1 adder 304. The operation of half adders is known in the literature and will not be discussed here. The output of branch 1 adder 304 is the 11 address bits BRPAD00 through BRPAD10. Bit 11 the least significant bit is not included in the increment calculation because binary addition by one simply toggles complements the least significant bit. This toggling is accomplished at the input of PC MUX 305, to be discussed with Figure 9. The contents of bits 00 through 10, in conjunction with a toggled state of bit 11, together represent a 12 bit address which is one greater than the 12 bit address in branch latch 314. This address is output to PC MUX 305 Figure 9 . Figure 8 depicts 12 flip flops 801 through 812 comprising PC 301 and half adders 813 through 823 comprising PC 1 adder 303. A flip flop is a bistable circuit which store a state of one binary bit at the time its clock input makes a transition. Inputs are the address PCADR00 through PCADR11 from PC HUX 305 Figure 9 . Operation is similar to that of branch latch 314 and branch 1 adder 304. Outputs PCPADOO through PCPAD10 are input to PC MUX 305 Figure 9 . Figure 9 is the logic diagram of PC MUX 305. 2 1 MUX s 901, 902, and 903 each handle four bits of the total 12 bit address. Two twelve bit addresses are presented as the inputs PCPADOO through PCPAD10 and PCRll from PC 301 and PC 1 adder 303 andBRPAD00 through BtPAD10 and BRLl1 from branch latch 314 and branch tl adder 304. Note that the inverse states of the PCPAD and BILPAD signals are input to the 2 1 MUX c, but the non inverse states ofPCR11 and BBLll are input pins A3 and t3 of 2 1 MUX 903 this accomplishes the toggling of the least significant bit mentioned above in connection with incrementing by one.One of the two twelve bit addresses is selected depending on the conditions previously discussed, and is output as the twelve bit address PCADDR0O through PCADDRl1 to MUX 306 Figure 11 , and as the twelve bit address PCADR00 through PCADRll to PC 301 Figure 8 . Figure 10 depicts the logic diagram of branch address forwarding circuit 313. It receives the twelve bit branch addressBRADR00 through BRADRl1 from branch MUX 302 Figures 5 and 6 , and generates, by conventional gating means, the twelve bit branch address BRADDROO through BRADDR1l to MUX 306 Figure 11 , and the twelve bit branch address BRADOO through BRAD11 to branch Latch 314 Figure 7 . The output address has the same value as the input address, but is established in the necessary timing relationships previously discussed. Figure 11 depicts the logic diagram of HUX 306, constructed of three eight bit 3916 buffer line drivers 1101, 1102, and 1103.Each of these has the ability to function as a 2 1 HUX a logic low on pin 1 causes the signals on pins 2, 4, 6, and 8 to be passed to output pins 18, 16, 14, and 12 respectively a logic low on pin 19 causes input signals on pins 11, 13. 15, and 17 to pass to output pins 9, 7, 5, and 3 respectively. It is seen that the 24 output pins are connected together in 12 pairs. For example, pin 18 of buffer line driver 1102 bears the signal came UADDR00, and pin 9 of buffer line driver 1103 bear the same signal name. This implicitly indicate that those two pins are wired together. Thus, depending on the state of the signal UIRCLK 1101 to be discussed in more detail in the discussion of Figure 16 either the 12 bit address BRADDROO through BRADDR11, or the 12 bit address PCADDROO through PCADDRll, vill be gated through to the lines UADDt00 through UADDR1L, which act as the address input to control store 307 Figure 12 . Figure 12 is the logic diagram of control store 307, which comprises twenty five 4K by 4 bit RAM chips, resulting in a 4K by 100 bit store. The twelve bit address UADDR00 through UADDR11 is applied in parallel to each of the twenty five chip which, assuming the CWRITEn signals to be FALSE,. each output four of the bits of the location specified by the address. CWRITEn will beTRUE only when loading control store 307, not discussed herein. The 100 output lines CS00 through CS99 comprise the 100 bit output of control store 307.Only the 96 bits CSOO through CS95 are presently used in the current embodiment. Figures 13 and 14 are the logic diagrams of prefetch register 308 and prefetch buffer 309 respectively, which together comprise the dual prefetch path of the present invention. Prey etch register 308 comprises a 96 bit register, packaged as 12 octal i.e., eight circuits per package flip flop chips. It is loaded, as previously discussed, with the microinstruction that is to be executed next if the current microinstruction does not branch, the microinstruction appearing on the control store 307 outputs CSOO through C595 at the end of the first 70 ns of the 140 ns microinstruction cycle, as controlled by the signal LAST70CLKn coming TRUE.The 96 outputs SELUIR00 through SELUIR95 when enabled by the by the FALSE state of the output enable signal TESTPASSEDn are the inputs to microword register 310. If the current icroinctruction is not to branch, this microinstruction from prefetch register 308 will thus be transferred to microword register 310 and become the next executing microinstruction. Prefetch buffer 309 comprises 12 octal buffer line drivers.Note that these are not flip flopc, and thus the prefetch buffer 309 is not a register i.e., it does not store the control store 307 outputs, but only passes them on to microword register 310 .When enabled by the TRUE State of the TESTPASSEDn signal, prefetch buffer 309 passes the branch target microinstruction, appearing on the 96 control store 307 outputs CSOO through C595 at the conclusion of the current microinstruction cycle through to the microvord register 310 inputs on lines SELUIR00 through SELUIR95. If the current microinstruction is to branch, it is through this path that the target microinstruction becomes the next executing microinstruction. Figure 15 is the logic diagram of microword register 310, comprising 25 4 bit shift register chips. The inputs are the 96 lines SFLUIB00 through SELUIR9S, which as discussed above come from prefetch register 308 if the present microinstruction is not to branch, or through prefetch buffer 309 if the present microinstrucrtion is to branch. SELUIBOO through SELUIR9S will be clocked into microword register 310 by the TRUE transition of the signal UIRCLKn 1501. The outputs of microvord register 310 directly control the processing elements of the microprocessor the ALU 312 thus, the microinstruction that is loaded into microvolt register 310 becomes the executing microinstruction. Figure 16 shows detailed timings of the interactions between control store 307, prefetch register 308, prefetch buffer 309, and microword register 310 for the instruction sequence of Table 1.Line 1601 defines 3 consecutive microinstruction cycles, and line 1602 associates them with nanosecond timing. It is assumed that microinstruction 100 from Table 1 is executed during cycle 1.Given that microinstruction 100 is a conditional branch to 400, which is assumed not to be taken, we now consider how microinstruction 101 the next sequential microinstruction is executed during cycle 2. It is assumed that the currently executing microinstruction. microinstruction 100, was reached by being the next sequential instruction microinstruction to a previously executed microinstruction. As previously discussed, its address 100 is at this time contained in PC 301. Had it been reached as a branch target its address would be in branch latch 314, as previously discussed. As previously described, during the first 70 ns of cycle 1 the address 100 of microinstruction 100 is incremented by one, to 101, through PC 1 adder 303, fed through PC MUX 305 and MUX 306 to control store 307.Late during the first 70 ns of cycle 1, the microinstruction from location 101 is available at the control store output, as shown by line 1607. As line 1604 sbovs, the signal LAST70CLK 1302 goes TRUE during this time, storing the microinstruction in prefetch register 308 see Fig. 13 . As line 1608 shows, microinstruction 101 remains stored in prefetch register 308 until the next TRUE transition of LAST7OCLL, 140 ns later.During the last 70 as of cycle 1, control store 307 is accessed with the branch address of target microinstruction 400, as obtained from currently executing microinstruction 100. As previously described, this is obtained through branch HUX 302 and HUX 306. Branch target microinstruction 400 is available at the CS outputs late in cycle 1, as line 1607 shows. Reference to Figure 14 reveals that the control store outptits ar iiip bt to prefetch buffer 309 however, they will not be gated through prefetch buffer 309 at this time because signal TESTPASSED is not TRUE line 1606 .TESTPASSED is TRUE if the current microinstruction is to branch, and our assumption is that current microinstruction 100 will not branch. Meanwhile, with reference to Figure 13, the FALSE state of TESTPASSED 1401 enables the contents of the prefetch register 308 those contents being microinstruction 101 to be gated onto the SELUIR lines, as shown on line 1609. At time 140 nc, signal UIRCLK goes TRUE line 1605 . Referring to Figure t5, this transition of UIRCLK clocks the SELUIR lines into Kicrovord register 310 line 1611 . Thus, microinstruction 101 occupies the microword register, and is the currently executing instruction, during cycle 2.The value 101 is transferred from PC MUX 305 on signal lines PCADR00 through PCADR11 into PC 301 for use in the fetches that will take place during cycle 2. Since Table 1 assumes that microinstruction 101 includes a conditional branch to 200 that is to be taken, microinstruction 200 will occupy the microword register during cycle 3. Similarly to cycle 1, the next sequential control store location location 102, the address being obtained by taking the value 101 from PC 301 and incrementing it to 102 in PC 1 adder 303 is accessed during the first 70 ns of cycle 2 line 1603 and microinstruction 102 is available at the control store outputs line 1607 in time to be gated by LAST7OCLK into the prefetch register line 1608 . The incremented address 102 is stored in PC 301.Control store location 200 the target address obtained from microinstruction 101 is accessed during the second 70 ns of cycle 2 line 1603 , and branch target microinstruction 200 is available at the control store outputs a nd prefetch buffer inputs late in cycle 2 line 1607 , The value 200 is stored in branch latch 314. ALU 312, having determined that this branch is to be taken, will raise the signal TESTPASSED line 1606 .Referring to Figure 13, TBSTPASSED inhibits gating next sequential microinstruction 102 from the prefetch register onto the SELUIR lines line 1609 with reference to Figure 14, TESTPASSED enables gating branch target microinstruction 200 through the prefetch buffer onto the SELUIR lines. t time 280 ns, UIRCLK transits to TRUE line 1605 . Referring to Figure 15, this clocks branch target microinstruction 200 from the SELUIR lines into microword register 310. Thus, branch target microinstruction 200 is executed during cycle 3. During the first half of cycle 3, microinstruction 201 is to be prefetched line 1607 . Since the currently executing microinstruction 200 was reached because it was a branch target,PC 301 will not come into play the value 200 is stored in branch latch 314, and branch 1 adder 304 increments to the required address of 201. During the last half of cycle 3, executing microinstruction 200 specifies 500 as its target address, and microinstruction 500 is prefetched. One of the two will be selected to execute during cycle 4, not discussed herein. Now follows z discussion of stack 315 and stack pointer 316. A prior art scheme for addressing a stack is shown in Figure 17. Stack 1703 is a memory device with some number of memory locations, here four. Stack pointer 1701 is a, flip flop register for containing the address of the location in stack 1703 which it is desired to access. Incr ement decrement means 1705 can add or subtract by one the contents of stack pointer 1701. Since stack locations are addressed in sequence, no provision is needed to load stack pointer 1701 with arbitrary contents, as would be the case for a random access memory. Stack pointer 1701 must be able to contain as many values as there are location in stack 1703. Since stack 1703 has four location, the two bit positions of stack pointer 1701 can be incremented through the four combinations 00, 01, 10, and 11. In order to select a particular one of the four locations in stack 1703 it is typically necessary to enable an , address selection line by decoding the contents of stack pointer 1701.Decoder 1702 comprises combinatorial gating to recognize each of the possible contents of stack pointer 1701 and enables the corresponding one of the four address selection lines 1706, which results in transferring data between the corresponding location of stack 1703 and bus 1704. Operation of storage devices is well known in the literature and will not be discussed herein. Additional gating may be incorporated in decoder 1702 in order to detect overflow and underflow . By convention, a stack is said to overflow when an attempt is made to exceed the capacity of the stack it is said to underflow when an attempt is made to retrieve data from a stack when no data has previously been stored in it. Figure 18 presents an overview of the stack addressing scheme of the present invention. Stack 315 contains four twelve bit locations, each of which is enabled by one of the address selection lines 1802. Each of address selection lines 1802 is the output of a stage of stack pointer 316, which is not, as in the prior art, an incrementidecrement register, but is a shift register.Stack pointer 316 must contain at least as many stages as there are locations in stack 315. In the present embodiment, the number of stages in stack pointer 316 is two greater than the number of locations in stack 315. As will be discussed below, the two additional stages aid in detecting overflov. Stack pointer 316 is initially loaded with one 1 bit in its rightmost stage stage 5 and is filled out with 0 bits. The 1 bit is shifted left after each stack write, and shifted right after each stack read.The stage containing the 1 bit at a given time has its output in the TRUE state since the output lines of stack pointer 316 are in fact the address selection lines 1802, the correct address selection line is TRUE without the necessity for any of the gating or decoding which the prior art schemes require. Since many applications require stacks to operate quickly, it is an advantage that the delays associated with gating are eliminated.While the shifting of the bit is left to right as described above, this can be reversed and still result in utilizing the invention described herein. The present embodiment uses stack 315 for only one purpose storing the addresses of microinstructions following cell microinstructions for subsequent use by return microinstructions. If, for example, microinstruction 700 is a call microinstruction that invokes a subroutine, the address 701 derived, as previously discussed, by incrementing the 700 in PC 1 adder 303, passing it through PC HUX 305 onto the PCADR00 through PCADRll lines and loading it into PC 301 is output from PC 301 and stored on the top of the stack.When the subroutine executes a return microinstruction, the address 701 is retrieved from the top of the stack and input to branch MUX 302 as the next microinstruction address. Execution thus returns to the microinstruction following the call microinstruction. In the present embodiment, the contents of PC 301 are written to the next available stack location every microinstruction cycle. However, stack pointer 316 is shifted to the left only if the current microinstruction is a conditional call microinstruction and if the specified conditions are met.Therefore, only the PC 301 contents which are in fact the return addresses of call microinstructions that cause branching are retained in the stack for all other microinstructions, failing to shift stack pointer 316 results in keeping the same stack 315 location selected, and it will the contents will be overwritten during the next microinstruction cycle. As has been discussed, stack pointer 316 is initially set to all zero bits except for s 1 bit in stage 5. The 1 bit in stage 5 selects location 3. When location 3 is written into on a call microinstruction, the stack pointer 316 is shifted one stage to the left after writing so that the 1 bit is in stage 4, selecting location 2. Three more call microinstructions would result in filling locations 2, 1, and 0, shifting the one bit to stages 3, 2, and 1 respectively, at which point the stack vould be full.Another attempt to store a return address in stack 315 shifts the one bit to stagy 0. Nothing is actually written to the stack, there being no stack location associated with stag. 1 of stack pointer 316. This constitutes overflow, but the present embodiment does not detect overflow until an attempt is made to retrieve the data that could not be written. The next attempt to read from stack 315 an attempt to read back the data that could not be written produces the OVERFLOW signal from gate 1803. When the stack is empty whether because nothing has ever been written in it or because everything written in it has been read back the 1 bit will be in stage 5 of shift register 316. An attempt to read the stack at that time will not shift stack pointer 316, but will produce the UNDERFLOW signal from gate 1804. Figure 19 shows the logic diagram of stack pointer 316. It comprises six D flip flops. A Dflip flop captures and stores the state of the D data input at the time the CLK input transits to z logic high. Stage 0 is depicted at the top element 1903 conventionally called the left and stage 5 associated with the first location in stack 315 at the bottom element 1904 conventionally called the right . Gating group 1901 is enabled by the BR TYP bits of the currently executing microinstruction being equal to 01, specifying a conditional call microinstruction, and by the TSTCNDO signal indicating that the requisite conditions are met, to produce the C STKC signal indicating that a call microinstruction is to be performed. Similarly, BR TYP bits being equal to 11 and TSTCNDO produce signal R STKC from gating group 1902 indicating that a return microinstruction is to be performed. On a call microinstruction, C STKC shifts stack pointer 316 to lower numbered stages by convention, to the left , denoting subsequent stack locations. For example, gate 1905 is enabled byC STKC and STKC3 the state of stage 3 and gates that state into stage 2. Similarly, on a return microinstruction, STKC shifts stack pointer 316 to higher numbered stages , to the right . Gate 1906, for example, shifts the state of stage 2 into stage 3. STXC2, STKC3, STKC4, and STKC5 the outputs of stages 2 through 5 respectively are passed through lii MUX 1907, enabled by the RESTORE signal, onto STKW 0, STKW 1, STKW 2, and STKW 3 respectively, which are address selection lines 1802. The circuitry implementing stack 315 is shown in Figure 20.Each of the four locations is constructed of six dual D flip flops. A dual D flip flop combines two D flip flops in a package. For example, element 2011 stores bits 0 and 1 of location 0, pins 1 and 3 being the inputs for bits 0 and 1 respectively, and pins 7 and 9 being the outputs for bits 0 and 1 respectively. Element 2011 requires ST W 0 of address select lines 1802 on pin 4, since it is part of location 0. Each of the four locations 2001, 2002, 2003, and 2004 is enabled by STKW 0, STKW 1, STKW 2, and STKW 3 respectively. Stack 315 is used to store the contents of PC 301, as discussed previously. The outputs of PC 301, namely PCR00 throughPCR11, are passed through 2 1 MUX s 2012, 2013, and 2014 under control of the RESTORE signal onto the STKIOO through SKILL lines, which are input in parallel to each of the four stack locations they are stored in the one location currently enabled by address selection lines 1802, as described above. Note that the contents of PC 301 are stored in stack 315 every microinstruction cycle however, stack pointer 316 is not shifted left except when call microinstructions are executed, as described above. Therefore, information written into stack 315 is not saved except for call microinstructions if stack pointer 316 is not shifted, data written into a stack location during a microinstruction cycle will be overwritten the next microinstruction cycle. Figure 21 depicts logic circuits for generating signals required by branch HUX 302 and branch address forwarding circuit 313 to for implementing return microinstructions. Gates 2101, 2102, 2103, and 2104 are enabled by the BR TYP bits of the currently executing microinstruction being equal to 11, denoting a return microinstruction. Each is enabled by one of the stages of shift register 316, denoting a location in stack 315 as previously discussed. For example, gate 2103 is enabled by STKC3, meaning that stack location location 1 is presently selected to be written into. This in turn means that stack location 2 is the last stack location with a return address stored in it. Gate 2103 therefore produces the signal STK2 BR, denoting that the address contained in stack location 2 is now to be used as a branch target address. Branching to the location whose address is contained in stack location 2 is initiated by branch MUX 302 Figures 5 and 6 . Using bit 02 as an example, and referring to Figure 5, gate 502 is enabled by STKZ BR just discussed and passes STK 02, which reference to Figure 20 discloses to be bit 02 of stack location 2. Logic group 501 then outputs BRADRO2. Similarly, the other eleven logic groups depicted in Figures 5 and 6, together with group 501, output the 12 bit address BRADROO through BRAI Rll, which results in branching to that address, as was previously discussed. In the event of errors in microcode resulting in stack overflow or stack underflov, the address produced by branch MUX 302 as just described is indeterminate, and attempts to branch to such an indeterminate address will produce indeterminate results. In such cases, computers generally trrp, i.e., force microinstruction execution to the start of a sequence that directs the machine to recover from the error in as orderly a manner as possible. By design convention, the current embodiment traps to the microinstruction at control store 307 location I if stack overflow is detected, and to the microinstruction in location 2 in the event that underflow is detected. There now follows a discussion of how there traps are implemented. Overflow is detected by gate 1803, shown in detail on Figure 21. TYP bits equal to 11, indicating a return microinstruction, and STKC0, indicating a prior attempt to write beyond available location in stack 315, as previously described, produce the signal STYOVFL denoting overflow. Gate 1804, responsive to BR TYP bits specifying a return microinstruction, and STKC5, indicating that the stack is empty as previously discussed, produce the signal STKUMFL denoting underflow.Either of these signals causes gate 2105 to produce the STKERR signal. Refer now to branch address forwarding circuit 313, Figure 10. Reference to each of the gates 1001 through 1012 shows that in order for the address BRADR00 through BRADS11 to be passed to lines BRADDROO through nRADDRl1, STKERR, STKUNFL and STKOVPL must all be absent. If STLOVFL and STKERR are present, all twelve output bits vill be zero except for BRADDR10, which will be a one because of STKUNFL enabling gate 1011. This bit pattern represents the requisite address of 2. Likewise, if STKOVFL and STKERR are present, all twelve bits will be zero except for BRADDR11, which will be a one because STKOVFL enables gate 1012. This bit configuration represents the requisite address of 1.