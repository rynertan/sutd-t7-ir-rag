# A METHOD OPERABLE WITHIN AN OPTIMIZING COMPILER

## Claims
Verfahren, das innerhalb eines optimierenden Compilers zum Erzeugen von Basiseinheiten und Unterdrückermengen zum Verwenden während nachfolgender Verfahren zum Eliminieren eines globalen, gemeinsamen Unter Ausdruckes und zum Code Bewegen durchgeführt werden kann,

## Description
The present invention has particular utility in a compiler in which optimization algorithms are used to improve the quality of the code. In particular, when the concept of a Basis item as taught in co pending application EP A 171631 is employed for global common subexpression elimination and code motion, this invention comprises an optimal method for establishing the Basis during the intermediate code generation process. While this invention will find utility in optimizing compilers for all types of computers, it has particular significance for reduced instruction set computers, for which the code produced by compilers is often more voluminous than code produced for complex instruction set computers, because each instruction of a reduced instruction set computer is simpler and performs less function. There is more opportunity and need for optimization in code produced for a reduced instruction set computer. The quality of code produced by compilers has been an issue ever since the first compiler was produced. One of the principal objectives of IBM s FORTRAN I compiler, the first commercially available compiler, was to produce object code in the field of scientific computation which was comparable in code quality to that produced by assembly language programmers. Today, higher level languages are designed to be used in every field in which computers are applicable. Even the original FORTRAN language has been bolstered to make it applicable to a wide range of programming tasks. However, it is still important that the quality of code produced by the compiler be high, especially if the resultant code is to be used in a production environment. Code produced by a skilled assembly language programmer is still the yardstick against which compiler produced code is measured. A large number of optimization techniques have been developed and refined since the 1950 s to improve the quality of compiler generated code. Indeed, many of these optimizations were known in principle, and used in some fashion by the team that produced the first FORTRAN compiler. Optimizations that are frequently employed in optimizing compilers include common subexpression elimination, moving code from regions of high execution frequency to regions of low execution frequency code motion , dead code elimination, reduction in strength replacing a slow operation by an equivalent fast operation , and constant propagation. Descriptions of these optimizations can be found in The above mentioned references describe how to perform global common subexpression elimination and code motion on the premise that the above mentioned sets are known for every basic block. In particular, these references describe how to compute the set of computations already available on entry to a basic block, and the set of computations to be inserted at the end of certain basic blocks to achieve the effect of code motion, based on the sets DEX, UEX, and THRU. These computations are well known to those skilled in the art. Unless care is taken in computing UEX, DEX, and THRU, the commoning and code motion algorithms known in the prior art may only common and or move the first of a sequence of related computations. For example, consider the code fragment in Table 1 It is easy U.S. Patent 4,309,756 discloses a method for evaluating certain logical computations. The disclosed concepts are narrow in scope and anachronistic for a patent issued in 1982. It is primarily background art in that it sheds no light on naming computations so that potentially redundant computations are given the same name. U.K. Patent 1,413.938 is concerned with techniques for testing compiler output for correctness. It could be used to test the correctness of code generated by an optimizing compiler. However, it bears no relevance to how the optimizing compiler generates code in general, or how it achieves its optimizations. U.S. Patent 4,277,826 uses hashing to maintain a virtual address translation mechanism. The present invention uses hashing to quickly reference computations previously encountered in the compilation process. However, hashing is a minor detail in the embodiment of our invention. Copending application EP A 171631 teaches how to avoid the difficulties in optimizing the code in Table 1, by introducing the concept of a determination of Basis for computations. From the Basis the other sets of data required for commoning and code motion can then be derived in a manner which will allow the standard global commoning and code motion to exploit all opportunities for code improvement in only one application. The present disclosure teaches how a computation Basis can be established easily during parsing and intermediate language code generation. It also shows how to assign symbolic registers to non basis items in such a manner that computations which are potentially redundant are assigned to the same symbolic register. The PL 1L compiler, which is discussed in Cocke, J. and Markstein, P., It is an object of this invention to introduce the concept of a It is a further object of this invention to assign names to non basis computations i.e to the formal identity which represents the non basis computation so that the same computation performed on Basis elements is always given the same name. In this manner, computations which are candidates for common subexpression elimination are given the same name. Names of non basis computations are called symbolic registers in the present description. It is a further object of this invention to derive the formal identity or symbolic register for a tuple consisting of an operator and a string of operands. It is yet another object of this invention to compute the kill sets , which for each basis element are the non basis computations or symbolic registers which depend on the value of the basis element. The present invention is defined in the attached claims. The objects of the present invention are accomplished in general by a method operable within an optimizing compiler for generating Basis items and Kill Sets for use during subsequent global common subexpressions eliminating code motion procedures. More particularly, the method comprises assigning a symbolic register to each non basis element to be computed as follows creating a tuple v for each computation which is to be compiled to a machine instruction by the compiler, a table optimally, a hash table is created for all the tuples in the program being compiled for every Basis element in a tuple being entered in the table, a symbolic register uniquely assigned to that tuple is added to the Kill Set for that Basis element for every non basis element n in the tuple being entered into the table, the uniquely assigned symbolic register for that tuple is added to the Kill Sets for all the Basis elements in whose Kill Sets that non basis element n appears the symbolic register assigned to the tuple in the table is chosen to hold the result of the computation of the non basis element and finally, a second table is constructed so that a given symbolic register, and then the computation which it represents can be retrieved. Figure 1 is a very high level functional flowchart of an optimizing compiler in which the present invention has utility. Figure 2 is a high level flowchart of the optimizing phase of an optimizing compiler in which the present invention has utility. Figure 3 is a high level flowchart of the global common subexpression and code motion algorithm which is used in an optimizing compiler, and in which the present invention has utility. Figure 4 is a high level flowchart of a routine which converts tuples describing an operation into symbolic registers, and shows how the kill sets are developed. In the drawing, like elements are designated with similar reference numbers, and identical elements in different specific embodiments are designated by identical reference numbers. The present invention provides a method by which the Basis for the computations in a program being compiled, and the Kill Sets for the basis items, can be determined during parsing and code generation time. This invention makes it unnecessary to determine the Basis and Kill Sets by later analyzing a program produced by the early phases of a compiler. The following is a bit of definition of a number of terms used in the description of the present invention. These definitions are coextensive with the definitions of the same types as used in copending application EP A 171631. To continue with the present description, take the following items as a computational basis Thus, basis elements can be determined as they are encountered, either because the use of a user variable was encountered, or a declaration of a user variable was encountered, or a user variable requires a descriptor at execution time, or references are made to heaps or stacks belonging to the run time environment, or the compiler must generate a distinguished temporary, or the compiler must make reference to object code i.e. a branch instruction . Whenever a non basis element is computed, it is assigned to a symbolic register as follows Thus the present invention causes two convenient tables or maps to be set up one map best implemented as a hash table which goes from tuples that describe operations to symbolic registers, and a second, from symbolic registers to the tuple that defines the operation. The symbolic registers can be viewed as formal identities for the computations on Basis elements. By the above construction of the symbolic registers, each symbolic register represents a unique computation using Basis elements as operands. Each symbolic register becomes a member of the Kill Set for each Basis element in the computation it represents. Because of the manner in which the symbolic registers were constructed from the Basis, they always represent the same computation, independent of where the symbolic registers are computed in the program. Thus they are natural objects for global common subexpression elimination and code motion. The figures which comprise the flowcharts of the present invention are largely self explanatory. FIG. 1 is a very high level flowchart for a compiler as is well known in the art. Blocks 1, 2, 4 and 5 are quite straightforward and well known. Block 3 entitled Code Optimization is the phase of the compiler activity to which the present invention applies. FIG. 2 is a flowchart of the optimization phase for such an optimizing compiler. The operations performed in Blocks 2, 3 and 4 are straightforward and well known in the art. Block 2 is the area of the optimizing compiler to which the present invention applies. This block is shown in expanded form in FIG. 3. FIG. 3 is a flowchart for the global commoning and code motion phase of the compiler. As stated previously in the specification, this overall objective is well known in compiler design. The specific manner in which the function is performed is set forth generally in copending application EP A 171631. In this application the overall compilation procedure as well as the concept of developing Basis and Kill Set Items is discussed and described in detail, as well as the means for using these items to determine UEX, DEX, THRU lists, e.g., Block 2 at FIG. 3. Also as discussed in the copending application applicants reference no. YO9 83 119 , the three blocks designated 3, 4 and 5 in FIG. 3 are similarly indicated as being within the prior art and are discussed and described for convenience of reference purposes only. Examples and sample programs for computing AVAIL and INSERT utilizing UEX, DEX, and THRU are set forth. Thus the particular way in which the Basis and Kill Sets are determined comprise the subject matter of the present invention and as indicated in the figure this method is described in detail in FIG. 4. FIG. 4, as is apparent, is a flowchart of the details of Block 1 of FIG. 3 in which a list of the Basis Items and Kill Sets for the individual basic blocks comprising a particular program are formed. Block 1 of this figure is in essence merely a definition of the sequence of tuples which are supplied to this phase of the compiler activity in sequence for each basic block. The first actual procedural step is in Block 2 where the system computes a hash function by some conventional means from the data content of the complete tuple v . As is well known this hash function is then used as an address into some sort of table or memory and the existence of data at that particular address is tested for in Block 3. If the address in the table contains the tuple v it means that this tuple has been previously processed and the system would proceed to Block 4. This block causes the symbolic register r associated with the tuple v to be returned to the system. Thus, the output of block 4 would be a list of symbolic registers each of which would be intrinsically different if the tuples were different. Obviously, if the tuples were identical the same symbolic register indication would be given. Assuming that the output from Block 3 is no, the system would then proceed to Block 5 which causes the particular tuple to be stored at the appropriate address in the hash table and causes a new symbolic register r to be assigned to that tuple and appropriately stored in the hash table at the hash address derived from the tuple. The system then proceeds to Block 6 wherein a parameter k for the tuple is set to a 1. The system then proceeds to Block 7 wherein the current value of the register k is compared against the number of operands in the tuple v. It will be noted in this connection that the number of operands in the particular tuple may be preprocessed and stored in the hash table together with the tuple or may be computed on the fly in Block 7 as will be apparent to those skilled in the art. In any event, if the value k is found to be greater than the number of operands in the tuple, the system will know that it has completely evaluated the tuple and will branch into Block 4, described previously. If, on the other hand, an equality or less than condition exists, the flow continues to Block 8. In Block 8 a test is made to see if the specific kth operand is in the list of Basis items, which list of Basis items would have been computed, in Block 1 of FIG. 3. The Basis list may be easily derived from the intermediate language listing as described previously. If the kth operand is found to be in the Basis the system branches to Block 9 wherein the particular symbolic register r is added to the kth operand s Kill Set. If, on the other hand, the operand had not been in the Basis, the system would proceed to Block 10 wherein the list of Kill Sets is examined and for every one containing the kth operand the symbolic register r associated with the present tuple is added. Both the Blocks 9 and 10 proceed to Block 11 which is a control block that increments the value of k to provide an exit to Block 4 when all operands that have been evaluated or to index the system to the next operand for appropriate evaluation. The above description of FIG. 4 describes the operation of the present invention in a functional manner indicating the manner in which symbolic registers are assigned to the various tuples and the way in which the Kill Sets are progressively built as a particular program sequence is evaluated. The following description of the subprogram for Block 4 is a much more detailed description of the operation of the present invention. The following PL 1 subprogram shows code which accepts the description of an instruction to compute a non basis item, and returns the symbolic register which holds the result. The program also constructs the kill sets for each basis item, and constructs a map from which, the instruction represented by a symbolic register can be retrieved. Details about how certain array sizes are determined, how the arrays are allocated, and how the compiler recovers if the array sizes are too small are not dealt with in this example subprogram, because these issues are orthogonal to this invention. Standard space allocation algorithms, fitting with the compiler s overall storage management philosophy, would be used for these matters.