# METHOD FOR ASSIGNING VALUES TO A HALF TONE THRESHOLD MATRIX

## Claims
Verfahren zum Bestimmen von Schwellenwerten für Zittermatrizen für Zweipegel Anzeigesysteme und zum Zuordnen eines geordneten Wertes zu jedem Element einer 3 x 3 Element Halbtonmatrix,

## Description
This invention relates to apparatus which will produce from a single scanned in gray scale image several kinds of halftone outputs, including a low resolution flicker free halftone output for a cathode ray tube CRT display, and high resolution halftone output suitable for office quality hard copy. An improved halftone pattern for CRT use is also described. In printing systems which edit images and text, one common procedure is to scan in data, to edit the material through the use of a CRT display and to print the edited result. The input data can be character coded text read from magnetic media, and continuous tone or halftone images scanned in through a raster input scanner RIS . The RIS output is assumed to be gray scale data of, for example, eight bits per pixel. There are different halftone patterns for CRT displays and hard copy printing. In a halftone pattern for a CRT, the white and black picture elements are relatively uniformly distributed over the area and the resolution is low, 3.2 picture elements pixels per mm for example. For hard copy, the pixels are grouped into white and black dots of varying sizes and the resolution is high, 19.2 picture elements per mm for example. For the production of these different halftones, two programs or, for higher speed, two circuits are required. An improvement would be to design a single circuit that can produce both patterns efficiently from the same scanned in image data base. An additional problem with a CRT halftone pattern is that it may cause objectionable flicker in a CRT with an interlaced raster. To be specific, in the system described herein, a full CRT display is produced at the approximate rate of 15 displays per second, and at this rate a noticeable flicker would be obvious to the viewer. To correct this, odd rasters are used to create one display and even rasters are used to create the next. The result is an apparent rate of 30 displays per second which does not flicker. The above would be usable for text and line graphics in white and black, but for halftone images a flicker may still be created if the bits selected to represent gray tones are predominantly located on odd or even rasters. This problem of flicker is mentioned in Digital Video A Buffer Controlled Dither Processor for Animated Images by C N Judice, IEEE Transactions, Vol COM 25, No. 11, Nov 77, pp 1433 1440, and Two and Three Dimensional Ordered Dither in Bi Level Picture Displays by B Lippel, Proc. of the SID, Vol 17 2, second quarter 76, but neither discloses this invention nor renders it obvious. In this case, some portions of halftone images will flicker. For example, in US A 4 032 978, Fig 2A, there is shown a halftone pattern wherein the first four pixels, 0,1,2 and 3 are all placed in odd numbered columns. If the display first shown the odd columns and then the evens , the odd display will have four more black bits than the even , and a noticeable flicker will result. Similarly, in US A 4 185304, in the left hand five columns of the Fig 1 matrix, if bits 1 6 are black, the row starting with matrix element 2 will have four more black bits than the row above. Here again there will be a noticeable flicker because of the alternating displays of odd and even rows. The solution is to use a halftone pattern which guarantees that for all levels of gray, the number of black pixels on odd and even lines are approximately equal. The invention will now be described by way of example with reference to the accompanying drawings, in which After the text and image data are scanned or otherwise loaded into the system, the next step in the editing process is to bring the images and text for a first page up on the display, to vary the image size, location, density, contrast, etc., and to position any text on the page. When the page is in final form, it can be printed, stored, transmitted, etc. In order to display the image data on the screen and to print it, halftone patterns are required. The pattern used for printing in this system, shown in Figure 1, is a double spiral 8 x 8 matrix with gray levels varying from 0 to 62. As is well known, as the original image data progress from white to black, the size of the white portions becomes smaller and the size of the black portions becomes larger. While this pattern produces good results with a xerographic printer, a system which spreads the pixels more uniformly over the area is better suited for a CRT display. A known dither pattern for use in a flat panel is shown in Figure 2. This type of pattern spreads the pixels over the area but doesn t have enough levels. Four of these dither patterns can be combined into the two level ordered dither pattern of Figure 3 to provide sixteen levels. However, it cannot be used in a system using interlaced rasters on a CRT because of the flicker that will be generated at certain density levels. For example, assume a density level of 4. Then pixels 1, 2, 3 and 4 will be black, the rest white. On every display of even rasters there will be four black pixels rows 0 and 2, pixels 1, 2, 3 and 4 but on every odd raster rows 1 and 3 all pixels will be white. A visible flicker results. The knight tour halftone pattern shown in Figure 4 has the even distribution characteristic of the pattern of Figure 3 and will produce a minimum of flicker on an interlaced raster CRT display. However, it has only nine levels. The knight ordered dither pattern of Figure 5 combines four knight ordered patterns into a single 6 x 6 matrix containing 36 levels. Since there are three rows separating the corresponding pixels of each 3 x 3 quadrant, the difference in the number of black pixels per matrix between odd and even scans is never more than one. For a greater number of levels, the knight knight dither pattern of Figure 6 can be used. This is a 9 x 9 matrix comprising nine 3 x 3 knight tour segments, the nine segments themselves being a knight tour rather than ordered dither as in Figure 5 . In Figure 6, the first twenty nine levels are shown to indicate the pattern. The imbalance in this case will be minimal 13 to 16 and the dispersion over the area is sufficient to create an apparently flicker free display. A knight ordered Pattern thus has three useful characteristics. It evenly distributes the black pixels over the matrix, it sufficiently balances the pixels between even and odd scans, and, as will be explained below, it can be produced by the same circuit that produces the hard copy pattern of Figure 1. The circuit for producing both of these halftone patterns is shown in schematic form in Figure 8 and in conceptual form in Figure 7. Referring to Figure 7, a random access memory RAM with a maximum capacity of 16 x 16 words, each 8 bits long, is loaded with the threshold values for either the entire Figure 5 or Figure 1 matrix. For this discussion, assume the 6 x 6 matrix of Figure 5. Then the first six rows of the first six columns of the memory will be loaded. That is, locations 0, 1, 2, 3, 4, 5,16,17,18,19, 20, 21, 32, 33, etc. Also, both scan counters will be set to modulo 6. Finally, in the hardware, the Along Scan Counter is incremented after every pixel, the Across Scan Counter is incremented at the end of each raster, and each output screen threshold data word is compared against the corresponding gray image data word at the comparator. In this case, location 0 in Figure 7 would have the value for the row 0, column 0 element of Figure 5, which shows a threshold level of 21. Then, as the series of pixels in the raster is compared, a series of halftoned binary bits will be output from the comparator as the screened image data . To change from producing the 6 x 6 knight ordered dither pattern to the 8 x 8 double spiral pattern of Figure 1, the first eight rows of the first eight columns are loaded with the thresholds appropriate to the new pattern, and the counters are changed to modulo 8. It should now be clear that this circuit can be used to generate any number of halftone patterns of any size up to 16 x 16 pixels by loading the appropriate threshold values in the RAM and resetting the counters to the appropriate values. In fact, a 1 x 1 matrix is also used. This is the threshold for text and line graphics which can be black or white. In use, the threshold level is loaded in the first location and all pixels are compared to it. The actual schematic diagram of this circuit is shown in Figure 8. The Across Scan Counter 71 is loaded through lines Screen Size 00 03 with a negative value when write enabled by line Load Screen Cntr0. Counter 71 then proceeds to count up to zero, generating a Screen Carry 0 overflow signal when it reaches zero. During the counting process, the four output lines Screen Addr 00 03 are used to address RAM 73. Counter 72 operates identically to produce the other four address bits, so that the entire 256 word RAM can be addressed. In operation, the Along Scan Counter is incremented for each pixel clock and reloaded at the end of each matrix, while the Across Scan Counter is incremented at the end of each line and reloaded at the end of each matrix. The threshold values, ThreshVal 00 07 are load enabled by line Wr Screen Clk, and the eight outputs Threshold 00 07 are coupled to the comparator 75, 76 along with the gray image data Gray Pixel 00 07. The output line of the comparator is labeled Screened Pixel. Gate 77 allows the Across Scan Counter 71 to increment at the end of each line. Gate 78 restarts the Across Scan Counter 71 at row 0 of the matrix if a line is completed and if the last matrix row is completed which is when Counter 71 overflows and generates a carry out, Screen Carry 0 and at the start of each page. Gate 79 restarts the Along Scan Counter 72 at column 0 if the Counter 72 overflowed or if there is a screen size or line change. So far in this discussion, it has been assumed that threshold levels would be evenly distributed over the range of inputs. For example, Figure 5 assumes an even density distribution of threshold levels from 1 to 36. This is shown in graphical form in Figure 9, curve number 1. Threshold number 1 in Figure 5 will be assigned a gray scale value of 1 as shown in curve 1 of Figure 9, threshold number 2 will be assigned a value of 2, etc. Thus, gray scale values will be compared against an evenly distributed set of threshold values in the comparator and the output density and contrast of the copy will equal those of the original. A further improvement, which can be incorporated into the system, is to make the various threshold levels adjustable by the operator through the use of interactive software. The need for this capability arises when the operator sees that the scanned image does not have enough contrast, density, etc. This software then gives the operator the capability of adjusting these parameters before printing. Ideally, the CRT and printer are both varied identically to allow the operator to see the adjusted image prior to printing. For example, as shown in Figure 9, curve 3, to increase the contrast, all threshold numbers of 8 and below will be assigned a gray scale value of zero, and all threshold numbers of twenty eight and above will be assigned a value of thirty six. This will result in a greater than normal probability of all black and all white areas on the copy, and increase the contrast of the copy over that of the original. Similarly, the average density can be varied by shifting curve 1 to the right or left. In fact, any shape of curve can be created with the appropriate software. As an example of this software, the program of Figure 10 generates a family of curves similar to that shown in Figure 9 for the knight ordered dither pattern of Figure 5. This program is written in Mesa which is a variant of Pascal, and is provided in the software to allow the operator to control the tonal rendition curve on an interactive basis. The program of Figure 10 allows the operator to change both the bias and the shape of the Figure 9 curve with a single parameter picptr.density. After declaring some local variables, the program also declares the halftone cell, screenRecord, to be a two dimensional array with appropriate fillers. Next, rowTable and columnTable are declared. The value of each pair of row column elements in the table is the coordinates of a picture element in the halftone cell, and the ordering of the coordinates in rowTable and columnTable is the order in which increasing values should be placed into the cell to create the 6 x 6 Knight Ordered Dither pattern of Figure 5. To compute screen values, the program first checks for the value zero in picptr.density. Picptr.density, although not shown in Figure 10, is an integer parameter in the range of 0 to 71. This is a special case, and indicates that the image data are to be treated as line art and should be uniformly thresholded rather than halftoned. If picptr.density is zero, the screenRecord will be loaded with a single value, 20. Otherwise, picptr.density contains some positive non zero value, and a Knight Ordered Dither cell will be constructed. If the value is equal to or less than 36, the increment between successive threshold values is effectively maxGrayValue divided by picptr.density. The first FOR loop places the successive values into the halftone cell using columnTable and rowTable to place the thresholds in their correct Knight Ordered Dither position. The process starts with the value zero, and effectively terminates the generation of thresholds such that the highest value is limited to maxGrayValue minus one. Since the entire screen array was preset to all ones prior to entering the FOR loop, all picture elements not addressed by the FOR loop will remain set to their maximum value. The generation of screen values when picptr.density is greater than 36 is handled in a fashion symmetrical to the way values were determined when picptr.density was less than or equal to 36. The increment between successive threshold values is effectively maxGrayValue divided by the difference between maxGrayValue and picptr.density. The second FOR loop places values into screenRecord using columnTable and rowTable as before, and the presetting of the screenRecord to all zeros prior to entering the FOR loop ensures that any low numbered picture elements in the screen that were not addressed by the FOR loop will be zero.