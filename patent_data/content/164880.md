# A CIRCUIT FOR MODIFYING DATA IN A DISPLAY MEMORY

## Claims
Schaltung zum Modifizieren von Bildschirmdaten in einem in Daten Arrays für die bitorientierte Darstellung organisierten Anzeigespeicher entsprechend einem ausgewählten Muster, mit

## Description
This invention relates to electronic display systems and, particularly, to a system for quickly modifying data in a display memory which is organized in arrays. A common configuration in display systems is shown in Fig. 1. The information to generate a display 12 is stored in a display memory 11. The display memory typically contains thousands of memory cells, each holding a single bit of information. Each bit or group of bits in the case of color or shaded displays of information corresponds to a small area, or pixel, in the display 12. Each memory location is used to store the intensity of the pixel. A bit represents or maps part of the display. The display 12 is typically a cathode ray tube unit in which the memory contents or some part thereof appear on the screen by scanning the memory. Display memories are usually organized into strings of pixels or words, along a scan line. Still another way of organizing the display memory is by an array or block organization. In an array organization, the pixels are organized in n by n pixels so that images extending vertically, or perpendicular to scan lines, may also be modified. An explanation of array organization in a system for updating these arrays is found in an article, A VLSI Architecture For Updating Raster Scan Displays by Satish Gupta and Robert Sproull in To change the contents of a display, no matter how arranged in the display memory, a display controller 10 see Fig.1 receives part or all of the data in the display memory, or reads the information from the memory 11, modifies the data and then returns or writes the data back into the display memory 11. The display controller 10 makes its modification in response to instructions from a processor 13. The transfer of data from the display memory, the modification of the data, and the data transfer back into the display memory consumes valuable time. A requirement for many display systems is that the images on the display 12 be updated rapidly. This is particularly true in interactive displays in which a user viewing the display 12 modifies the images as they appear on the screen. European Patent Specification No. 0,095,618 discloses a similar circuit for modifying data in a display memory which is organised in arrays of data for a bit mapped graphic display. This prior art, which is acknowledged in the preamble of Claim 1, has per data channel only a single display memory means and a single pattern memory means, and these memory means together with the logic means associated therewith operate in a consecutive, non time overlapping manner so that the overall operation of this circuit is relatively slow. The present invention is specially adapted for display memories organized in arrays to permit a faster modification of the data in the display memory. Accordingly the present invention provides a circuit for modifying screen data in a display memory, organised in arrays of data for bit mapped display, in accordance with a selected pattern, comprising For the generation of address signals corresponding to a linear pattern, the pattern generator uses a modified form of Breshenham s algorithm. For vectors, the pattern generator produces signals corresponding to the selected vector in approximately the same time as the corresponding data block is transferred from the display memory. For vectors and simple curves, the last address of a set of points corresponding to the pattern in a block of data from the display memory leads to the first address of the set of points corresponding to the pattern in the next block of data from the display memory. Furthermore, the last address and the direction of the line determines the next block of data to be retrieved from the display memory. In the manner described above, the present invention provides for high speed operation in a display controller. Other and more detailed aspects of the invention are discussed below. The present system is especially adapted for the high speed processing of straight lines vectors so that most of the following description relates to vectors. Where curved lines arcs are processed, it is so noted. Fig. 2 is a representation of a straight line, termed a vector, as it might appear on a display device, such as a CRT. The solid vertical and horizontal lines which form a grid over the vector V represent the boundaries of the organization of the display memory 11, which is organized in an array fashion. Each area enclosed by the solid grid lines corresponds to an array of data. Each pixel, or data point, of the array, here shown as an 8x8 array, is stored in a different semiconductor RAM Random Access Memory . This is true for monochrome displays. For shaded or color displays, each pixel of the array is stored in a group of RAMs. Thus, one of 64 RAMs is matched to a particular point in an array as well as to similarly located points in other similarly aligned arrays. When all 64 RAMs are addressed simultaneously, 64 bits of data appear as output signals for an 8x8 array. The same 64 RAMs accessed simultaneously at a different address form the data array for another 8x8 array. The RAMs in this description, which have a capacity of 64K byte, permit a display of arrays, each 8x8, of 256 arrays in the horizontal direction and 256 arrays in the vertical direction for a complete display on a device. Of course, this invention is not limited to the particular capacity of the RAMs comprising the display memory 11. A linear pattern, such as vector V, can be located anywhere on the display as shown in Fig. 2. To write or remove vector V to and from the display memory, the present invention reads arrays of data which are indicated by the dotted lines. These arrays are selected to best cover the modifying linear pattern. For purposes of clarification, these data arrays are called blocks hereafter to distinguish them from the data organization of the display memory. Depending upon the location of a linear pattern, such as vector V, the blocks retrieved from the display memory 11 may or may not be congruent with any one of the arrays in the memory 11. In Fig. 2, the vector V starts in the upper left hand corner of the display with the display coordinates As will be explained later in detail, the present system reads from the display memory 11 a block 12A, which is demarcated by horizontal and vertical dotted lines. After the portion of vector V contained in the block 12A is, say, inserted into the data, the block 12A is returned to the display memory 11 and the next block 12B is read from the display memory 11 for modification to continue writing in the vector V. Finally, the block 12C is read from the display memory 11 and the last portion of the vector V including the terminal point X The present system 20 which is part of the display controller 10 of Fig. 1, is shown in Fig. 3. The system has an X Y translator 21 which communicates to the display memory 11 through communication lines 31. The translator 21 generates the necessary addresses to the display memory 11 so that the data retrieved from or written into the display memory 11 are from or to the proper location. For example, in Fig. 2 the X Y translator 21 generates the proper signals to the display memory 11 so that the block 12A is retrieved from the display memory 11. However, the block 12A is not located in a single array by which the display memory is organized. Rather, as is often the case, the block 12A occupies parts of four arrays. The X Y translator 21 performs the addressing function to the display memory 11 so that the parts of the four arrays are properly retrieved. Data to and from the display memory 11 is passed through a data bus 32 which is 64 lines wide to accommodate the data of an 8x8 block. By the nature of a display memory arranged in an array, the data to and from the display memory 11 must be passed through a two dimensional barrel shifter 22 to correct for the two dimensional rotation which occurs when data is written into or read from the array organized display memory 11. See Fig. 4 of the referenced paper by Gupta and Sproull above of an illustration of the two dimensional rotation for data in array organized memories. Thus, data from the display memory 11 is loaded into the buffer array 23 or 24 after passing through the barrel shifter 22 through the bus 32. Similarly, the data from any one of the buffer arrays 23, 24 pass through the barrel shifter 22 before being written into the display memory 11. A vector arc generator 28 receives input signals from the processor 13 of Fig. 1 along input lines 36. These signals tell the generator 28 what linear pattern function to perform and where the function is to be performed in the display memory 11. The generator 28 then sends the address of the linear pattern to the X Y translator 21. These display coordinates are written as X and Y and the addresses of the upper lefthand corner pixel of each data block to be modified. These address signals are sent along a 24 bit wide data path 81 to the X Y translator 21 which in turn generates the proper address signals and timing to the display memory 11 to form the data blocks from the arrays in the memory 11. As the display memory data is read through the barrel shifter 22 and into one of the buffer arrays 23, 24, the vector arc generator 28 generates the memory locations of the vector in the data block in one of the buffer arrays 23, 24. These block addresses are indicated as x and y. The address signals are passed along a six bit wide data path 82 to one of two scratch pad arrays 25, 26. These scratch pad arrays 25, 26 are each 64 flip flops arranged in an 8x8 configuration corresponding to the organization of the buffer arrays 23, 24. Responsive to the address denoted by the signals on the lines 82, the flip flop at that address in a scratch pad array is set. A logic unit 27 is connected to each of the buffer arrays 23, 24 by a B bus 34 and is connected to each of the scratch pad arrays 25, 26 by an A bus 33. Each of these buses 33, 34 are 64 lines wide. The logic unit 27 logically combines each of the datum stored in one of the buffer arrays 23, 24 with the corresponding datum stored in one of the scratch pad arrays 25, 26 for parallel operation. The logic unit 27 is responsive to control signals on control lines 85 which determine whether the logic unit 27 is to perform a logic AND, OR, XOR, INVERT and AND function useful in color transformation, or other functions with the A and B inputs to the logic unit 27. The combined result is then returned on a return bus 35 to one of the buffer arrays 23, 24. Like the preceding buses, the R bus 35 is 64 lines wide so all the combined data moves in parallel. The different logic functions by the logic unit 27 permit a vector or arc to be written into the data block which will be transferred back into the display memory 11. The OR function allows the pattern generated by the generator 28 to be written into the data block. On the other hand, an XOR exclusive OR function for the logic unit 27 allows a pattern already in the display memory 11 to be removed by having the generator 28 generate the same pattern. The AND function allows the present system to perform another type of operation with the vector or arc generated by the unit 28. High speed operation occurs since the display memory data is moved and modified in parallel. The present system also has the generator 28 generating its address signals x,y responsive to the input signals on the line 36 while data is transferred to the buffer arrays 23, 24 from the display memory 11. Fig. 4 illustrates the particular high speed operation of the present system for straight lines or vectors. The present system operates on a 50 nanosecond clock cycle. For a straight line to be combined into a data block n from the memory 11 takes only 800 nanoseconds. This is achieved by generating eight data point addresses of that part of the vector in the data block n as the block n is loaded into a buffer array 23, indicated as buffer 1 in Fig. 4 and termed the present buffer. The other buffer array 24 is then the alternate buffer. The addresses of the data points are transmitted to the scratch pad array 25, indicated as scratch array 1 and termed the present scratch pad array. The other scratch pad array 26 is the alternate array . It takes approximately 800 nanoseconds to move the block n into the buffer array 1 and the generator 28 generates each address within 100 nanoseconds. Thus, the contents of the buffer array 1 and the scratch pad array 1 are logically combined and loaded into the buffer array 1 after 800 nanoseconds. At the same time, other operations start or COBEGIN. The next block n 1 in the display memory 11 is loaded into the buffer array 24 and designated as buffer 2 in Fig. 4. At this point the roles of the buffer arrays 23, 24 are switched so that the buffer array 24 becomes the present buffer and the buffer array 23 become the alternate buffer. Likewise, the roles of the scratch pad arrays 25, 26 are also switched. Correspondingly, the generator 28 generates the addresses for the next eight data points and sets the points in the scratch array 2. At the 1200 nanosecond mark, the contents of the buffer array 1 the alternate buffer at this time is sent back to the display memory 11. After 1600 nanoseconds, the roles of the buffer arrays 23, 24 again switch with the roles of the scratch pad arrays 25, 26. The third data block n 2 from the display memory is transferred into the present buffer array 1 while the addresses for the vector corresponding to data block is generated by the generator 28. Simultaneously, the contents of the buffer array 2, the second data block n 1, are logically combined with the contents of the alternate scratch array 2 and placed in the alternate buffer array 2. This alternation cycle continues until the complete vector is combined with the contents of the display memory. As may be seen in Fig. 4, each block of data from the display memory 11 is processed in 800 nanoseconds. Fig. 5 illustrates the detailed steps by which the vector arc generator 28 generates the block x,y addresses for a straight line to be communicated to the scratch pad arrays 25, 26 according to a modification of Breshenham s algorithm. By the nature of this algorithm, only eight points are generated for an 8 x 8 block, which maintains interpolation speed. Furthermore, the error is not cumulative, ensuring accuracy. The generator 28 also generates the display X,Y addresses and the vector direction, or octant, signals to the translator 25 to fetch the parts of the arrays stored in the display memory 11 to form the required data block. At the beginning of the generation process, the generator 28 receives the endpoint coordinates X The coordinate axis on which the vector has the projection of greatest length is the major axis. The other axis is the minor axis. Hence if DX DY, the major axis is X, and the minor axis is Y. If DY DX, the major axis is Y and the minor axis is X. If The interpolation steps shown in Fig. 5 follow separate paths depending upon which is the major axis. Since the vector follows the major axis more than the minor axis, there will be a certain offset OFF1 added to the coordinate of the major axis and a possible offset OFF2 may be added to the coordinate of the minor axis, in the calculation of the coordinates of the next data point after the current point. The offsets are each 1, depending on the vector s direction, or octant which is fixed for a given vector. The interpolation is performed iteratively. At each iteration, if X is the major axis, certainly OFF1 and possibly OFF2 are added to X and Y the display addresses , respectively, and to x and y the data array address , respectively. The offsets are identical for X and x, and for Y and y. If Y is the major axis certainly OFF1 and possibly OFF2 are added to Y and X the display addresses , respectively, and to y and x the data array addresses , respectively. An example illustrates the calculation of the X,Y addresses and the x,y addresses. Referring back to vector V and Fig. 2, the endpoint coordinates X Referring to Fig. 5, it can be seen that a determination that the vector V is in octant 7, or that the sign of DX DY is positive, implies that the procedure in generating the addresses proceeds through the left branch of the flow chart. The registers for X and Y are loaded with the initial values X The values for errors E, E1 and E2 are calculated. Ignoring the tests for the I and J counters, the procedure moves to testing the value of E. Since From the last calculated coordinates in a block and octant of the vector, the first coordinates of the first point of the vector in the next data block can be determined without interruption of the interpolation process. The X, Y values of the first point continue from the first data block, while x, y coordinates are re initialized to some corner point of the second data block. In the example of vector V of Fig. 2, the vector V has a direction indicated by octant 7. Thus, the initial x, y coordinates of each block of the vector V are 0, 0, the upper lefthand corner of block as indicted in Fig. 7. Since the starting corner and its location is known, the location of the second data block from the display memory is also known. The I and J counters keep track of the number of cycles used to perform the coordinate generation by the generator 28. The I counter at the initialization stage is set to be number of points separating the starting and terminal points along the major axis. This indicates the number of cycles required to generate the vector. In the example above, since DX is larger than DY, it is known that 22 cycles DX 1 are required to generate the coordinates of vector V. Thus the I counter is loaded with the value 21. As each cycle is performed, the counter is decremented by 1 until I equals 0, at which point the interpolation process ends. The I counter test for completion is performed after x,y are written to a scratch pad register 25 or 26, which assures that the end point of the vector the 22nd point in the example of Fig. 2 is plotted. The J counter counts between 0 and 8. At the initialization step, J is set to 0 and at each pass through the cycle is incremented by 1. The J counter is used to start the COBEGIN operations. When J equals 4, or half way into the complete 800 nanosecond cycle, the present invention loads the contents of the alternate buffer array into the display memory 11. The COBEGIN operation number 3 at the 1200 nanosecond mark in Fig. 4 illustrates this operation. At that point, the buffer array 1 which has the contents of the block n and loads the contents into the display memory 11. When the J counter is equal to 8, an 800 nanosecond cycle is complete, all 8 points for a data block being loaded into one of the two buffer arrays 23, 24 have been generated and a new generation of data points is started for the next data block. J is reset to 0 upon reaching the value 8. As shown in the flow chart in Fig. 5, at that point the J register is reset to 0, the functions of the buffer and scratch arrays are interchanged. The present buffer array becomes the alternate buffer, while the alternate buffer becomes the present buffer array. A similar operation is performed to the scratch pad arrays. At the same time, the data contents of what is now the alternate buffer and scratch pad array are logically combined by the logic unit 27 and stored in the alternate buffer. This step is illustrated, for example, on the third row of operations shown in Fig. 4. Additionally, what is now the present buffer is loaded with the contents of a block from the display memory 11. Finally, the values of x and y are initialized back to the corner values from the table in Fig. 7 for the start of this new block. The process continues until I is equal to or less than 0, at which point the vector instruction has been completely carried out. All that then remains is to merge and transmit the block just interpolated as output. This method of calculating the X,Y addresses to the translator 25 and x,y addresses to the scratch pad array 25, 26 is an improvement of Breshenham s algorithm, which interpolates vectors at any angle. The improvement interpolates lines in two general cases whether the X or Y is the major axis and the other the minor axis to permit a faster calculation of the X, x, Y and y coordinates. Fig. 8 illustrates the details of the vector arc generator 28. From the nature of the operation described previously, only simple calculating units, such as adders, are required. The generator 28 receives instructions from the processor 13 along input lines 36 to an instruction first in first out FIFO register 40. For the generation of a vector, such as vector V in Fig. 2, the instruction signals include a command to draw a vector, and the four X The multiplexer 45, the file 46, and the adder 47 are all controlled by control lines, here denoted by reference numeral 43. The reference numeral 43 is used to indicate one or more control lines. The E file 46 contains storage locations for the values of X The X unit and the Y unit also have their multiplexers 50, 60 connected to the instruction register 41 through the line 42. The x and y units do not. Instead, the multiplexers 56, 65 of these units are connected to voltage terminals V The I, J Counter Logic Unit 44 keeps track of the I and J values as the generator 28 operates. The logic unit 44 communicates to a control µROM 75 through control lines 72, 73. Also under the control of the µROM 75, the generator 28 operates to generate the values for X, x, Y and y coordinates for a data block. Such a µROM 75 and some of its control lines are labeled for exemplary purposes. Also shown are some of the control lines to the µROM 75, which include the instruction line 42, an E line 71 from the file 46 to inform the µROM 75 of the polarity of the value of error E, line 74 with a similar function from the E unit latch 48 and the octant line 70. It should be noted in passing that the µROM shown includes other units besides a ROM, such as a program counter, sequencers and other elements commonly found in a control unit. The translator 21 is illustrated in Fig. 10. The X and Y values enter the translator 21 along lines 31. Each set of lines for the X value or the Y value is 12 bits wide. Only 11 bit wide lines are required for 64K capacity RAMs in the display memory 11. 12 bit wide lines permit 256K RAMs to be used for a higher resolution display memory. The translator 21 treats each value X and Y identically. The X value is divided by a divider 81 shifting the X value down by three places. The remaining data bits, the quotient or X div 8, are sent to a latch 82 and an incrementer 83. The result is stored in a latch 84. The remainder of the divider 81, X mod 8, is stored in a latch 85. Similarly, the values of Y div 8, Y div 8 incremented or left the same, and Y mod 8 are respectively stored in latches 88, 90, and 91. The latches 82, 84, 88 and 90 are connected to the input terminals of a four to one multiplexer 86. The output of the multiplexer 86 appears on a 9 bit address line to the display memory 11. The latches 85, 91 are connected to a logic block 92, which is responsive to a clock signal and the control pixel Fig. 11 illustrates the operation of the translator 21 through the example on Fig. 2. At the first 50 nanosecond clock cycle, the address line places the row address RAD 1 of the two upper arrays through which the block 12A cuts through. At the same time, since the update block array 12A includes only the 5, 6 and 7 row lines of these arrays, the row address strobe for rows 5 through 7 At this point, the semiconductor devices in the memory 11 have only their row addresses. At the third clock cycle the column address for the left two arrays CAD 3 are placed on the address line by the translator 25. Correspondingly, the column address strobe lines for columns 5 through 7 Thus, after four 50 nanosecond clock cycles, all of the addresses are placed into the latches of semiconductor RAMs which comprise the display memory 11. From the nature of the operation of these integrated circuits having a certain data access and a certain amount of data settling time, the data appears approximately 350 nanoseconds from the display memory 11. As discussed previously, the data will appear rotated in two dimensions and must be shifted back through the barrel shifter 22 before being loaded into one of the buffer arrays 23, 24. This is performed within 800 nanoseconds. The update blocks may not always include 4 arrays, but possibly two or even one array. The translator 21 performs its function in those cases. The above example was chosen only as the most complex case for its operation for illustrative purposes. The present description so far has dealt with the modification of blocks of data with straight lines, or vectors. For more complicated shapes, including curves or arcs, the present apparatus provides for the prior art point by point calculation and retrieval from display memory of datum comprising the complex shape. The pixel However, by a suitable modification of Breshenham s algorithm for simple curves, many of the advantages of the present invention can be retained. These curves, such as those of a circle or ellipse, permit the interpolation of the arc by blocks rather than individual data points. Rather than octant directions, quadrant directions are used. The quadrant directions are not set as in the case of vectors, but are recalculated at the points where the curve begins to double back upon itself, either in the X direction or the Y direction. In the case of a circle, for instance, there are four such points, which are the extreme top, bottom, lefthand and righthand points of the circle. This modification of Breshenham s algorithm and the calculation of quadrants minimizes processing time even if the interpolation of data points of the curve within a data block takes more time than for the transfer of the data block from the display memory. Curves generally require more calculation time than vectors and typically require more complex calculating units, such as multipliers, than shown in Fig. 8. However, since the data block can be transferred as the points are being interpolated, no time is wasted for data transfer.