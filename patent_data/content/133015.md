# DATA TRANSFER SYSTEM

## Claims
Datenübertragungsverfahren zur Verwendung mit einem Computersystem, welches einen Prozessor aufweist, ein an den Prozessor gekoppeltes Speichersystem, und zumindest einen ersten und einen zweiten Auswahlkanal, von denen jeder einen direkten Speicherzugriff für die Übertragung digitaler Daten zu und aus dem Speichersystem zur Verfügung stellt, mit folgenden Schritten

## Description
This invention relates to data transfer systems. In a range of complex data processing tasks, scratch tapes or other mass storage devices are used to store intermediate processing results. For example, many seismic data processing tasks consist of a series of steps that are applied to a set of seismic data that are initially stored on magnetic tape. Each step is a separate program which may, for example, read a set of input data from magnetic tape generated by the preceding step process the input data, and then generate a set of output data on magnetic tape which is subsequently supplied as an input to the next step . Such intermediate scratch tapes are often used because the volume of data is large and they allow each step to be developed as a separate entity. Seismic data processing tasks may consist of ten or more individual steps, each linked to the next by a corresponding scratch tape. Such extensive use of scratch tapes represents a significant limitation on execution speed, since the reading and writing of such tapes is both time consuming and susceptible to errors. In the past, a number of approaches have been proposed for simplifying the sequential processing of digital information. For example, the UNIX system described by B.W. Kernighan and J.R. Mashey in the article entitled, The UNIX Programming Environment IEEE Computer , April 1981, pp. 12 24, utilizes an operating system which facilitates the linking of sequential processing steps. However, no hardware is described in this paper to provide high speed data transfer between two portions of computer memory. US patent no. 4 149 242 issued April 10, 1979 to Frank C. Pirz, discloses an interface apparatus for multiple sequential processors in which a plurality of processors, each with its own memory, are linked in series by a chain of transfer units. The operation of the processors is synchronized carefully such that data transfers between adjacent processors occur simultaneously. Thus, each of the processors executes its task with the data stored in its respective memory, and then the data is moved from one memory to the next simultaneously. Thus, each processor must complete its respective task within the time period between adjacent data transfers so that the next data transfer can take place. In this sense all of the processors are required to run in synchrony. US patent no. 3 686 641 discloses the use in a multi program computer system of an intermediate queuing memory for controlling the priority and sequence in which the results of one program are provided to another program. Results put into the queuing memory are available to the second program on either a first in first out or last in first out basis. An article Fast Switching Matrix for Microcomputer K 1520 by W. Schone, K. Muller and M. Kotzurek, in Nachrichtentechnik Elektronik vol. 30, no. 4,1980, pp. 141 143, describes transfer of data between two or more separate computers using direct memory access techniques. Transfer of data to the receiving computer occurs after the receiving computer has requested information from the sending computer. None of these prior art approaches provides a solution to the problem of providing high speed data transfer between two portions of a computer memory system, without intermediate mass storage. The present invention is directed to an improved, high speed data transfer system which provides the high transfer speeds of direct memory access techniques while simultaneously reducing or eliminating the problems and time delays associated with the use of scratch tapes. This invention provides a data transfer method for use with a computer system having a processor, a memory system coupled to the processor and at least first and second selector channels, each providing direct memory access for the transfer of digital data to and from the memory system, said method comprising the following steps In the preferred embodiment of the method of this invention, the first program generates a write request after the first set of digital data has been stored in the first portion of the memory system and the second program generates a read request, asynchronously with respect to the generation of the write request, before processing the digital data stored in the second portion of the memory system, and the transferring step is performed when the write request in the write pipe matches the read request in the read pipe. The execution of the first and second programs may be suspended following the generation of the write and read requests, respectively, until completion of the transferring step. Also in the preferred embodiment, the transfer of the first set of digital data in the first portion of the memory system directly to the second portion of the memory system is accomplished without buffering. The method of this invention allows two independent programs to be run asynchronously and simultaneously on a computer system. An important advantage of this invention is that the transfer may be made in many ways quite similar to the generation and reading of a magnetic tape, at least at the level of the programmer. In the preferred embodiment, the first program writes into a data pipe coupled to the first selector channel which is in many way similar to writing onto a magnetic tape and the second program reads from a data pipe coupled to the second selector channel which is in many ways similar to reading from a magnetic tape . Thus, the simplicity and the independence of operation obtained with magnetic tapes is to a large extent preserved, while eliminating errors and time delays associated with the use of magnetic tapes. A related advantage is that the data transfer system of this invention allows the reading and writing programs to be run asynchronously. They can start and stop execution at differing times, and they can make data transfer requests at differing times. In the preferred embodiment described below, the execution of each of the programs requesting a data transfer is suspended until the transfer is complete, Thus, the first to request a transfer in effect waits until the other program requests the transfer as well. In this way, the standard techniques used to arrange I O data transfers can be used and the problems associated with synchronized programs can be largely avoided. According to a second aspect of this invention, there is provided a computer system comprising a central processing unit, a memory system coupled to the central processing unit, at least two direct memory access channels, each coupled to transfer digital data to and from the memory system, a write pipe connected to one of the access channels to receive data therefrom, a read pipe connected to the other access channel to transfer data thereto, and interconnecting means connecting the write pipe to the read pipe, such that a selected set of digital data can be read from a first portion of the memory system and written into a second portion of the memory system via the two access channels the write pipe, the read pipe and the interconnecting means, without intermediate storage of the set of digital data. The invention will now be described, by way of example, with reference to the accompanying drawings. FIGURE 1 is a block diagram of a computer system which incorporates a first preferred embodiment of the present invention. FIGURE 2 is a more detailed block diagram of the read and write pipes of Figure 1. FIGURE 3 is a detailed electronic schematic diagram of the write pipe of Figures 1 and 2. FIGURE 4 is a detailed electronic schematic diagram of the read pipe of Figures 1 and 2. FIGURE 5 is a timing wave form diagram of selected signals associated with the read and write pipes of Figures 3 and 4. FIGURE 6 is an organizational diagram showing the relationship between the application programs, the data pipes software driver, and the data pipes hardware in the embodiment of Figure 1. Turning now to the drawings, Figure 1 shows a general block diagram of a computer system 10 which incorporates a presently preferred embodiment of this invention. This computer system 10 includes a central processing unit 12 coupled to a memory system 14. As schematically shown in Figure 1, this memory system 14 defines in this embodiment at least four blocks of memory locations 16, 18, 20, 22. Blocks 16 and 18 are a first program block and a first data block, respectively, and blocks 20 an 22 are a second program block and a second data block, respectively. The CPU 12 is controlled by an operating system stored in the memory system 14 so as to allow the simultaneous, asynchronous running by time sharing of the single CPU 12 of the programs stored in the first and second program blocks 16, 20, respectively. The first program in block 16 operates to generate a first set of digital data and to store this data in block 18, and the second program in block 20 utilizes digital data stored in the second block 22 in its operation. The computer system 10 includes a memory bus 30 to which are connected a write selector channel or selch 40, a read selch 46 and may optionally include at least one additional selch 50. The write selch 40 is connected to a write pipe 42, and the read selch 46 is connected to a read pipe 44. The write and read pipes 42,44 are interconnected with one another by a hardware cable interconnection 48. The structure and operation of the read and write pipes 44,42 will be described in detail below in conjunction with Figures 2 5. The additional selch 50 is connected in the conventional manner to a disc controller 52, which operates to control a plurality of magnetic storage discs 54. Each of the selches 40,46,50 is coupled to transfer data with substantially the entire memory system 14. As used herein, the terms selector channel and selch are used to designate a direct memory access device which operates to transfer digital data to or from a memory system, without constant supervision of the CPU. Such direct memory access devices are well known to those skilled in the art and will not be described in detail here. For example, the Perkin Elmer Corporation markets a selch under Model No. 3200 Computer Systems Division, 2 Crescent Place, Oceanport, New Jersey 07757 . Perkin Elmer Publication No. H29 727R09 should be referenced for a detailed description of the method of operation of the Perkin Elmer Model 3200 selch. Once initiated, this selch performs data transfers to or from the memory and I O device, independent of processor control. To start the data transfer, the processor sets up the device coupled to the selch to provide or receive data, provides the selch with the starting and final memory addresses of the block to be transferred and the type of transfer read or write , and then issues a GO command. The selch then performs the data transfer without further direction from the processor. In the Model 3200 Perkin Elmer selch, the processor is notified by an interrupt from the selch when the transfer is completed. Thus, for example, a conventional use of a selch is as shown in connection with the additional selch 50, in which the selch operates to transfer data from the memory 14 to the disk controller 52 or vice versa, without direct supervision of the CPU 12. The present invention is directed to the write and read data pipes 42,44 and their method of use and operation. Figure 2 provides a more detailed block diagram of the component elements of the write and read pipe 42,44. As shown in Figure 2, the write pipe 42 includes a 16 bit data bus driver 56 which is adapted to receive 16 bit half words from the private bus of the write selch 40. The write pipe 42 also includes an address decoder 58 which is responsive to 8 data bits D080 through D150 of the write selch private bus. The block entitled SYN LOGIC 60 of Figure 2 denotes the control circuitry of the write pipe 42 which cooperates with corresponding circuitry in the read pipe 44 to control data transfer from the write pipe 42 to the read pipe 44. Similarly, the read pipe 44 includes a 16 bit data terminator 62 which is adapted to receive 16 bit parallel half words from the data bus driver 56 and to pass this digital information to the private bus of the read selch 46. The read data pipe 44 includes an 8 bit address decoder 64 coupled to data bits D080 D150 of the read selch private bus, as well as a SYN LOGIC 66 coupled to interact with the SYN LOGIC 60 of the write data pipe 42. In Figure 2 the symbol coupled with an adjacent numeral indicates the number of parallel data lines included in certain of the interconnections of the figure. Symbols are provided adjacent each of the lines to indicate the names of the signals transmitted over these lines. Figure 3 provides a detailed electrical schematic of the write pipe 42, in which the data bus driver 56, the address decoder 58, and the SYN LOGIC 60 have been outlined in dotted lines. In Figure 3 all inverters are type 7404 inverters except those included in the data bus driver 56, which are type 7406 inverters. Similarly, Figure 4 shows a detailed electrical schematic of the read data pipe 44, including the address decoder 64 and the SYN LOGIC 66. In Figure 4, the data terminator 62 is made up of two component parts identified by reference numerals 62a and 62b in the drawing. Unless otherwise shown, the gates of the data terminator 62b in Figure 4 are type 7438 NAND gates and all inverters are type 7404. As shown in Figure 2, the data bus driver 56 is connected to the data terminator 62 and the SYN LOGIC 60 is connected with the SYN LOGIC 66 by respective conductors. In this preferred embodiment, a 25 pair pin to pin cable 48 is used to provide these interconnections directly, without intermediate storage such as scratch tapes. In Figures 2 5 the last digit of each variable name indicates whether the variable is active when in the Logic High state or the Logic Low state. Variables which are active in the Logic High state terminate with the number 1, and variables active in the Logic Low state terminate with the number 0. Turning now to the detailed schematic of Figure 3, address decoder 58 of the write pipe 42 includes two 4 bit jumper blocks 70. Through the use of suitable jumpers any address between 00 and FF can be selected. When the selected address appears on data lines D080 D150 and the ADRS0 signal makes a transition from high to low, the signal ADD1 is latched high, indicating that the write pipe 42 has been addressed. When the address decoder 58 latches ADD1 high, a number of things happen. The signals HW0 and SNS0 are pulled low to indicate to the write selch 40 that data transfer is to proceed in parallel half word 16 bit segments, and that the high speed data transfer sequence is to be used. The signals HW0 and SNS0 are explained in greater detail at pages 2 5 and 2 11 of the above identified Perkin Elmer Publication No. H29 727R09. Furthermore, the SYN LOGIC 60 is enabled, such that the SYN0 signal is returned to the write selch 40 in response to a signal on any of the lines CMD0, SR0 or ADRS0, and then SYN LOGIC 60 responds to signals on the lines DA0, SCLR0. In use, the write selch 40 presents 16 parallel bits on data lines D000 D150 along with a Data Available signal on line DA0. The write pipe 42 presents these 16 bits to the read pipe 44 via the lines DB000 DB150 of the cable 48, along with a gated Data Available signal PWSYN0. PWSYN0 is generated in the write pipe 42 by gating DA0 with the address signal ADD1, and PWSYN0 indicates whether or not data are available for transfer on DB000 DB150 The theory of operation and timing of the write and read pipes 42,44 can now be described. First, it should be understood that data being transferred always flow from the write selch 40 to the read selch 46, via the write pipe 42, the cable 48, and the read pipe 44. In effect, the write pipe 42 writes the data into the read pipe 44 and the read pipe 44 reads the data from the write pipe 46. When the write pipe 42 has been addressed and the write selch 40 is prepared to transfer data on the lines D000 D150 of its private bus, it presents 16 bits of data on the lines D000 D150 along with a Data Available signal on line DA0. The write pipe 42 presents the data to the read pipe 44 on lines DB000 DB150 of the cable 48, along with the gated Data Available signal PWSYN0. At this point, the write pipe 42 does not return the SYN0 signal to the write selch 40 this causes the write selch 40 to maintain the data on lines D000 D150 of its private bus. Once the read pipe 44 has been addressed by the read selch 46 and has received a Data Request signal on line DR0, the read pipe then gates the data on lines DB000 DB150 of the cable 48 directly to the private bus of the read selch 46, without intermediate storage. The read selch 46 latches the data and removes the Data Request signal on line DR0. A SYN0 signal is returned to the write selch 40 a selected time after the data have been gated to the private bus of the read selch 46, and the write selch 40 then removes the data and the DA0 signal from its private bus to complete the transfer of one 16 bit half word. This timing arrangement is illustrated in Figure 5, in which the following symbols are used RDRG1 represents the gated Data Request signal generated by the read pipe 44 at line 74 active high WDAG1 represents the gated Data Available signal generated by the write pipe 42 at line 76 active high RSYN1 represents the synchronization signal generated by the write pipe 42 at line 78 and returned to the read selch 46 active high and WSYN1 represents the synchronization signal generated by the RACK0 signal of the above identified Perkin Elmer write pipe 42 at line 80 and returned to the write selch active high . In practice, it has been found that the read and write pipes 44,42 may be plugged into the private buses of any two selches of the computer system. For example, when using a Model 3200 selch as described in the above referenced publication No. H29 727R09 and a Perkin Elmer 3220 or 3240 digital processing system, the read and write pipes 44,42 can be embodied as half circuit boards which are plugged into the private buses of the respective selches, on the connector 1 side of the Perkin Elmer I O chassis. It is advisable that selches at the lowest possible priority on the memory bus be used. Preferably, the selches for the read and write pipes 44,42 should be at a lower memory bus priority than mechanical devices such as disk and tape units. Also, it is preferable that no other devices be on the read and write selches 46,40, in order to prevent interference by slower I O devices, such as magnetic tape or disc units. Since the write and read pipes 42,44 do not generate interrupts, they do not trap RACK0 signals and it is therefore not necessary to remove the RACK0 TACK0 jumper from the chassis backplate. As described above, the read and write pipes 44,42 support the high speed transfer sequence and half word transfer format, and indicate this capability by holding the SNS0 and HW0 lines low. With some Perkin Elmer computers it may be necessary to install a selch high speed jumper as shown on Page 1 13 of the above referenced publication H29 727RO9. Furthermore, it may be necessary to connect pin 124 1 of the Perkin Elmer I O chassis, which in some cases is not connected at the factory. It has been found that maximum data rates of approximately 4.3 million bytes per second for each of the write pipe 42 and the read pipe 44 can be obtained if the two pipes 42,44 are connected to selches 40,44 on different DMA buses. This is not a requirement for operation, however. Measurements have indicated that a transfer rate of about 3.6 million bytes per second can be achieved using a single DMA bus. Since both the write and read pipes 42,44 each have only one function, no commands are needed. However, if a command is issued to either the write pipe 42 or the read pipe 44 via the respective line CMD0, the signal SYN0 will be returned. Similarly, since there is no mechanical storage device associated with either the write or read pipes 42,44, there is no need for status information from either pipe. However, both the write and read pipes 42,44 respond to a status request signal on the respective line SR0 by returning a SYN0 signal. The computer system can be programmed to use the data pipes 42,44 to transfer data directly from one program to another, without intermediate storage. In the example of Figure 1, after the first program in conjunction with a data pipe driver, to be discussed further, in the block 16 has generated the desired data in the data block 18, the first program in conjunction with a data pipe driver, to be discussed further, can then set up the write selch 40 with the beginning and ending addresses of the first data block 18, address and write pipe 42, and then direct an output go command to write selch 40 with the read write bit set properly. Then the second program in the block 20 in conjunction with the data pipe driver of the operating system can set up the read selch 46 with the beginning and ending addresses of the second data block 22, address the read pipe 44, and then direct an output go command to the read selch 46 with the read write bit set properly. After both selches 40,46 have been started, they utilize the data pipes 42,44 and the cable 48 to transfer data therebetween in order to move the block of data stored in the first data block 18 directly to the second data block 22, without supervision by the CPU 12 or intermediate mass storage. Software may check the status of the selches 40,46 or wait for a selch interrupt to determine when the transfer has been completed. Of course, the transfer does not begin until both selches 40,46 have been started, and it is therefore possible to start the read selch 46 before the write selch 40 rather than vice versa as described above. The software performs the pipe and selch control functions described generally above in response to selected I O requests. However, the software may in addition provide a number of further features which improve the flexibility and usefulness of the data pipes 42,44. For example, the speed of the single set of data pipes 42,44 will be sufficient for the needs of many applications. This single set of data pipes 42,44 physically provides only one input and one output. However, users of data pipes will often require many simultaneous yet logically independent pipes, for example, to connect multiple batch steps together. For this reason the preferred software simulates many logically independent data pipes which share a common hardware. The software maintains a plurality of pairs of data pipe ends, each of which is logically independent and all of which utilize the same hardware. As used herein, the term data pipe end signifies such a software generated, logically independent, virtual I O device. Each logically independent set of data pipe ends appears in the operating system as two physical devices, for example RP01 and WP01 . The RP01 device may only be read from while the WP01 device may only be written into. Data written into the WP01 device may be read from the RP01 under certain constraints. In a typical application, the software can be used to simulate 50 distinct sets of data pipe ends numbered 1 to 50. Figure 6 shows in general terms the manner in which the preferred software controls access to the data pipes hardware 40,42,44,46 by the application programs resident in the computer system 10. In Figure 6 the blocks labeled AP₁, AP₂...AP A further important point is that the preferred software has been designed such that the use of the data pipes 42,44 mimics the use of conventional magnetic tape read and write procedures. For this reason, the software allows data pipe ends to be used by an application program in much the same manner as magnetic tapes. For example, if the first and second programs in the data blocks 16,20 of Figure 1 are loaded into the computer system 10 for simultaneous execution and both have been designed to select data pipe end 7 for use, the first program in block 16 would assign a logical unit to WP07 and the second program in block 20 would assign a logical unit to RP07 . After each program has issued a rewind command to its respective pipe end, the two programs may exchange data with normal read and write I O requests. In general, the more closely data pipe end operation approximates the operation of magnetic tape, the more transparent data pipe ends will be to the user. Thus, each write pipe end honors the commands REWIND, WRITE, WRITE FILEMARK and UNLOAD, and each read pipe end honors the commands REWIND, READ, FORWARD SPACE RECORD, FORWARD SPACE FILEMARK, and UNLOAD. Although the precise implications of these operations are not identical between tapes and pipe ends, reasonable approximation does exist which increases the transparency of the data pipe ends. The term FILEMARK is used to designate an end of file symbol. As explained above, the data pipes 42,44 provide no buffering of data transfers and data is transferred directly from the writer s memory into the reader s memory. This approach provides a high efficiency of transfer, but without buffering it is often not practical to support back spacing and rewind operations in a manner similar to magnetic tapes. This is not a significant drawback for a wide range of data processing operations. The first and second programs in program blocks 16 and 20 which exchange data through the data pipes 42,44 are synchronized by the same operating system mechanism used for all other data transfers in this embodiment. A typical approach is for the operating system to suspend execution of a program which has made an I O request to a peripheral tape, disc drive, terminal, or the like until the transaction is completed. As explained above, when data pipe ends are used to transfer data, a transaction cannot be processed until complimentary read and write requests have been received by the operating system. A read or write request waiting for a complimentary write or read request therefore simply takes longer to complete and results in a longer period during which execution of the requesting program is suspended. A further point in which the preferred software mimics magnetic tape is that the transfer lengths of paired read and write requests do not have to be equal. In fact, it is the minimum length of the two that is actually transferred. The writing program is always led to believe that the full request was transferred. This approach parallels magnetic tape operation in which the writer always transfers the full amount of data while the reader may attempt to read more or less than the actual quantity present. One advantage of magnetic tape is that the mounting of the physical tape, the writing of data, and its subsequent reading by another program follow a reasonably rigid protocol which coordinates the activity of both programs with the associated hardware. The preferred software simulates this protocol, adapted to the particular needs of data pipe control. The software maintains a three level state variable for each data pipe end, and these variables indicate the current status of the individual pipe ends. These states may be named ERROR, SYNC and READY. The ERROR state roughly corresponds to a magnetic tape drive which does not have a tape mounted and on line. The SYNC state roughly corresponds to a magnetic tape mounted, on line, and rewound to the beginning. The READY state roughly corresponds to a magnetic tape containing one or more valid records and positioned off of the load point. The states of the pipe ends are controlled in conjunction with the following rules to define the complete pipe protocol. Several additional points concerning data pipe operations deserve mention. After assigning a logical unit to a data pipe end read or write , it is important that a REWIND command be issued to achieve synchronization. Similarly, the final request to a data pipe end read or write should be an UNLOAD command, although this is not essential. No actual data transfer is necessary for FORWARD SPACE RECORD and FORWARD SPACE FILEMARK reader requests, although they must still be properly paired with the associated writer requests. In generating the operating system to include data pipe ends, it is preferable that an equal number of read and write pipe ends be configured under each physical pipe hardware and selector channel. The data pipe driver of the preferred software is divided conceptually into two parts DCB197, INITRPIP, CMDRPIP, and TERMRPIP for the read pipe ends and DCB198, INITWPIP, CMDWPIP, and TERMWPIP for the write pipe ends. The operation and programming of these two drivers are nearly identical and will be referenced together as simply the pipe driver in the following description. All of the following comments are applicable to both the read and write pipe drivers except for explicitly mentioned differences. The device dependent DCB structure is quite simple and contains only three full word items. DCB.CPIP is the address of the complimentary pipe end and is used in coordinating read and write activities. DCB.RTL is the requested transfer length for the pending request at a particular pipe end. DCB.PEST is the current pipe end state of the associated pipe and has the states listed and defined in Table 1. The data pipe driver code may be divided into two major areas the pipe manager and the data transfer sequence. The pipe manager is responsible for enforcing the specified protocol defined above in complimentary pipe ends and recognizing when an actual data transfer is required. The data transfer sequence accepts paired read write requests and accomplishes the actual transfer. These two areas are summarized below. The pipe manager provides three primary entry points for data requests INITRPIP and INITWPIP , command requests CMDRPIP and CMDWPIP , and driver termination TERMRPIP and TERMWPIP . The first time a pipe driver request is issued after the operating system has been rebooted, the linkage pipe driver subroutine LINKAGE is executed. LINKAGE searches the operating system Device Mnemonic Table for occurrences of read and write pipe devices DCB197 and DCB198 and establishes cross linkage of complimentary pipe ends via DCB.CPIP. Data requests to a read pipe end begin execution at INITRPIP and data requests to a write pipe end begin execution at INITWPIP. The pipe manager enforces the specified protocol by adjusting DCB.PEST and terminating, holding, or scheduling further processing. The pipe manager will manipulate either end of the logical pipe as necessary to enforce the protocol. When the pipe manager determines that valid read and write requests have been paired and an actual data transfer is required, steps are taken 1 to prevent an inadvertent breakage of a logical request pair via a halt I O request, 2 to coordinate the data transfer with any other logical data pipes or other devices using the selches, and 3 to initiate the data transfer sequence. These three actions are performed upon both pipe ends at the same time. Command requests to a read pipe end begin execution at CMDRPIP and command requests to a write pipe end begin execution at CMDWPIP. Again, the pipe manager enforces the specified protocol by adjusting DCB.PEST and manipulating queued requests at either end of the logical pipe. It should be noted that no command request is capable of triggering an actual data transfer. The routines TERMRPIP and TERMWPIP or several additional variations of them are entered to terminate a transfer request. The actual data transfer sequence of the data pipe driver begins at PIPEREAD and PIPEWRIT. By the time these routines are entered, complimentary read write requests have been paired and full connection has been made in the resource tree. The actual length of data transfer is determined and a time out safety net is established before actually starting the hardware. The data transfer method and apparatus described above provide a number of important advantages. This 5 method and apparatus can be used to transfer data between sequential processing steps at a rate faster than that possible with standard magnetic tapes. Furthermore, tape handling is significantly reduced, and in this way the size of tape libraries and the number of tape errors can be reduced, along with associated processing errors. Other advantages over tapes include reduced human intervention, increased reliability, as well as the possibility of a more nearly parallel processing approach. In many applications, the use of data pipes of the type described above will allow the throughput of computer systems to be increased and will provide faster turnaround on individual processing tasks. They will allow processing tasks with increasingly large volumes of data to be processed with minimal tape handling and personnel requirements. The advantages of these data pipes are particularly useful in seismic processing tasks. Of course, it should be understood that the foregoing detailed description is provided by way of example, and that a wide range of changes and modifications will be apparent to those skilled in the art. For example, the data pipes described above can readily be adapted for use in other computers, with other types of direct memory access devices, or in computer systems employing multiple processors. Furthermore, details of both hardware and software can readily be varied to suit individual applications. It is, therefore, intended that the foregoing detailed description be regarded as illustrative rather than limiting, and that it be understood that it is the following claims, including all equivalents, which are intended to define the scope of this invention.