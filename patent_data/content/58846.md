# Multiprocessing system with variably shared paging storage.

## Abstract
A shared paging storage manager partitioning storage into sectors private to individual running processes, maintains, for each running process, a list of segment list counts for the ordered unequal segments of a fictional maximum sector, and an ordered page identity stack of an equal page capacity each position the stack uniquely associating its contained page identity, with one segment, the order of page identities representing their relative replacement order, the actual accessing of a page causing the hit count for the segment corresponding to the stack position containing the page identity at the time of the access to be incremented, and effects optimum partitioning by determining the highest totalling hit count for each of the various combinations of segment list lengths of all the lists representing an aggregate segment page capacity not exceeding the available storage page capacity.

## Claims
CLAIMS 1. A multiprocessing system having shared paging storage and a storage manager therefor partitioning it into sectors private to individual running processes, enforcing a common replacement protocol across the sectors and enabling address translation, read and write accessing, erazing and updating characterized in that, in addition to the maintainance of those facilities appropriate to the actual exercizing of the shared storage, the storage manager maintains, for each running process, a list of segment list counts for the ordered segments of a fictional maximum sector, the segments not all being of the same page capacity, and an ordered page identity stack of a capacity equal to the page capacity of the fictional maximum sector, each position in the stack uniquely associating the page identity, if any, contained therein with one of the fictional segments, the order of page identities in the stack being adjusted in response to each actual page access including additions and deletions to represent the relative replacement order of the corresponding pages, the actual accessing of a page causing the hit count for the segment corresponding to the stack position containing the page identity at the time of the access to be incremented, the storage manager determining the optimum partitioning, and so partitioning the storage, by totalling the hit counts for each of the various combinations of segment list lengths of all the lists representing an aggregate segment page capacity not exceeding the available storage page capacity, determining the highest total and defining the sectors in terms of the aggregate segment page capacity of the lengths of the lists providing that highest total. 2. A system as claimed in claim 1 wherein the storage manager is responsive, for the purposes of repartitioning, to the invoking of a new process, to a periodic timer, and, optionally, to the deletion of a process.

## Description
MULTIPROCESSING SYSTEM WITH VARIABLY SHARED PAGING STORAGE The present invention relates to multiprocessing systems having shared paging storage and a storage manager, inter alia, partitioning the shared storage into sections private to individual processes. This is a form of paging constraint and it is known that performance can be potentially improved if the sector sizes are tuned to the aggregate process requirements thus rendering the constraint variable.Various proposals have been made for mechanisms to determine the optimum partitioning in given circumstances, see, for example, Fast Approximation Algorithms For Knapsack Problems ,Lawler, Mathematics of Operations Research, Vol. 4, November 1979, pp 339 356, but are not practical in that they do not enable economic dynamic partitioning since, without the use of a technology considerably faster than that of the remainder of the system, they can only be used off line and not in real time. The present invention seeks to provide, in the storage manager, a mechanism permitting effective dynamic partitioning. The present invention provides a multiprocessing system having shared paging storage and a storage manager therefor partitioning it into sectors private to individual running processes, enforcing a common replacement protocol across the sectors and enabling address translation, read and write accessing, erazing and updating characterized in that, in addition to the maintainance of those facilities appropriate to the actual exercizing of the shared storage, the storage manager maintains, for each running process, a list of segment list counts for the ordered segments of a fictional maximum sector, the segments not all being of the same page capacity, and an ordered page identity stack of a capacity equal to the page capacity of the fictional maximum sector, each position in the stack uniquely associating the page identity, if any, contained therein with one of the fictional segments, the order of page identities in the stack being adjusted in response to each actual page access including additions and deletions to represent the relative replacement order of the corresponding pages, the actual accessing of a page causing the hit count for the segment corresponding to the stack position containing the page identity at the time of the access to be incremented, the storage manager determining the optimum partitioning, and so partitioning the storage, by totalling the hit counts for each of the various combinations of segment list lengths of all the lists representing an aggregate segment page capacity not exceeding the available storage page capacity, determining the highest total and defining the sectors in terms of the aggregate segment page capacity of the lengths of the lists providing that highest total. Repartitioning can be performed more or less as required but it is thought to be most efficient if it is performed each time a new process is invoked and, in addition, periodically. It may also be performed each time a process is deleted. It is thought necessary, at this stage, to establish certain term definitions and concepts. A process is an entity which requires use of the shared storage. It may be a task, program, processor or other functional unit. Thus, when a processor, for example, it is invoked when it places a demand for use of the shared storage and is deleted when it relinquishes such a demand.Further, since in modern computers, constraints are applied by the addressing logic of a random access store, sectors and segments are logical entities and not physical entities. Moreover, a list or stack is also a logic entity. For example, the lists of hit counts can be formed in ordered sets of physical counters or in registers and an ordered stack can be implemented physically, as by a shift register or as an address selected and ordered set of locations. What matters from the point of view of the invention are the operations and relationships effected. Priority is claimed from an application specifically prepared to conform with the current practices of and filed in the United States of America, the specification as filed for that purpose being incorporated herein in the form of an appendix to which reference should be made for matters of detail, the matters disclosed therein being represented in a more compact form hereinbefore. A conventional paging store or cache comprises a fixed number of page frames into which pages of data are copied from bulk storage. The capacity of the paging store is much less than the capacity of bulk storage, as is its cycle time, and a replacement protocal is observed. It is quite usual to apply a constraint to the transfer of pages, and, in the type of system to which this specification relates, the constraint is that pages required by a given process can be transferred only to given page frames, is exercised by the addressing logic and is variable, being established by the storage manager, producing a logically partitioned store although, physically, it is a homogenious random access store.The present invention modifies the storage manager to perform additional specific functions in order that it can determine, with the minimum of overhead, the optimum partitioning of the paging store in relation to current operating criteria so that the paging store can be repartitioned dynamically. To this end, quite apart from its conventional logging of the actual use of the paging store, it additionally logs the use that would have been made by each process of a number of hypothetical sectors. In fact, only one of these sectors exists for each process, but it would not really matter if none of them did. Many factors may be logged, but the key factor is the number of hits that would have been made in the immediately proceding operating period had the associated process actually had a private sector available to it of the capacity of each particular hypothetical sector.However, the hit counts cannot be logged directly because of the lack of one to one correspondence between the actual sectors and the hypothetical sectors. Moreover, a compromise is made as to the number of hypothetical sector sizes condidered so that, in general, each hypothetical sector size is more than one page larger than the size of the next smaller sector size. This renders the granularity more coarse and the tuning theoretically less precise but gains considerably in reduced overhead. Accordingly, the storage manager creates and maintains two associated tools which it uses when required to make a partitioning decision, preferably, whenever a new process is invoked, as well as at regular intervals as determined by the system timer and, opertionally, also whenever a process is deleted. The first tool is a list of ordered segment hit counts for each of a ordered sequence of segments, not all of the same size, which together have a page capacity equal to that of a fictional maximum sector. The second tool is an ordered stack which relates actual pages accessed to the fictional segments of the fictional sectors.The essential stack entries are page identities which are moved around the stack so that the order of page identities within the stack reflects the actual replacement order of the pages, the page identity capacity of the stack equals the fictional sector page capacity and the individual stack locations directly associate the page identities, if any, contained therein with the fictional segments. The ordering within both tools is critical. Although a selection, as to the start and finish of the list, the top and bottom of the stack and which replacement protocol is to be observed, is possible, once established, the ordering protocol must be strictly adhered to. Assuming a least recently used replacement protocol, with the top of the stack being associated with the most recently used page and the bottom of the stack with the least recently used page and sectors incrementing by segment from the start of the list to the end of the list, the tools are maintained as follows When an actual page is accessed in a page frame, the corresponding page identity is entered at the top of the stack and the remaining stack contents pushed down and out, if and as necessary.If that page identity was previously in the stack, the hit count for the fictional segment to which the stack location containing that entry corresponds is incremented. When a page is deleted, the page entry is deleted from the stack. The combined effect of these operations is to maintain an ordered list of hit counts which records, not the actual hits made, but how many more hits owuld have been made per additional segment, if the corresponding sector had contained the additional page capacity of that segment. In other words, a sector of the capacity of the aggregate of the first E segments in list order would have secured hits equal in number to the aggregate of the first E hit counts in list order. These list of counts are very nearly the data required to determine optimum partitioning and are maintainable, in realistic terms, in real time. The actual determination involves generating hit totals for all the possible segment string, or in other words, sector size, combinations which do not have a capacity greater than the capacity of the shared storage and selecting the highest hit total and this, in practice, reduces to very nearly a real time process, certainly in terms of storage access times, because the number of combinations possible is strictly limited and known beforehand.Assume a new process is invoked, being given a standard sector since this is no data available relative thereto, then repartitioning of running processes reduces to examining register accessing, adding and comparing all possible combinations of known consecutive segment storing counts equal in number to the number of running processes which do not represent a total page capacity greater than the page capacity of the shared storage less the page capacity of the standard sector. Similar criteria apply to the other listed repartitioning circumstances. For a given environment, these are all known and can be retained in tablular form. Moreover, the greater the number of sectors, the fewer the number of possible segment strings within each. Further, the highest hit total, if unique, uniquely identifies the total sought sector configuration. There is a further point to note in that a suitable choice of segment sizes will help. Ideally the smaller segments should combine to exactly equal the capacity of a larger segment, say 3 4 10 as in the case illustrated in the appendix.