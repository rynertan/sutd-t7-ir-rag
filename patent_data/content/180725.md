# INSTRUCTION PREFETCH OPERATION FOR BRANCH INSTRUCTIONS

## Claims
Verfahren zum Vorauslesen und zum Ausführen einer Mehrzahl von Befehlen mit zumindest einem Verzweigungsbefehl in einem System, das einem Pipelining unterworfen ist, mit einem Vorauslesepuffer 11 , der folgendes aufweist eine Mehrzahl von Vorausleseregistern 15 18 , eine Steuerlogik 21 zum Lenken des Auslesens von Befehlen an die Vorausleseregister und aus denselben, einen Speicher 14 und einen Speicherkanal 12 für den Austausch von Befehlen zwischen den Registern und dem Speicher,

## Description
This invention relates to the operation of an instruction prefetch buffer in a pipelined processor, and more particularly to a method and an apparatus for prefetching and executing a plurality of instructions having at least one branch instruction. In a pipelined processor, multiple pieces of data, such as instructions, can move simultaneously through the channel connecting the processor with a storage means. A storage controller is used to direct such data between the storage means and the processor through the storage channel. The data moving through the channel is tagged so as to identify its destination in the processor. Since the operation of the processor is much faster than that of the storage means, the use of such a pipelined storage channel together with appropriate buffers within the processor permits the processor to operate at its most effective rate and to conduct a plurality of simultaneous storage transactions. The concept of a pipelined storage channel is described in One technique for overcoming the branching problem is disclosed in U. S. Patent 4,430,706, wherein a branch prediction approach is employed. In this approach, an auxiliary implementation is added to a pipelined data processor for monitoring both the instruction flow and the recent conditional branches and their outcome. Whenever a branch instruction is encountered more than once, its prior behavior is used to predict the particular branch to be taken. The processor then provisionally executes the instructions in such predicted branch. However, when a predicted branch turns out to be incorrect, such processing ceases and the processor then attempts to take a correct branch. Two problems with this approach are that, first, extra hardware is required, and second, processing time is wasted whenever a wrong branch is predicted and subsequently processed. Another approach to the branching problem is disclosed in U. S. Patents 4,155,120 and 4,179,737, wherein it is assumed that no branching possibilities are present. In accordance with this approach, microinstruction sequencing is assumed to be unconditional even though a plurality of branching possibilities may indeed exist in the microinstruction sequencing flow. In this manner, microinstruction sequencing may proceed rapidly as long as no branching occurs. However, when a branch does in fact occur, it must be detected and then a correction cycle must be initiated. A problem with this approach is that as the number of branching operations increases, sequencing must be altered and corrected for incorrect sequencing because of lack of recognition of branching possibilities. Further this approach requires means for monitoring the correctness of the sequencing of microinstructions concurrently with the execution of microinstructions during each cycle for which a branching decision is required. A further problem that arises as a result of a branch is that the instruction prefetch buffer in the processor has no advance knowledge of a successful branch, so there may be several pending requests from previous prefetches when the successful branch occurs. The problem then is how to distinguish between old prefetches, i.e., ones that occurred before the successful branch and which are no longer necessary, and the new prefetches which are needed as a result of the successful branch. One approach to solve this branching problem is to divide the instruction prefetch buffer into two halves, and to alternate between the two halves every time a successful branch occurs. Since the storage channel utilizes a tag to identify each request source, a set of tags could be associated with each half of the instruction prefetch buffer. Thus, whenever a successful branch occurs, the instruction prefetch buffer would change to the alternate set of tags. In this manner, the instruction prefetch buffer could determine whether or not a reply from a prefetch request should go into the active half of the buffer by comparing the returned tag with the currently active tag set. If the tag were a member of the active set, then the prefetch would be associated with the current execution stream and consequently should be placed in the active half of the buffer. Conversely, if the tag were not a member of the active set, then it would no longer be required and could be placed in the inactive half of the buffer. Although this approach is workable, it only utilizes one half of the storage area in the instruction prefetch buffer at any given time. Accordingly, it is an object of this invention to provide improved execution sequencing in a pipelined processor system. It is another object of this invention to provide improved instruction prefetch buffer utilization and efficiency. Accordingly, a method and an apparatus are set out in claims 1 and 6, respectively. This technique reduces the amount of storage required in the instruction prefetch buffer IPB by a factor of two without reducing IPB performance. The technique is especially useful for handling branching operations. When a branch occurs, the IPB begins fetching instructions starting at the branch target address. However, since the IPB has no advance knowledge of the branch, there may be several pending requests from the previous prefetched instructions when the branch occurs. The technique disclosed herein enables the IPB to distinguish between old prefetches, that is, those that occurred before the branch, and the new prefetches which are needed as a result of the branch. The IPB contains a plurality of registers which are used to hold instructions prior to their execution. Each of these registers has a number associated with it which uniquely identifies that register. Additionally, a control bit is associated with each register to indicate if there is a cancelled fetch outstanding CFO for that particular register. A cancelled fetch outstanding occurs after a branch when a previous fetch has not yet been returned to the IPB from storage over the storage channel. Recall that these previous prefetches are no longer required after the branch occurs. In addition to the register identifier and the CFO control bit, there is also a control bit in the processor which is complemented every time a branch occurs. This latter control bit is known as the branch target bit BTB . When a prefetch is returned to the IPB, the BTB value associated with the returning prefetch is compared to the current BTB value in the IPB. If the two are equal, then this is an indication that a branch has not occurred and that the prefetch request which was sent to storage is still needed. In this situation, the returning prefetch is written into the register in the IPB specified by control bits of the returning prefetch. The returned instruction is then used when needed for execution. However, if the BTB value associated with the returning prefetch is not equal to the current BTB value in the IPB, then this is an indication that a branch has occurred and that the returning prefetch is no longer needed. As a result, the returning prefetch is not written into one of the registers of the IPB. Whenever a branch occurs, the CFO bits associated with each register of the IPB are examined. If any of such bits are set, then the branch must wait until all CFO bits are reset. As previously noted, the BTB is also complemented when the branch occurs. Finally, CFO bits in the IPB are set for locations for which a prefetch has been sent to storage but has not yet returned. Fig. 1 is a block diagram of a pipelined processor system according to the present invention. Fig. 2 is a flow chart depicting the branching operation according to the present invention. Fig. 3 is a flow chart depicting instruction execution according to the present invention. Fig. 4 is a flow chart depicting the prefetching operation of the present invention. Fig. 5 is a flow chart depicting the returning tag operation of the present invention. Referring now to Fig. 1, there is shown a pipelined processor with particular emphasis on instruction prefetch buffer 11. Information in the form of instructions is communicated over storage channel 12 through storage controller 13 between instruction prefetch buffer IPB 11 and storage 14. IPB 11 comprises four registers, IPB0, 15, IPB1, 16, IPB2, 17, and IPB3, 18. Each of registers 15 through 18 has logic means, CFO, associated with it for indicating whether each of these registers has a cancelled fetch outstanding CFO . IPB 11 also includes a branch tag register BTR 19 which contains a control bit for indicating whenever an instruction branch occurs. IPB 11 also contains control logic 21 for directing the fetching of instructions to and from IPB 11. Each of registers 15 through 18 has a number associated with it, 0 through 3, which uniquely identifies such register. Additionally, there is a control bit associated with each of registers 15 through 18 to indicate if there is a cancelled fetch outstanding CFO for that associated register. There is also a control bit in BTR 19 called the branch target bit BTB which is complemented every time a branch occurs in the instruction stream. In operation, whenever the next instruction is to be fetched, IPB 11 determines which of registers 15 through 18 should be used for the fetch. A tag is then generated for the prefetch so as to indicate the source of the instruction request. Control logic 21 generates this tag for the instruction fetch by appending the current BTB value to the register number selected for such request. The prefetch request is then sent to storage 14 over storage channel 12 in order to obtain the next instruction. After the prefetch request has been processed by storage 14, it will be returned over channel 12 to IPB 11. The returned prefetch request will contain the next instruction along with its identifying tag. A determination will then be made if the returned prefetch instruction is still needed. This is done by comparing the BTB value in the returning instruction to the current BTB value in BTR 19. If the two values are equal, then this is an indication that a branch has not occurred since the time that the prefetch request was sent to storage 14. Consequently, the prefetch instruction is still required. At this time, the prefetch instruction returned is then written into the register specified by the returning tag identifier, and the instruction is then used when it is needed for an execution. If the BTB value in the returning prefetch instruction and the current BTB value in BTR 19 are different, then this is an indication that a branch in the instruction stream has occurred. Consequently, the prefetch instruction is no longer needed and therefore, is not written in one of registers 15 through 18. The CFO bit associated with the returning prefetch instruction is then reset. At the time a branch in the instruction stream occurs, the CFO bits associated with each of registers 15 through 18 are examined. If any of these CFO bits are set, then the execution of the branch in the instruction stream must wait until all of these CFO bits are reset. Also at this time, the BTB in BTR 19 is complemented. Finally, control logic 21 examines each of registers 15 through 18 to determine if any prefetch has been sent to storage 14 but has not yet returned. If this is the case, then the CFO bit associated with that register is set thus indicating that there is a cancelled fetch outstanding. The flow chart in Fig. 2 details the operation of IPB 11 at the time a branch in the instruction stream occurs. As indicated in box 22, a determination is made as to whether or not there are any cancelled fetches outstanding. If there are, then box 23 indicates that no further operation occurs until the cancelled tag identifying a returned prefetch instruction is sent from storage 14 to IPB 11. If there are no current fetches outstanding, then box 24 provides that control logic 21 sets a CFO bit for all registers 15 through 18 for which a prefetch has been allocated. Also at this time, the BTB value in BTR 19 is complemented as indicated in box 25 and all tags are set to their available state for enabling instructions to be fetched from storage as indicated in box 26. Finally in box 27, an identifying tag is selected in order to fetch the branch target instruction from storage 14. This prefetching process continues until all target fetches are completed. The flow chart in Fig. 3 indicates the operation of IPB 11 when instruction execution unit 37 asks for the next instruction. As indicated in box 31, the next instruction address is calculated within IPB 11. Then in box 32, a decision is made as to whether or not the location in IPB 11 of the next instruction has been freed. If the answer is affirmative, then the freed IPB tag is set to its available state. However, if the answer is negative, then a further decision is made in block 34 as to whether or not the next instruction tag is in a valid state. If the next instruction tag is not in a valid state, then IPB 11 must wait for the selected tag to return from storage 14 over channel 12. However, if the next instruction tag is in a valid state, then the next instruction is provided to execution unit 37 for execution. The process for selecting the next identifying tag for a prefetch is detailed in the flow chart shown in Fig. 4. After the next prefetch tag has been selected, a determination is made as to whether or not the tag is available. If such tag is not available, then IPB 11 must wait for such tag to become available as indicated in blocks 42 and 43. However, if the tag is available, then it is allocated to the next prefetch as shown in block 44. Finally the next prefetch along with identifying tag is sent to storage 14 so as to obtain the next instruction. As shown in Fig. 5, when an instruction is returned from storage 14 with its associated identifying tag, a determination is made as to whether or not the BTB returning with the instruction is equal to the current BTB value in IPB 11. If the two values are not equal, then this is an indication that a branch has occurred in the instruction stream and consequently the prefetched instruction is no longer needed. The CFO bit for each returning tag is then reset. However, if the returning BTB value is equal to the current BTB value in IPB 11, then as stated previously this is an indication that a branch in the instruction stream has not occurred. A determination is then made as shown in block 53, as to whether or not a reply to an exception state exists. If the answer is affirmative then the tag identifier is set to the exception state, while if the answer is negative then the tag is set to the valid state and the instruction awaits execution.