# METHOD AND APPARATUS FOR ROUTING PACKETS IN A MULTINODE COMPUTER INTERCONNECT NETWORK

## Claims
Verfahren zum Leiten von Benutzerpaketen in einem Verbindungsnetzwerk, das mehrere Knotenpunkte 10 mit jeweils mehreren Ausgangsleitungen 26, 28, 30, 32 und Paketspeichern 34, 40, 42, 44 enthält, wobei jedes Benutzerpaket einen Bestimmungsknotenpunkt aufweist,

## Description
This invention relates generally to multinode computer interconnect networks, and more particularly relates to a method and apparatus for routing packets in such networks in order to achieve a high routing efficiency and minimum grid lock problems. A computer system includes a number of separate components such as memory, processors CPUs , and input output devices. All of these components must be able to communicate with each other. The most common conventional means of intercommunication has been by the use of buses and crossbars. Recent advancements in the electronics industry are causing bus and crossbar interconnect techniques to be insufficient. Very large scale integration VLSI makes it possible to form a small, low speed processor on a single chip. It is now therefore cost effective to construct a large, high speed processor by ganging many single chip processors. When this is done, however, the interconnect between the processors becomes a major bottleneck in attempting to increase the overall efficiency of the processor. Ideally, the interconnect must be able to supply sufficient bandwidth and to connect a large number of processors together at a reasonable cost. It is also highly desirable that the interconnect be expandable, as by adding processors to increase system power. While expanding the network with further processors or devices, it is desirable that the interconnect bandwith expands with it without excessive cost and without a required purchase of initially unneeded hardware to support the future expansion. Conventional bus and crossbar interconnection techniques do not meet these requirements. A bus has only electrical limitations on the number of processors it can service, but has a fixed bandwidth. The bandwidth of a crossbar increases with the number of processors which it interconnects, but its cost grows as the square of the number of processors and is not expandable at all without initial overdesign. In local area computer networks, the bandwidth requirements are usually low enough that a bus will suffice, but buses are not fault tolerant. Failure of the bus will cause failure of the entire network. A crossbar is generally not feasible for a local area computer network because of the N² cost growth relation. The fault tolerance of a crossbar is only slightly greater than the fault tolerance of a bus, as each pair of nodes inside a crossbar has only a single link between them. Therefore, failure of the link prevents any communication between the two nodes in the crossbar. Neither crossbar nor bus interconnection techniques allow local area computer networks to be easily expandable for the reasons discussed above. More recently, expandability and fault tolerance have been somewhat imperfectly achieved by the employment of packet switching, rather than circuit switching, techniques. In packet switching, a user s logical message is separated disassembled and transmitted in multiple user packets. The packet may contain user data and control data, all of which are switched as a composite whole. Each packet of the user data generally contains a header that has information as to the packet s final destination. Packet switching often is used in a multinode system with several alternative paths between the origin of a packet and its final destination. The use of packet switching and multiple communication paths allows the bypassing of failed switches or lines and, where packet switching control is distributed at each node, allows expansion of the system without initial overdesign. However, the control software of such nodes has generally not been flexible in adapting to faults in the network. Packet switching in a multinode interconnect system has other problems as well. One of these is load balancing. Where routing rules are chosen such that a packet is sent on the path requiring the least nodal travel distance to reach its destination, often certain paths are selected at a much greater frequency than other paths, causing an imbalance of loading on the system and possible static deadlock. Another problem found in multinode packet switching systems is dynamic deadlock. Dynamic deadlock is caused when a node forces a packet out of the node in order to free a packet storage buffer for the receipt of another packet. The packet may be forced out along an output line that moves it away from the packet s destination. With a poor set of routing rules, the packet may circulate endlessly, resulting in dynamic deadlock. Therefore, a need has arisen for a multinode packet switching network which has a minimum logical distance between nodes and that is operated by a set of routing rules to prevent static and dynamic deadlock. Further, a need exists for a packet switching network that is extremely fault tolerant and provides a self repairing distributed control over the packet switching function. In a paper entitled A simulation study of a dynamic routing scheme by P.H.N. Chu et al., published in the report of the National Telecommunications Conference, New Orleans 1981, by the I.E.E.E., pages A3.4.1 A3.4.11 there is disclosed a scheme for routing packets from one node to other nodes connected in a network. An example is described having two dedicated queues with respective servers which also service a shared queue, and the results of four different service disciplines for the operation of the servers are analysed. Each packet is pre assigned to a queue according to its destination node. Each server is connected to a respective output link and does not service a dedicated queue other than its own. In US A 4,466,060 there is disclosed a routing algorithm for packets in a network in which each node receives input exclusionary trees from neighbouring nodes, prepares output exclusionary trees from the input trees, transmits the output trees to neighbouring nodes, and prepares a route table from the information in the input tree for routing packets. According to one aspect of the present invention there is provided a method for routing user packets in an interconnect network, the interconnect network having a plurality of nodes each having a plurality of output lines and packet storage, each user packet having a destination node, According to another aspect of the present invention there is provided an interconnect network for transmission of user packets and including a plurality of nodes, each node being connected by input and output lines to a plurality of other nodes, and each user packet having a destination node, For a more complete understanding of the present invention and the advantages thereof, reference is now made to the following description, taken in conjunction with the accompanying Drawings in which Although the routing system of the invention can be used in any multinode interconnect network, preferably a hypertoroidal interconnect scheme is employed. As used herein, hypertoroid describes a class of network organizations where each node has 2n connections and is a member of n rings. The number of ring dimensions, or conceptual ring families in which the network rings are formed, is also n. FIGURE 1 illustrates a hypertoroid in one ring dimension, that is, n 1. Each node 10 has only two 2n sets of input output lines 12, and is a member of only one 1n ring. A hypertoroid of one dimension is only used with a small number of nodes, as it offers only one alternative path for the switching of packets. FIGURE 2 shows a hypertoroidal network of nine nodes and two ring dimensions. The invention may also be used for hypertoroidal networks having three or more ring dimensions and a large number of nodes, but the structure shown in FIGURE 2 will be used for purposes of illustrating the invention. Each node 10 has been labeled with a capital letter for purposes of discussion, although in actual practice the node identity would of course be specified by a digital sequence. In the illustrated two dimensional case, each node 10 is connected to adjacent nodes by four full duplex lines 12. Each line 12 connects two nodes together and for purposes of discussion is labeled twice. Thus, for node A, the line connecting node A to node B is line a3 and is also line b1. Each node 10 is a member of two rings, each ring residing in a different ring dimension. Node A is a member of ring 14 and ring 16. Ring 14 includes Nodes B and C and ring 16 includes Nodes D and G. The hypertoroid has a number of advantages over other networks. It provides a large degree of expandability while maintaining short distances between nodes. Hypertoroidal structure provides multiple paths between nodes, thus allowing automatic load balancing and a fail soft capability. Simulation has shown the hypertoroid to be the network that delivers the highest bandwidth for a given number of nodes and links. The hypertoroidal network s relatively short average logical nodal distance between originating node and destination node has a strong affect on both delivery time and maximum delivered bandwidth. As the hypertoroidal network is expanded, the average distance between nodes grows slowly. Doubling the number nodes on a two dimensional network causes only a FIGURE 3 shows in a schematic manner the internal structure of Node A in the network shown in FIGURE 2. In FIGURE 2, Node A is connected to surrounding nodes by a set of full duplex lines 12, which include lines a1, a2, a3 and a4. FIGURE 3 shows that lines a1, a2, a3 and a4 are each further divided into input lines 10, 20, 22 and 24 and output lines 26, 28, 30 and 32, respectively. Input lines 18 24 and output lines 26 32 are here shown separated for purposes of clarity. Input line 18 is connected to a link 34 that comprises a demultiplexer 36, a plurality of packet storage buffers 38 44 and a multiplexer 46. A multiplexer demultiplexer control 47 controls multiplexer 46 and demultiplexter 36 through a control bus 49. The operation of buffers 38 44 is controlled by a buffer controller 51 through a control bus 53. A CPU 48, which can be a microprocessor, is connected to MUX DX controller 47 by an address bus 50. Address bus 50 also delivers instructions to buffer controller 51 from CPU 48. FIGURE 4 shows link 34 in more detail. Control bus 49 communicates instructions from MUX DX controller 47 FIGURE 3 to serial one of four demultiplexer 36. In accordance with these instructions, demultiplexer 36 will switch an incoming packet on input line 18 onto one of four buffer input lines 62, 64, 66 and 68. Concurrently, buffer controller 51 FIGURE 3 tells one of buffers 38 44 to receive a packet appearing on a respective input line 62 68. The internal structure of buffer 38 is shown in detail in FIGURE 4. A controller 70 receives instructions from control bus 53, and itself controls elements 72 76 through control lines 78 82. A signal on line 78 enables serial in parallel out shift register 72 to receive a packet on line 62, which is transmitted between nodes in serial form. Element 72 makes the packet available in parallel form at buffer bus 84. Controller 70 enables a routing header of the packet to be latched in a buffer 74 by a signal on line 80. Buffer 74 makes the header, including such items as destination node in a user packet or originating node and node distance number in a node distance packet available at a data bus 118 to be read by CPU 48. A parallel in serial out shift register 76, when enabled by a signal on control line 82 from controller 70, converts the packet back to serial form and transmits it on a buffer serial output line 86. Controller 70 enables register 72 to receive an incoming packet at the same time that register 76 is enabled to transmit an outgoing packet on line 86. Line 86 is connected to one of four multiplexer 46, which switches one of output lines 86 92 to interior output line 54 according to instructions received on control bus 49. The structure of buffers 40 44 replicates the structure of buffer 38. Referring back now to FIGURE 3, multiplexer 46 transmits outbound packets on interior output line 54 to a crossbar 122. Input lines 20 24 connect to the demultiplexers not shown of links 56, 58 and 60. Links 56 60 are organized in the same manner as link 34. Outbound packets from links 56 60 are transmitted on interior output lines 110, 112 and 114, respectively, to crossbar 122. CPU 48 communicates with a random access memory RAM 116 by data bus 118. Data bus 118 also allows communication between CPU 48 and MUX DX controller 47, main buffer controller 51, a CPU output interface element 94 and a local CPU interface 96. CPU 48 reads the header information from buffer 74 and analagous elements in order to determine which of the user packets are closest to their destinations, and which output line 26 32 is on the shortest path to the destination node. CPU 48 makes these comparisons with the assistance of a look up table, later described, stored in RAM 116. A Write ability back to buffer 74, et al., is necessary for the transmission of incremented node distance packets in connection with look up table generation at the beginning of network operation, as will be later described. CPU 48 selects one packet stored in link 34, one packet stored in link 56, one packet stored in link 58 and one packet stored in link 60 for transmission upon the next system clock pulse. By address bus 50, CPU 48 instructs a crossbar controller 98 as to which interior output line 54, 110, 112, or 114 should be electrically connected with which exterior output line 26, 28, 30, or 32. These instructions are in turn relayed by controller 98 to crossbar 122 on a crossbar bus 120. CPU output interface 94 allows CPU 48 to handshake with other nodes through a serial message line 100. Interface 94 transmits an acknowledgement signal or error message on an appropriate output line if the received packet is known to be faulty through error checking upon receipt of a packet into one of links 34, 56 60. The failure of the sending node to receive an acknowledgement from interface 94 sets up a fault detection procedure later described. Each node A I in the network may have one or more local devices 124 connected to it. These devices can be processors, memories, or input output devices. Device 124 is connected to node 10 by an interface 126. Interface 126 is in turn connected to crossbar 122 by a local device input line 128 and a local device output line 130. As it receives knowledge of a locally generated packet s destination node from a local CPU interface 96 through bus 118, CPU 48 can instruct crossbar 122 to transmit the contents of interface 126 on any output lines 26 32. CPU 48 also can instruct crossbar 122 through controller 98 to transmit a stored packet with a destination node equal to A the home node to interface 126 on line 128. Interface 96 receives the destination node of a packet to be transmitted on bus 102, and a ready to send signal and other information from device 124 on lines 104, 106. Local device 124 and interface 126 are connected by a bus 109. It should once again be noted that while the present invention is illustrated as a two dimensional hypertoroidal case, the structure of node 10 can be easily expanded to accommodate additional ring dimensions. Each additional ring dimension requires two additional input lines, two additional output lines, and two additional links. The remaining components of node 10 would be functionally the same. The number of buffers in each link could be increased or decreased, although at least four buffers per link are preferred. The number of hypertoroid dimensions and number of data packet storage buffers are selected according to desired bandwidth, degree of utilization of the network and overall internode transmission rate. FIGURE 5 is a schematic flow diagram for the table generation software stored in RAM 116. It should be noted that a look up table sufficient to operate the system could be hardwired into a PROM or like device, but it is preferred that the look up table be stored in volatile memory in order that it may be modified upon failure of one of the system s links or nodes or in the event an addition is made to the network. After power up at step 132, each node in the system will generate a node distance packet at 134. Each node distance packet includes a node identity and a node distance number. FIGURE 5 illustrates look up table generation for node A in FIGURE 2. The identity portion of a node distance packet generated at A is A . At the time of node distance packet generation, the node distance number is zero. After the node distance packet is generated, the generating node will put the node distance packet in a buffer of each of links 34, 56, 58, 60 Figure 3 at step 136. At step 138, the node transmits the node distance packet to adjacent connected nodes on each of its output lines. Simultaneously with the transmission of the node distance packets, node A will receive four node distance packets from its neighbors on the input lines at 140. This step is shown as a decision because later in the table generation process node A may not receive any node distance packets. Received node distance packets are generally noted in FIGURE 5 as X n , where X is the originating node identity and n is the node distance number of the node distance packet as received. If any node distance packets are received, CPU 48 FIGURE 3 will read them serially starting with the first link at 142. At 144, CPU 48 asks whether the received node distance packet was generated by itself. If X is equal to A, CPU 48 will discard the node distance packet at 146. If X does not equal A, the node then increments the node distance number of the node distance packet by a constant, preferably one, at 148. The packet is also associated with the input line ℓ on which it appeared. At decision 150, CUP 48 looks at its look up table in RAM 116 FIGURE 3 at the entry corresponding to node identity and input line ℓ. An entry in the total at T, X,ℓ corresponds to a node ℓ distance to node X on a path including output line ℓ. If the entry is zero, indicating that no information has yet been received corresponding to that entry, the entry is set to n 1 at 152. If entry T X,ℓ , is non zero, the node distance number n 1 of the packet n 1,ℓ is compared at 154 to the corresponding table entry T x,ℓ . If the node distance number is less than the existing table entry, n 1 is set equal to the entry at step 152. Otherwise, node distance packet X n 1,ℓ is discarded at step 146. Where a node distance number n 1 of a packet has been set to a look up table entry, the node distance packet X n 1 is dissociated from line ℓ, preserved and is placed in a transmission queue at step 156. As incremented, the node distance packet will be transmitted on all lines to adjacent nodes, thereby passing on correct information as to how far away node X is by the path taken by X n 1 . On the other hand, if node distance packet X n ℓ has a node distance number n 1 less than that already present in the table at node T X,ℓ , it shows that the path taken by X n 1,ℓ is not the shortest path to node X that includes line ℓ. Therefore, the node distance packet is discarded. At 156, X n 1 is placed in a queue instead of directly into a buffer because, during the table generation process, the number of node distance packets to be transmitted on the output lines soon exceeds the number of buffers available to store data. For instance, during the first system clock cycle, node A will receive node distance packets D 0 , G 0 , 0 0 and C 0 See FIGURE 2 . After the distance number of these node distance packets is incremented by one, the node distance packets will be D 1 , C 1 , D 1 , and G 1 . An entry of one will be placed in the look up table at T D,2 T G,4 T D,3 and T C,1 . Since all of the node distance packets received during the first clock cycle are used to supply information to the look up table, none of these node distance packets is discarded and therefore all will be retransmitted. As replicated four times, the node distance packets received during the first clock cycle therefore will by themselves occupy all 16 available storage buffers in awaiting for retransmission. Subsequent valid undiscarded node distance packets in excess of one are therefore stored in a queue pending the opening up of buffers. At step 158, the receiving link ℓ is incremented by one and the line number is tested to four, the maximum link number, at 160. Link ℓ and input line ℓ are associated structures, as shown by FIGURE 3. If one or more links have yet to be looked at, the table generation procedure returns at 160 to step 144 and repeats the process for the remaining links. If all links have been searched, the procedure then proceeds to step 164 right side of figure , and asks whether any incremented node distance packet X n 1 is present in the transmission queue. The no branch from decision 140 also branches to this set. If there exists an X n 1 in the transmission queue, as will be the case during most of the procedure, a distance node packet X n 1 at the top of the queue is placed in one buffer on each link at step 166 so that the distance node packet can be retransmitted on each output line X n 1 is thus replicated four times before being transmitted. The procedure then asks at step 168 whether there are any further node distance packets in the transmission queue. If there are, step 170 determines whether or not there are any remaining buffers Buff, ℓ,a to hold the further queued node distance packets. The number of empty buffers will be a multiple of four, as the buffers are filled and emptied four at a time, one per link a is the buffer number, and varies from one to four. If there are no further node distance packets in the transmission queue, or if there are no further empty buffers to contain such node distance packets, the contents of buffer a in each link ℓ will be transmitted to all adjacent nodes at step 172. If there are further empty buffers, further node distance packets will be placed in them at step 174 and the procedure will loop back to step 168. If no node distance packets are found in the transmission queue at 164, the procedure branches to step 176, which begins a subprocedure to find out whether any active node distance packets are still being transmitted within the nextwork. Step 176 asks whether any node distance packet X n 1 is present in any buffer in any link. If one or more node distance packets are ready for retransmission, a count variable is set at zero at step 178 and the found node distance packets are retransmitted at step 172. If no node distance packets are found in the buffers, COUNT is incremented by one at step 180 and compared to an arbitrarily set constant S in order to determine how many cycles have elapsed without the node retransmitting a node distance packet. S is set so that, when queue backups are taken into consideration, node distance packets transmitted on all lines from the node having the largest logical separation are able to reach the subject node here, Node A . If COUNT is less than S at 182, the procedure returns to step 140 to begin the next cycle in the table generation procedure. The procedure also returns to 140 after transmission of the contents of one group of four buffers at 172. If COUNT is greater than or equal to S at 182, indicating that no node distance packets have been transmitted for a number of cycles, a full A packet is transmitted at 186, indicating that Node A s look up table is finalized. Step 188 tests whether the node has received similar full B , full C , etc., packets from each other node in the system. If such is not the case, the procedure returns to 140 to begin another cycle. However, if full X packets have been received for each node in the system, it is an indication that all look up tables in the network have been finalized and the network is ready to begin switching user packets at 190. The packet switching procedure shown in FIGURE 7 is then employed. At node distance packet transmission step 172, buffer a is selected preferably in sequence, i.e., if buffer number one for each link one through four is selected in the first cycle for transmission, buffer two would be selected for transmission in the second cycle, etc. This pattern would repeat in order to assure that no destination node packets are transmitted out of sequence of their receipt. The efficiency of table generation is thereby increased because the node distance packets evidencing the shortest logical routes will arrive at Node A first, with node distance packets that have taken more circuitous paths arriving later. The transmission mnemonic could also be somewhat improved by not transmitting the node distance packet back to the node from which the node distance packet was received, as that retransmitted node distance packet would merely be discarded by the source node. However, this logical refinement requires further overhead to execute and may thus not be desirable to institute in many instances. FIGURE 6 is a conceptual diagram of a completed look up table 192, stored in RAM element 116 FIGURE 3 . The look up table shown in FIGURE 6 corresponds to the relatively simple, two dimensional hypertoroidal network shown in FIGURE 2 and would of course be expanded for a network having additional dimensions or nodes. The completed table shows the shortest logical distance to the referenced node along the referenced output line. Corresponding to a user packet being transmitted out of output line 28 part of full duplex line a2 and having a destination node G, the entry T G,2 is equal to two node distances. Entry T G,4 shows that it is more economical to send a G packet out line 1, as Node G is only one node distance away by that route. Although a hypertoroidal network is preferred for minimum logical distance growth, the look up table exemplified by FIGURE 6 could also be generated for any multinode system architecture. Once a look up table 192 is generated for each node, the network is ready to switch user packets from local devices 124 FIGURE 3 onto the network. Used herein, user packet means a packet of fixed, constant length of user program material containing data and or instructions. During each packet switching clock cycle of the user program operation, any of nodes 10 FIGURE 2 will receive user packets P X on any of input lines one through four 18, 20, 22, and 24 FIGURE 3 and will be stored in links 34, 56, 58 and 60 in an empty buffer selected by CPU 48. The packet switching procedure operates such that there are always at least four buffers, one buffer per link, in an empty condition ready to receive a user packet. Referring to FIGURE 7, user packets are input into four empty buffers one per link ℓ, at step 194. Step 196 then asks whether there is still a non empty buffer after receipt of user packets from other nodes. If one or more non empty buffers do exist, user packets P X of local origin are put into one or more empty buffers from local device 124 FIGURE 3 . Referring back to FIGURE 3, a local user packet is switched into one of the buffers in link 34, 56, 58 or 60 through the action of crossbar 122 and controller 98. Whether a locally originated packet can be placed in an empty buffer or not, variable ℓ is set to one at step 200. Next, step 202 checks to see if all buffers in the inspected link are empty at step 202. If all of the link s buffers are empty, the program branches to step 204, where the link number is incremented at step 204, tested to see if the link number exceeds the maximum at 206 and the next link in numerical sequence is inspected at 202. If a non empty link is located, buffer variable a is set to one at 205. At 206, the destination node in the packet header is read from buffer latch 74 FIGURE 4 . Then, entries T x,oℓ , oℓ 1 to 4 in the look up table for the packet s destination node X are retrieved. As used for FIGURE 7, oℓ is an output line variable ranging from one to four. The minimum logical distance is next determined by picking the minimum of T x,oℓ and equating it to the distance P X,ℓ,a that the user packet in buffer ℓ,a has left to travel. At step 208, the output line oℓ preferred by user packet P X,ℓ,a is set equal to the output line giving the minimum distance in table T. At step 210, buffer a is incremented by one and is compared to the number of buffers in each link here, four at step 212 to check if the possible number of buffers has been exceeded. If a is less than four, the process of determining P X,ℓ,A and oℓ P X,ℓ,A is repeated for each buffer within the link. When step 212 determines that all of the buffers in the current link have been inspected, one of the user packets stored in the link having the smallest d is selected as a member of a set S at step 214. User packets belonging to set S get first priority in the assignment of output lines for transmission to adjacent nodes. Each member of S ℓ is associated with an output line oℓ S ℓ equivalent to the preferred output line of the chosen stored user packet, and has a nodal distance d S ℓ equivalent to the nodal distance of the chosen user packet. Once a member of S is chosen for the current link ℓ, the link number is incremented by one at step 204 and compared against the total number of links in the node at step 206. If the link number is less than the total number of links in the node, the process repeats to select further members of set S. Upon completion of the selection of members of set S, the members are sorted at step 216 top according to the nodal distance d to their respective destination nodes, from smallest to largest. At 218, the member of S ℓ having the smallest d is retrieved. Step 220 determines whether the output line preferred by the retrieved user packet has been assigned yet. If not, the output line is then assigned at step 222 by placing S ℓ at the top of the transmission queue for that output line. If the retrieved member of S ℓ has a preferred line which has already been assigned, the procedure considers the member of S ℓ having the next smallest d at 224. By steps 216 224, therefore, from one to all of the members of S ℓ are assigned to output lines, depending on the availability of those output lines for transmission. The member of S ℓ having the shortest nodal distance to its destination will certainly be assigned to an output line and transmitted during the current system clock cycle. Whether succeeding members of S ℓ are assigned to output lines depends on whether those output lines have been previously assigned to previously considered members of S ℓ . Step 226 asks whether there are any remaining members of S ℓ to be considered. If there are, the procedure returns to step 224. If there are not, the procedure goes to the next phase of user packet selection for transmission at decision 228, which asks whether any unassigned output lines remain after the members of S ℓ have been assigned to them. If no output lines remain unassigned, four assigned user packets are ready for transmission and the procedure branches to transmission step 230. If there are remaining unassigned output lines, a second phase of the user packet selection procedure first sets ℓ to one at step 232. The procedure inspects the current link at 234 to determine whether or not all of its buffers contain unassigned user packets. If the current link is full , i.e., all of its buffers contain unassigned user packets, step 236 determines whether any of the unassigned user packets have a preferred output line equivalent to an unassigned output line. If so, the matched user packet is assigned its preferred output line at 230. Then link number is compared to the maximum number of links at 240. If all of the links have not yet been considered, the link number is incremented by one at 242 and the next link is considered at 234. If all of the links have been considered by this phase of the assignment program, a third phase of user packet assignment begins at step 244, which asks whether any unassigned output lines remain. If not, the procedure branches to transmission step 230. If there are remaining unassigned output lines, then step 246 inspects each link to determine if any of them are full. If one or more full links remain, the program assigns at 248 any unassigned user packet in the full link to an unassigned output line, without considering whether the preferred output line of the user packet is the same as the unassigned output line. This phase ensures that at least one empty buffer will be available in each link to receive incoming data upon the next packet switching clock cycle. If at 246 it is determined that each link has one empty buffer or one buffer containing an already assigned information packet, the procedure branches to step 250 where all remaining information packets are assigned if their preferred lines are equivalent to any unassigned output line. After step 248 of the other branch, the program once again asks whether any unassigned output lines remain if there are, the program goes to step 250. Otherwise, the program branches to transmission step 230. After step 250 has been completed, or in the case that the unassigned output lines have been exhausted before step 250, the assigned information packets are transmitted on their respective assigned output lines at step 230. Step 230 is simultaneous with the receipt of further information packets on input lines a1 a4. Thus, although for purposes of description step 230 and step 194 are conceptually separated by return 254, the transmission step 230 of a previous packet switching cycle occurs simultaneously with the receipt of information packets at 194 in a subsequent packet switching cycle. Referring back to FIGURE 4, this is possible because, if buffer 38 is the only empty buffer in link 34, an incoming packet will input serially into register 72 at the same time that an outgoing packet is being serially outputted on line 86 out of shift register 76. Thus, no space conflict between the packets occurs. The above described packet switching procedure may be summarized as follows FIGURE 8 is a conceptual diagram of a completely full set of links in Node A of FIGURE 2. Each buffer contains a user packet including a header having a destination node identifier. For example, buffer 2,4 has a packet destined for Node E. The circled data packets are selected for transmission on the nodes output lines as follows. During the first user packet selection stage steps 196 228, FIGURE 7 set S is formed from the data packets in each link having the smallest distance d . This can be determined by referring to the look up table of FIGURE 6. Ties go to the first packet of two considered. For link 1, S 1 P I,1,1 , as d P I,1,1 2, a distance at least as small as those available for packets E or F. oℓ Pa I,1,1 , the output line giving the smallest distance, is 1. Therefore d S 1 2 and oℓ S ℓ 1. Similarly, S 2 P C,2,2 , d S 2 1, oℓ S 2 1 5 3 P D,3,2 , d S 3 2, oℓ S 3 2 and S 4 P D,4,2 , d S 4 2, oℓ S 4 2. Next, the members of S are arranged in the order of smallest to largest distance S 2 , S 3 , S 4 , S 1 . Then, the members of S are sequentially assigned to ouput lines. S 2 is assigned to output line 1. S 3 is assigned to output line 2. S 4 is not assigned, as its preferred output line has already been assigned to S 3 . S 1 is passed over because its preferred output line has already been assigned to S 2 . After the first data packet selection stage, there are still two unassigned output lines 3 and 4 . Therefore, the second user packet selection stage is entered into steps 232 242, FIGURE 7 . Links 1 and 4 are still full . In link 1, the preferred output lines for the stored packets are as follows oℓ P I,1,1 2 oℓ P E,1,2 2 oℓ P E,1,3 2 oℓ P F,1,4 1. In the basic illustrated algorithm for selection of the preferred output line, ties go to the first output line considered. Thus, for P E,1,2 , either line 2 or 3 gives the minimum distance d of 2, but line two will be chosen over line 3. A more complicated line selection algorithm could throw out previously selected lines as possible choices in the last example, this improvement would cause oℓ P E,1,2 3 instead of 2. As it is, however, no packet is found in Link 1 whose preferred output line equals an unassigned output line. In link 4, the other full link, the preferred output lines are oℓ P H,4,1 3 oℓ P D,4,3 2 oℓ P D,4,3 3 oℓ P I,4,4 1. Line 3 is unassigned, and therefore is assigned to P H,4,1 . The remainder of the packets in link 4 prefer already assigned lines. At the end of stage 2, there is still a full link link 1 and an unassigned line output line 4 . Steps 244 and 246 FIGURE 7 therefore force the packet selection procedure into a third state step 248 . The packet in the first buffer of link 1 P I,1,1 is taken and assigned to output line 4 for transmission without considering the preferred line for a packet with destination I. Fortunately, line 4 is as good a choice as preferred line 1 See FIGURE 6 . Since all output lines have been allocated to packets, the mode is ready to transmit at the start of the next clock cycle at step 230. FIGURE 8 shows the packets to be transmitted in circles and their respective assigned output lines in the rightmost column. FIGURE 9 is a flow diagram of the fault packet generation subroutine entered into when a node or a line in the system fails. At system startup 255, a resend incremented variable R is set to zero and a fault packet flag FPFLG is also set to zero. At 256 a Node X notes a failure to receive an acknowledgement code from an adjacent Node Y after X has transmitted a packet to Y. This causes Node X to resend the packet at 257 and to increment R at 259. R is compared against a predetermined constant K at 261. If R is less than K, the resend procedure loops to step 256. If R is greater than or equal to K, a fault packet FP is generated at step 258. The node checks whether FPFLG at 263. On the first pass, FPFLG will equal zero and the node therefore wipes its look up table at 260. Wiping the look up table is necessary because its entries are valid for the system condition previous to the fault only. The failure of a line or node will change several values in the table see FIGURES 10 and 11 . At 262, most of the packet transmission procedure outlined in FIGURE 7 is short circuited. Until all look up tables are generated, user packets P Z will only be transmitted to empty one buffer in a full link, and then without reference to the packet s preferred line, per step 248 in FIGURE 7. Since the other packet selection stages 214 222 , 234 242 , 250 in FIGURE 7 use the look up table, they are bypassed. FPFLG is set to 1 at 265. Fault packets are transmitted on all output lines as they become available at 264. Adjacent nodes each receive a fault packet at 266, and they copy the procedure undergone by the sending node starting at 263. This eventually erases all look up tables in the system. After a node has already wiped its look up table, it will most likely receive further fault packets at step 266. However, because FPFLG has been set to 1 at 265 for such a node, the procedure branches at 263 to step 268 instead of rewiping the look up table at 260. The received fault packet is discarded and not retransmitted at 268. This branch will eventually eliminate all fault packets in the system. After a node has transmitted fault packets at 264, it will begin to regenerate its look up table at 132 after the table generation procedure shown in FIGURE 5. At 270, FPFLG is set back to 0 to rearm the subroutine after one system clock cycle. The step is taken after one cycle in order for the system to have purged all current fault packets near the node. After all look up tables are regenerated, the program returns to the user packet switching procedure of FIGURE 7 at 190. FIGURE 10 conceptually shows a look up table that has been regenerated according to the procedure diagrammed in FIGURE 9. In this case, line e1 see FIGURE 2 between Nodes D and E has failed, and Node D is unable to get a response from Node E that an information packet has been received. This causes the tables of Nodes A I to be wiped, and the table regenerated as shown in FIGURE 10, the circled entries are those that have changed show the values as a result of the line failure. FIGURE 11 conceptually shows what happens when an entire node, in this case Node E of FIGURE 2, fails. In this case, since no node distance packets can emanate from E upon table regeneration, none of the regenerated tables of the remaining nodes will have any entries concerning Node E. Node E has effectively been taken out of the network. An executing program requiring the use of a device locally connected to node E will crash. However, assuming that the function provided by Node E s local device is duplicated elsewhere in the network, the program can be modified and reloaded without any hardware repair to the network necessary. In both FIGURES 10 and 11, it should be noted that certain node distance values a2B, a3D change even though they do not have any thing directly to do with Node E. This is why regeneration of all look up table entries is necessary. In summary, a routing procedure and node architecture is disclosed for a multinode interconnection network, and specifically for a hypertoroidal interconnection network, which efficiently switches user packets among the nodes in the system. The routing procedure is so constructed that static and dynamic grid lock are avoided. As used, the network exhibits an effect analogous to a gravational field with respect to a user packet and its destination node as the user packet gets closer to the destination node, it tends to be more and more preferentially chosen for transmission increasing its overall internodal velocity number of switches cycle . As mentioned, the routing procedure and nodal architecture disclosed herein may be used for a network having other than a hypertoroidal architecture. All that is required is that the nodes have an equal number of inputs and outputs and that their connecting lines be in a full duplex configuration. Various improvements may be made to the basic algorithms shown. For example, a set of transmission cues, one for each output line, may be established as a portion of the user packet switching procedure. A user packet would then be assigned a transmission priority only once, instead of at each system cycle. However, such a cue, in common with other improvements, tends to increase the complexity of the algorithm and thus system overhead. The routing procedure and nodal architecture described herein also provide a fail soft system network. The failure of one or more lines generally will only increase computing time by a certain amount, and even the failure of an entire node will not require subsequent hardware repair in order for the network to operate.