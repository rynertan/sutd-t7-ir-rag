# ON THE FLY MULTIBYTE ERROR CORRECTION

## Claims
Fehlerkorrektursystem, das zur Korrektur bis zu einer vorgegebenen Anzahl von t Fehlern in einem Codewort ausgebildet ist, wobei jedes Zeichen von einem aus einer eindeutigen Kombination b binärer Bits bestehenden Byte dargestellt ist, ein Codewort bis zu 2

## Description
This invention relates in general to error correction and, in the preferred embodiment to an error correcting system for correcting multibyte errors in a codeword in which the identity of the error locations and the identity of the error patterns are achieved simultaneously. Most data storage subsystems associated with modern information handling systems employ some type of error correction system in order to obtain cost effective design for high reliability and data integrity. The ability of the data processing system to retrieve data from the storage system, i.e., access time, is a well recognized measure of the efficiency of the overall storage system. In most data processing systems, the decoding time for the error correction code is a direct factor in the total access time. As the capacity of storage devices has increased, the need for increased reliability and availability has also increased. As a result, the time required to process soft errors by the error correcting system becomes a larger percentage of the total access time. Multibyte error correcting systems suggested in the prior art require a relatively long time for decoding of the multibyte errors. This has been one of the main objections to their use in high performance storage systems. The following references disclose basic and significant aspects of prior art error correcting systems References 1, 2 and 3 provide a wide class of cyclic error correcting codes which are commonly known as Reed Solomon Codes and BCH Codes. These codes, when defined over nonbinary or extended binary finite fields, can be used for correction of symbol errors as binary byte errors. References 4 and 5 provide the basic key to the solution of the multi error decoding problem by suggesting the use of the error locator polynomial . These references 4 and 5 suggest the use of a set of linear equations to solve for the coefficients of the error locator polynomial. References 6 and 7 suggest the use of an iterative method to compute the coefficients of the error locator polynomial. The roots of the error locator polynomial represent the locations of the symbols in error. Reference 8 suggests a simple mechanized method, the Chien Search , for searching these roots using a cyclic trial and error procedure, while reference 9 provides further simplification in the computation of error values in the case of codes with non binary or higher order binary symbols. The contribution of the error locator polynomial in references 4 and 5 was significant in that the roots of this polynomial represent the locations of the symbols in error for a multibyte error correcting system. The method of decoding multibyte errors in a multibyte error correcting system generally comprises four sequential steps All known methods for decoding multiple errors require completion of step 3 before beginning step 4. Because of that situation, prior art systems also require additional hardware to accumulate the results of step 3 for use subsequently by the hardware that implements step 4. References 6 and 10 provide good discussion on the prior art decoding methods. The present invention is directed to an error correcting system in which the problems of the prior art have been eliminated. GB A 2 093 238 discloses, a system for correcting up to three bits in error in a, conceptually, bit serial word, protected by a BCH code, without generating error locator polynomials. Instead, plural values are calculated for each bit position in turn and bit inversion, or not, is performed depending on the current set of values. The values for each bit position are calculated using feedback shift registers and ROM look up tables to provide functions of the full word syndrome values and current bit related powers of the selected primitive element of the appropriate GF. In the case of three error correction, a compound function of these functions is also used and the decision to use or not depends on the relationship of selected full word syndrome values. The variable times that would be required to perform the divergent calculations are smoothed out by the use of pre calculations stored in the ROM tables. Thus, the full word syndrome values are generated as the word is received and buffered and are, in turn, buffered for repeated use during the correcting process. In theory, once the buffering is complete, a new full word could be received provided that the calculations can be done at a rate not slower than the bit reception rate. The patent is silent on this point, buffering of the full word syndrome values being performed because, being shift register generated, they are only available in the shift register at a single clock time and are changed at the very next clock. Clearly, this system does not suffer from the sequential step problem recited since step 2 is also avoided but it is not perceived how this arrangement could be applied to byte, rather than bit, correction. Given the need for data on both the identity and location of the errors, as is the case with byte correction, the above system appears not to be adaptable. Various systems are proposed for correcting errors on the fly and for operating on byte errors rather than bit errors. Attention is drawn to IBM Technical Disclosure Bulletin, Vol. 17, No. 2, July 1974, pages 473 to 475, wherein the current inventor discusses a multiple byte tape correction technique using hard and soft pointers and interleaved words. This prior art document however is essentially concerned with how sets of codewords are to be interleaved, and does not discuss decoding of individual codewords, which is the focus of the present invention. Speed of decoding, a major factor in approaching on the fly correction, was considered in the context of an SEC DED Reed Solomon code, in the 3rd USA JAPAN Computer Conference, 1978, Session 11 1 1, and reported at pages 203 to 207 of the Proceedings thereof. Parallel decoding logic is proposed and the key comment is that the complexity and delay of the decoder is not impractical. There is no suggestion of an on the fly decoder. Accordingly, the invention provides an error correcting system, operable to correct up to a given number t of errors in a codeword, wherein each character is represented by a byte consisting of a unique combination of b binary bits, a codeword containing up to 2 The invention also provides an error correcting method for an error correcting system, It must be noted that the formulae given above merely indicate the mathematical basis of the invention, rather strictly specify the actual calculation steps followed. As an example of this, the denominator in the expression for E Many other manipulations of the above formulae will be readily apparent to the skilled man for performing the required calculations, which must of necessity be mathematically equivalent to the formulae given above and so be encompassed by the present invention. In accordance with the present invention, an error correcting system is provided in which steps 3 and 4 of the decoding procedure for multibyte errors are completed simultaneously. In particular, the location and value of each error are computed in cyclic order without explicit information regarding the location of the remaining errors which are yet to be determined. Step 3, which involves the Chien Search function is expanded into a complete mechanization of the error correcting procedure, and as a result, data characters in the codeword can be transferred from the error correcting system to the data processing system one at a time in synchronism with each cycle of the Chien Search. The access time to the first byte of data is, therefore, not impacted by the time required for the identification of the error locations and development of the error values of the errors. The hardware of the error correcting system is also highly simplified since the results of step 3 which normally had to be stored no longer need to be stored. The same set of hardware obtains the error values and the correction for all errors at the appropriate cycle during the Chien Search even when the actual number of errors is less than the designed maximum. Such an arrangement was only possible in prior art single symbol correcting codes. The improved system also avoids all division operations in obtaining the coefficients of the error location equation when the syndrome processing unit and the error pattern processing circuits of the present invention are employed. The situation where less than a maximum number of errors are present in the code word results in additional simplification of the hardware which becomes important when the circuitry of the error correcting system is being implemented in very large scale integration. The simplification is important in that when the circuitry has been implemented in VLSI to operate with 2t input syndrome bytes, the same VLSI circuitry can be used in environments which provide less than 2t input syndrome bytes. It is therefore possible to provide a multibyte error correcting system which has a minimal effect on the access time of an associated data storage system. It is further possible, to provide a multibyte error correcting system in which the transfer of the codeword from the error correcting system is initiated prior to the time that the identity of all the error locations is known and to provide a multibyte error correcting system in which the location and error pattern of each byte of the codeword that is in error is simultaneously identified as bytes are being transferred from the error correcting system so that errors are corrected on the fly. There is disclosed hereinafter an ECC system which is operable to correct any number of errors up to the maximum number for which it has been designed so that the same hardware may be employed to correct less than the maximum number of errors in one application or, alternatively, employed with a different application which employs a fewer number of check bytes and syndrome bytes. Only one inverse operation is involved in developing the error patterns. The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular description of a preferred embodiment of the invention as illustrated in the accompanying drawings. A description of the system shown in FIG. 1 will first be provided. The description of the syndrome processing logic for identifying error locations and the method of operating the logic will then be followed by a mathematical explanation and proof of the manner in which the logic has been implemented. This explanation will describe in mathematical terms the operation of the error correcting system for the general case of any number of errors. FIG. 1 shows the block diagram of an on the fly ECC system. The syndrome processing unit develops the coefficients for the error locator equation. The correcting process of the FIG. 1 system is continuous. An uninterrupted stream of data enters and leaves the decoder in the form of a chain of n symbol codewords, hence the name, on the fly decoding. From a practical viewpoint, a given decoding process can be considered on the fly if it meets the following test, namely, the corrected data bytes of a previously received codeword are delivered to the user system while the data bytes of the following codeword are being received. The decoder, comprising blocks 6, 7, 8, 9, computes syndromes for the incoming codeword as it decodes and corrects errors in the previously received outgoing codeword. Each clock cycle corresponds to an input of one data symbol of the incoming codeword concurrent with an output of one corrected data symbol of the outgoing codeword. A buffer 5 holds at least n symbols of the uncorrected data in between the incoming and outgoing symbols. A three error correcting Reed Solomon Code in GF 2⁸ is used as an example of special interest for applications in computer products. The 256 elements of GF 2⁸ are conventionally represented by the set of 8 bit binary vectors. One such representation is given in Table 1. In a three error correcting Reed Solomon code, there are six check symbols corresponding to the roots α⁰, α¹, α², α³, α⁴, α⁵ of the generator polynomial where α is an element of a finite field GF 2⁸ and is represented by an 8 bit binary vector. The corresponding syndromes computed by block 6 are denoted by S₀, S₁, S₂, S₃, S₄, and S₅ respectively. These syndromes are computed from the received codeword in the conventional manner in accordance with any known prior art process. The implementation for this step is well known and makes use of exclusive OR circuits and shift registers. The details of the block 7 logic circuits are shown in FIGS. 2 and 3. The overall function of the block 7, shown in FIGS. 2 and 3, is first to implement the following four equations in FIG. 2 to develop the locator parameters Δ₃₃, Δ₃₂, Δ₃₁ and Δ₃₀ for the three error case, which also includes the parameters Δ₂₂, Δ₂₁ and Δ₂₀ for the two error case where, for example, the subscript 33 identifies one of four parameters. From these locator parameters, the coefficients Δ₃, Δ₂, Δ₁ and Δ₀ are selected by the logic shown in FIG. 3 in accordance with the exact number of errors that are involved in the particular codeword. The equations for Δ₃₃, Δ₃₂, Δ₃₁ and Δ₃₀ are as follows The combinatorial logic shown in FIG. 2 includes two basic logic blocks 10 and 11. The first block 10, represented by an X, corresponds to a product operation in GF 2⁸ involving two 8 bit binary vectors, while the second block 11 represents a sum operation in GF 2⁸ involving two 8 bit binary vectors. The operation of block 11 is a simple bit by bit exclusive OR logical function using eight 2 way exclusive OR gates. The product operation, on the other hand, represented by block 10 is more complex and involves 76 exclusive OR circuits and 64 AND circuits. The need for the 76 XOR circuits and 64 AND circuits may be seen from the following explanation of the product function of block 10. The product operation of block 10 involves two 8 bit vectors A and B to produce a third vector C where Second, reduce the polynomial F, modulo p x , where p x is a primitive binary polynomial of degree 8. Use The first term of the error locator polynomial S₂ S₁, S₃ S₂, S₂ of the Δ₃₃ equation is implemented by dashed block 16 in FIG. 2. The output of block 16 is exclusive ORed in gate 18 with the second term of the equation and the result exclusive ORed in gate 19 with the last term of the equation. The blocks involved in developing each of the other parameters Δ₃₂, Δ₃₁ and Δ₃₀ may be traced in a similar manner in FIG. 2. The parameters Δ₂₂, Δ₂₁ and Δ₂₀ for the case when only two errors occur are cofactors in equation 1 for Δ₃₃. These cofactors are FIG. 3 illustrates the logic for selecting the coefficients of the error locator polynomial from the locator parameters Δ₃₃ through Δ₃₀ and the cofactors Δ₂₂ through Δ₁₀. The FIG. 3 logic functions to identify the number of errors from the input parameters Δ₃₃ through Δ₃₀ and the cofactors Δ₂₂ through Δ₁₀ and select the appropriate value Δ When Δ₃₃ is non zero, indicating the presence of three errors, the coefficients Δ₃ through Δ₀ will assume the values Δ₃₃ through Δ₃₀. As shown, when Δ₃₃ is non zero, the output of AND gate 41 is low, permitting the Δ₃₂, Δ₃₁ and Δ₃₀ signals to be gated through AND gates 42, 43 and 44 respectively since the output of AND gate 41 is inverted at the input to each gate 42 44 to enable each of the AND gates. A similar logic function is achieved by Δ₂₂ if Δ₃₃ is zero indicating not more than two errors are present. In such a situation, Δ₂, Δ₁ and Δ₀ will take the values of Δ₂₂, Δ₂₁ and Δ₂₀ respectively through the operation of AND gates 51, 52 and 53 respectively. This function corresponds to the syndrome equation for two errors. The logic circuitry of FIG. 3 functions similarly if Δ₂₂ is also zero to cause Δ₁ and Δ₀ to assume the values of Δ₁₁ and Δ₁₀. AND gates 61 and 62 gate Δ₁₁ and Δ₁₀ respectively through OR gates 71, 72 if Δ₃₃ and Δ₂₂ are both zero since AND gate 60 provides the enabling signal. The overall logic of FIG. 3, therefore, functions to produce or to select the correct values of the coefficients Δ₃ The hardware for developing the coefficients Φ of the error value equation which is expressed as follows will now be described. The error value equation for the generic case is developed later in the specification. The general equation can be converted to the specific three byte error correcting system set forth in the drawings such that the coefficients may be defined as As shown, FIG. 5 comprises four feedback shift registers 120 0, 120 1, 120 2 and 120 3 which receive the error location coefficients and three feedback shift registers 130 0, 130 1 and 130 2 which receive the three error pattern coefficients. The block labelled 120 implements the following equation The product block 145 multiples the two 8 bit vectors in a manner identical to product blocks 110 and 10 described earlier and comprises 76 exclusive OR gates and 64 AND gates, each of which are 2 input gates. The output of product block 145 is the error pattern E As shown in FIG. 5, a clock signal C is supplied to the shift registers and buffers so that the bytes of data in error are each supplied to exclusive OR block 147 at the appropriate time determined by the recognition that the error is located as indicated by a zero at the output of exclusive OR block 127, thereby signifying that the output of the product block 145 contains the correct error pattern for that byte position. The operation of the FIG. 5 circuitry is as follows. The computed values of the coefficients Δ₃, Δ₂, Δ₁ and Δ₀ and Φ₂, Φ₁ and Φ₀ are entered into the appropriate shift registers at clock 0 time. Each clock cycle generates a shifting operation of these registers. A shifting operation multiplies the contents of each register by a specific constant, namely α₃, α₂ and α , in the case of the shift registers for Δ₃, Δ₂, and Δ₁ respectively and α₂ and α in the case of registers of Φ₂ and Φ₁ respectively. At the i The algebraic inverse in GF 2⁸ can be obtained through combinational logic which maps each 8 digit binary sequence into a specific 8 digit binary sequence. This mapping requires, at the most, 304 two terminal AND gates and 494 two terminal OR gates. The method of developing the inverse is shown later on in the specification. When the error location is identified, data character from buffer 4 is modified by E The corrected bytes in the decoder of FIG. 5 are delivered in the order B₀, B₁, B₂, ..., B In these equations, j represents the clock cycle count, and j 1 to c, successively, correspond to the byte position values i c 1 to 0. This provides delivery of bytes in the order B To accomplish the above mentioned modification, the following changes are made in the logic of FIG. 5 1 the shift register multipliers α³, α², and α are replaced by α ³, α ², and α ¹, respectively 2 the coefficients Δ₃, Δ₂, Δ₁, Φ₂, and Φ₁ are premultiplied by the constants α The following is the mathematical derviation for the equations used in the logic implementation of FIGS. 2 and 3. In the three error correcting Reed Solomon Code in GF 2⁸ there are six check symbols corresponding to the roots α⁰, α¹, α², α³,α⁴, α⁵ of the generator polynomial. The corresponding syndromes are denoted by S₀, S₁, S₂, S₃, S₄ and S₅ respectively. We assume that, at the most, three symbols are in error. The error values are denoted by Ei₁, Ei₂ and Ei₃ and the locations of erroneous symbols are denoted by i₁, i₂ and i₃. Then the relationships between the syndromes and the errors are given by Consider the polynomial with roots at α Substituting x α We can solve Equation 4A and obtain σ₀, σ₁ and σ₂ as where Δ₃₃, Δ₃₂, Δ₃₁ and Δ₃₀ are given by Let v denote the exact number of errors, which may be 3, 2, 1 or 0. The exact number of errors is determined as follows Then equation 5A can be rewritten as Conventionally, the error locator polynomial 3A with the coefficients σ₀, σ₁ and σ₂ of equation 21A is used to determine error locations through the well known Chien search procedure. However, the error locator equation can be modified in order to avoid the division by Δ Next an expression is derived for the error values E Solving 23A for E From Equation 2A Using Equation 5A Equation 27A can be reduced to Notice that the error value E where the coefficients Φ₀, Φ₁ and Φ₂ are given by The syndrome decoder then consists of computation of various quantities in Equations 22A and 29A for each value of i in a cyclic iterative manner and then affecting the correction of an outgoing symbol with E The following is the mathematical derivation for the general case to establish that the logic set forth in FIGS. 2, 3, 4 and 5 for the special case of up to three errors is applicable in general for t errors. In a general BCH or Reed Solomon code, the codeword consists of n symbols which include r check symbols corresponding to the roots α where B and₀, B and₁, B and₂, ..., B and Let v denote the actual number of symbols in error in a given codeword. The error values are denoted by E Any non zero value of a syndrome indicates the presence of errors. The decoder processes these syndromes in order to determine the locations and values of the errors. Let t denote the maximum number of errors that can be decoded without ambiguity. A set of r 2t syndromes are required to determine the locations and values of t errors. Consider the polynomial with roots at α where σ₀ 1, σ Substituting x α Using Equations 2B and 4B , it is easy to show that the syndromes S The set of equations 5B can be rewritten in matrix notation as Let M denote the tx t 1 syndrome matrix on left side of Equation 6B. Let M where Δ If matrix M It can be easily seen that Δ Thus the values Δ In order to accomodate the special cases of all fewer errors, we will replace Equation 7B by a more convenient general form where v is determined from the fact that Δ Since σ₀ 1, one can determine σ The error location values iε I are the set of v unique values of i which satisfy Equation 11B. The error locator polynomial as defined by Equation 2B has v roots corresponding to v error location values. Consider a polynomial which has all roots of the error locator polynomial except one corresponding to the location value i j. This polynomial is defined as When the actual number of error locations v is less than t, the coefficients σ Examine an expression similar to one in Equation 5B involving the syndromes S Interchanging the order of summing parameters m and i in Equation 14B we get Now using Equations 13B and 15B we obtain Thus we have an expression for the error values The above expression for error values is well known. We will reduce it further to obtain a more convenient form. To this end, we prove the following Lemmas 1, 2 and 3. In Lemma 1, we obtain a relation which expresses the coefficients σ Comparing the coefficients of each term in the polynomials on the two sides of equation 19B we have Using Equation 20B, we can substitute for σ On eliminating the cancelling terms from Equation 21B we get This completes the proof of Lemma 1. Next we rewrite the denominator of the expression in Equation 17B using the result of Lemma 1. Interchanging the order of summing parameters m and k, we get Using Equation 4B, we can rewrite Equation 25B as This completes the proof of Lemma 2. Now we use the result of Lemma 1 and obtain a more convenient expression for the numerator in Equation 17B in the following Lemma. Let RHS denote the right hand side of Equation 28B In order to prove the Lemma, we rearrange RHS. First, we use the result from Equation 4B and rewrite some of the terms in RHS the terms with m µ as Then, substituting k by m h in the above RHS becomes Interchanging the order of summing parameters m and h, we obtain another form for RHS as Substituting m by k h, the expression RHS becomes However, from Equation 5B we have Thus using Equation 33B in 32B we have the final form for RHS This completes the proof of Lemma 3. We also have the following corollary of Lemma 3 from Equation 32B where 0 µ t and the coefficients Lemma 3 and its corollary provides a family of expressions for the numerator in Equation 17B through a choice of values for µ . We make the following observations In view of the above observations, we will use expression in the corollary of Lemma 3 in decoder implementation. For large values of t, it is advisable to use µ Now we can rewrite Equation 17B using the results of Lemma 2 and the corollary of Lemma 3 with µ 0. As a result, any error value E where In view of Equation 9B, the above expressions can be normalized to obtain error values in terms of Δ where In case of binary base field, the terms with even values of m, m mod 2 0 in the denomination of Equation 39B vanish. The resultant expression for E where Note that the computations for the denominator in Equation 41B is already available as a byproduct from the computations of Equation 11B for each value of i in the Chien Search of error locations. The numerator for each value of i can be computed and multiplied by the inverse of the denominator in synchronism with the search for error locations. The resultant E Table 2 which follows lists 255 non zero elements of GF 2⁸ , each with the corresponding inverse element. A primitive polynomial