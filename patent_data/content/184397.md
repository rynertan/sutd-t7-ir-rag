# REAL TIME SOFTWARE MONITOR AND WRITE PROTECT CONTROLLER

## Claims
Echtzeiteinrichtung für Software Überwachung und Schreibschutz,

## Description
This invention pertains to apparatus for independently verifying the proper execution of computer programs and the protection of memory stored data to effect isolation of multiple softwares executed on a single central processor. Most safety critical applications, such as aircraft flight control systems, have been implemented in analogue hardware to avoid potential hazards that could result from faulty software execution. Unlike functions implemented in analogue hardware, software functions are effectively time shared with other software functions executed on the same computer. Accordingly, individual software functions are difficult to isolate. Various techniques have been used to help verify proper execution of software. Monitoring of software execution and protection of data has been traditionally accomplished in the software itself. Examples of the software associated monitoring are the heartbeat monitor and the software ticket check. In the heartbeat monitor, the software outputs a pulse at regular intervals to verify real time operation. Traditionally, software is divided into small functional blocks of executable code called software modules. Each software module can be categorised as critical, essential or non critical in accordance with definitions contained in Radio Technical Commission for Aeronautics DO 178. When a software package containing modules that fall into more than one of these software categories is executed by a common processor, some method of isolation is required to provide clear and distinct partitioning of the software criticality categories. Otherwise, the criticality of all the modules within the package default to that of the most critical of the group relative to documentation, testing, and verification requirements. In order fully to isolate software of different criticality levels, two basic problems must be solved. Thus, a substantive problem in implementing flight safety functions in software is verifying that critical software modules, in a multi criticality software package, are fully executed in the proper sequence with uncontaminated data. The present invention is defined in the appended claims and provides apparatus for independently verifying the proper execution of computer programs and for protecting selected areas of memory from inadvertent alteration such that there is positive isolation and protection of data for multiple programs executing in a single central processor. An independent software monitor accepts a sequence of data keys from software executing in a central processor. The sequence of data keys generate addresses to a read only memory which outputs a plurality of legitimate codes to be compared with selected portions of the input data keys in order to verify the validity of the input data key and hence the proper operation of software executing in a central processor. Additionally, selected areas of memory are isolated by a write protect signal thereby precluding inadvertent alteration of critical data. The real time software monitor and write protect controller of the present invention thus verifies software execution in an independent manner. It isolates and protects critical data from software of lower criticality levels, thereby allowing separation of software within a single processing system into the three levels of criticality as described in Radio Technical Commission for Aeronautics RTCA document DO 178. The present invention verifies that the software executes in the proper sequence and that the entire software task is completed within a specified time. A real time software monitor and write protect apparatus in accordance with the present invention will now be described in greater detail, by way of example, with reference to the accompanying drawings, in which As shown in Figure 1, the present invention consists of a software monitor integrated circuit 10 and a software identify read only memory ROM 11. Each software module, upon entry and exit from the central processor CPU , not shown, writes a binary data key 1 to the software monitor integrated circuit 10. The software monitor 10 compares data key 1 against defined legitimate code sequences including branching stored in the ROM 11. Each time a legitimate data key 1 is written into the software monitor 10 it transitions to a new state. The software monitor 10 and the ROM 11 therefore form a state machine. Thus, the software monitor 10 verifies that the data key 1 is correct and is in the proper sequence. If a data key 1 is entered out of sequence, a software failure is annunciated on a lead 50. A write protect control 4, corresponding to the current executing module, is issued to the system scratch pad memory, not shown, to protect critical data from inadvertent alteration. Legitimate sequences of data keys 1 can include branching. Since multiple legitimate sequences of data keys 1 may be optionally defined, the software monitor integrated circuit 10 has a mode input 8. If more than one legitimate sequence has been defined, the mode input 8 determines which sequences are legitimate. For example, in a flight control system application, cruise sequences are excluded from the legitimate sequence set during the landing mode. In most applications there may be several independent software tasks to be executed, each with a different repetition rate. In the present invention, an individual software task may be temporarily suspended and another task resumed at the exact point at which it was last suspended. Each individual task is thus monitored by the software monitor 10 for completion at the defined repetition rate. Referring now to Figure 2, a more detailed description of the present invention will be provided. Figure 2 shows the software monitor integrated circuit 10 and the software identity read only memory ROM 11. At the beginning and end of execution of each software module in the central processor CPU again not shown a data key 1 is provided to the software monitor 10 as before but more specifically is provided simultaneously to conventional D type latches 21, 22, 23 and 34. Data key 1 contains key code 3, branch code 7 and write protect code 4. The key code 3 is a binary code typically containing 8 bits which uniquely identifies the key code, and the branch code 7 is a binary code typically containing 2 bits specifying the branch in program control that is to be executed. The write protect code 4 consisting typically of 4 bits specifies which areas of scratch pad memory may be accessed by the CPU. Memory write protection remains in effect until changed by receipt of a subsequent data key 1. The data key 1 is strobed into the latches 21, 22 and 23 when a write pulse signal 2 is present and is strobed into the latch 34 when a control pulse 32 is present. The branch code 7 is outputed from the latch 21 to a logical AND circuit 41 upon input of data key 1 and write pulse 2. The branch code 7 defines which program flow branch is associated with a given data key 1. A mode signal 8 is also inputed to the AND circuit 41 which acts optionally to prohibit selected branching and outputs a branch control signal 9. The branch control signal 9 and an old key code signal 19 form the address of the software identity ROM 11. An old key code 19 corresponding to the immediately preceding key code 3 is outputed from, the latch 24 to software identity ROM 11 upon input of key code 3 and a delayed write pulse 25a. A legitimate key code 5 and a legitimate write control code 6 are outputs of software identity ROM 11 as defined by branch control 9 and old key code 19 address. Immediately upon data key 1 being written into the software monitor 10, key code 3 is ouputed from the latch 22 to a comparator 12, and the write protect code 4 is outputed from the latch 23 to the comparator 12. The software identity ROM 11 outputs the legitimate key code 5 and the legitimate write control code 6 to the comparator 12. The key code 3 and the write protect control code 4 are compared in the comparator 12 with the legitimate key 5 and the legitimate write protect code 6. If the comparison is not valid, the latch 13 is set by an output from the comparator 12 on a lead 12a which provides an input to an OR gate 26, indicating a fault. The clock input to the latch 13 is the delayed write pulse 25a. The length of the delay 25, which receives its input from the write pulse 2, is typically several nanoseconds and must be long enough to accommodate the internal integrated circuit delays associated with the comparator 12. If the latch 13 is set indicating an invalid comparison of the inputs to the comparator 12, it remains set until cleared by a system reset, not shown. In addition to monitoring all data keys 1 written to it as discussed above, the software monitor 10 must confirm that a defined sequence of data keys 1 was received within the allotted interval of time. When a last key detector 18 indicates, by an ouput to an AND gate 27, that the last key code 3 has been received and the comparator 12 confirms that data keys 1 are in the proper sequence, a latch 14 is set, by an output from the comparator 12 on the lead 12a providing an input to the AND gate 27, indicating that the last valid key code 3 of a sequence has been received. The time period allocated for software task completion is monitored by a task timer 15 which receives a time base input 15a from the CPU. If, when the task timer 15 outputs an end of task signal 16, the latch 14 has not been set, then a latch 17 is set, via an AND gate 28 and an OR gate 29, indicating a fault. The above description applies to the monitoring of a single sequence of data keys 1 corresponding to a single task. Monitoring multiple tasks, each with a different repetition rate, may be accomplished by the present invention by switching between tasks. Data key 1 is written to the software monitor 10 via a control pulse 32 which strobes data into the latch 34 which outputs a control code 34a to a control code detector 36. If the control code 34a is invalid, a latch 38 is set via an OR gate 37, whose output is strobed into the latch 38 by the output from a delay 35, and an invalid signal 39 is outputed to an OR gate 40. The latch 34 also outputs a task select code 34b which in a multiple task environment becomes part of the address to the software identity ROM 11 and is an input to a task select decoder 44. Since the latch 23, the latch 24 and the task timer 15 must be dedicated to a single task, multiples of latch 23, latch 24 and task timer 15 are provided but are not shown in Figure 2. The task select decoder 44 enables one of The present invention, therefore, is a central processor independent apparatus that monitors software execution and protects data. Improper software execution is thus immediately detected and reported with a high degree of reliability and confidence.