# APPARATUS FOR INTERFACING BETWEEN AT LEAST ONE CHANNEL AND AT LEAST ONE BUS

## Claims
Schnittstellenvorrichtung für ein Mehrkanal 308 314 Mehrasynchronbus 300 306 System zur Kopplung zwischen wenigstens einem oder einem unter den asynchronen Bussen auswählbaren asynchronen Bus und einem wählbaren von Kanälen oder wenigstens einem Kanal, wobei jeder Bus ein identisches Protokoll hat, das eine Kommunikation zwischen einem Bus und nur einem Kanal gleichzeitig gestattet, wobei das Protokoll weiter legale und illegale Nachrichtensignalkennwerte festlegt, die in jedem Kanal gespeichert sind, wobei die Signale als Wörter aus einer bestimmten Anzahl von Bits in Nachrichten formatiert sind, die eine bestimmte maximale Zahl von Wörtern haben, wobei jedes Kanalteil der Schnittstellenvorrichtung aufweist

## Description
The invention described herein may employ some of the teachings disclosed and claimed in commonly owned copending applications filed on even date herewith by UNITED TECHNOLOGIES CORPORATION, entitled COHERENT INTERFACE WITH WRAPAROUND RECEIVE MEMORY, EP A 0188 990 , and COHERENT INTERFACE WITH WRAPAROUND RECEIVE AND TRANSMIT MEMORIES, EP A 0185 609 , respectively. The invention relates to a multichannel and multibus interface that guarantees the coherency of data transfers between at least one asynchronous bus and at least one channel interfaced thereto. In a system having a plurality of subsystems which are functionally integrated via an asynchronously operating bus, a need for data coherency arises. In such a system a bus controller normally communicates with up to a certain number of remote terminal interfaces which individually interface the bus with a related subsystem. For example, in a MIL STD 1553 context, the bus controller can communicate with up to 31 remote terminal interfaces. All of the remote terminal interfaces RTI s are capable of communicating with one other at the behest of the bus controller. There is a potential problem in such a system of the subsystems CPUs obtaining incoherent data blocks or messages. A coherent message is one in which the data or parameters refer to a unique computation performed on a unique data set and belonging to a unique time frame. Incoherency involves the transmission and or use of partial, i.e., incoherent messages made up of data belonging to different time frames, computations, or data sets. For example, an RTI can receive a message consisting of many words from the bus, can store that message, and can begin to overwrite or update the stored information while the host CPU is still in the process of reading the previously written message. In other words, the RTI is updated in midstream with new information before the old information can be transferred completely to the CPU. Thus, the CPU can receive, for example, the first half of the message from one time frame while the second half of the message is from a different time frame. If the bus is used for interfacing with critical avionics subsystems, where highly accurate and coherent information is critical, such incoherency can have disastrous consequences. One of the prior art methods of attacking this problem is to create a double buffering type situation in which the messages received are alternately placed in one of two memory buffers. While a first message is occupying the first memory buffer a second message can be received in the second memory buffer. Thus a small amount of time is sacrificed for ensuring coherency. However, if a burst of information is transmitted on the asynchronous bus to the particular RTI, the double buffering solution may not be successful in retaining all the transmitted information. If the CPU can respond in a timely manner, this method can ensure coherency. However, in the majority of high performance subsystems communicating with a bus, the CPU is quite busy performing other tasks and cannot respond to a burst of messages or block transmissions using the same message label. Thus, some data will be lost if the transfer rate is greater than the rate of acceptance capabilities of the double buffering architecture. Of course, it is conceivable that a system designer could set up a triple, quadruple, quintuple, or any number of buffering architectures. However, this would be extremely expensive because of a the necessity of designing each buffer in such a way that it can accept a full block there are 32 words in MIL STD 1553B block thus ensuring considerable waste of memory for messages containing less than the full number of words for a block b the need for updating, in a rapid and orderly manner, the addresses of the last tenants of the first buffer each time a new message is received into the first buffer c the buffering type solution requires a great deal of hardware and CPU throughput and, d the need for interrupting the CPU everytime new information is shifted into the last available buffer. A second level of coherency problems exists in the prior art. Each data word within a message belongs to a unique time frame. However, if two or more messages are received by the RTI at different times but are buffered and read out by the host CPU at the same time, the problem of time consistency between such critical messages arises. Both of the above described first and second levels of coherency problems have been addressed in said commonly owned copending applications entitled COHERENT INTERFACE WITH WRAPAROUND RECEIVE MEMORY and COHERENT INTERFACE WITH WRAPAROUND RECEIVE AND TRANSMIT MEMORIES. A third level of coherency problems exists in the prior art. It is the problem of efficiently transferring data between one or more simplex busses such as MIL STD 1553 and one or more subsystems, typically a set of redundant synchronous subsystems. In general, a simplex bus can communicate with only one channel at any given time. Under MIL STD 1553, each subsystem is provided a unique terminal address on the bus. The electrical and operational characteristics of this interface do not permit a variable number of redundant channels to receive and transmit data to and from the bus using the same RTI address. Therefore, in a redundant subsystem with one RTI with one RTI address the bus can be connected to one and only one redundant channel at any time and the data must be internally distributed and coherently used by the other redundant channels. This requires that the channel receiving the bus messages must transmit the data to all redundant channels in an efficient manner over interchannel links. These links are generally used for other data as well and as such the bandwidths of these links is usually limited. Thus an inexpensive and simple means of ensuring data coherency and time consistency for redundant synchronous subsystems is desirable. The object of the present invention is to provide a multichannel interface to a redundant system which ensures data coherency and time consistency with minimum hardware and minimizes the host subsystem software penalties associated with the distribution of data from one or more busses to redundant channels. This object is achieved by the interface apperatus described in claim 1. Embodiments thereof are described in the dependent claims. According to the present invention, blocks of messages received from a single bus by a single channel and which have been stored in memory locations associated with that channel are synchronously transmitted in a packed format having an end of data statement attached thereto over interchannel links to redundant channels or subsystems. In further accord with the present invention, each message block is time tagged with a time tag word before being packed for transmission over the interchannel links. In still further accord with the present invention, each channel is capable of communicating with one or more asynchronous busses and each channel may be disconnected or severed from any other busses in response to a detected fault. In still further accord with the present invention, received data coherency of the data transmitted is assured in the receiving channel by the management and absorbtion of each individual block received over an asynchronous bus on a block by block basis in a wraparound memory. This technique avoids many of the inefficiencies associated with buffering architectures used in the prior art and also FIFO architectures which have similar access inefficiencies. Time consistency between received message blocks is achieved by time tagging the received blocks. Coherency and consistency of received message blocks synchronously transmitted between the redundant channels is thereby ensured. Of course, the management and absorbtion task could be accomplished wholly by software techniques and the wraparound memory would then be unnecessary. Data coherency and time consistency of the incoming messages from the asynchronous bus is achieved in the receiving channel by using a memory buffer for storing received message blocks. The buffer has much larger memory capacity than anything that could conceivably be effectively utilized by the host CPU during a sequence of received message blocks. The incoming message words are stored sequentially into the next available memory location in a stack of memory locations organized as a circular buffer . As subsequent message words are received, they are written or packed sequentially regardless of subaddress without wasting any spaces. Each time a message block is completely written into the stack, a stop pointer is set to the memory address in the stack that was filled by the last data word in the message block. The host CPU is algorithmically unaware of any incompletely stored message blocks beyond the stop pointer. The RTI receives message blocks in sequence and writes these blocks into the stack in sequence until the memory is completely filled up. At that point, the RTI will wraparound to the beginning of the memory again, overriding the very first message block written into the stack. But by this time, the host CPU will already have accessed the overwritten data. In parallel with this activity, the host CPU is permitted to read out any number of correctly received messages starting with the first message indicated by a start pointer and ending with any block up to the RTI controlled stop pointer. Each stored message remains in the same location until it is overwritten. Receive message coherency is thus achieved due to the dynamic separation of the message write area for the RTI from the read area for the CPU, regardless of the message subaddress. Coherency of transmit data is assured within the transmitting channel by using a memory buffer for storing message blocks for transmission in predefined message block areas. The host CPU is allowed to read the RTI status register to determine if the RTI is busy transferring data and if so, to determine the subaddress of the transmit address block. The host CPU will reschedule the transfer of the data to the RTI if a conflict is indicated. A semaphore flag is set when the CPU reads this status which inhibits data reads by the RTI. The semaphore flag is cleared when the CPU writes the first data word to the transmit RAM. The CPU then continues through the block, easily staying ahead of the RTI, which reads at only 20 microseconds per word. This technique eliminates the need for use of the MIL STD 1553 busy bit which can have a devestating effect on bus throughput. Alternatively, each message block is organized in wraparound fashion, except that each block is a smaller version of the receive memory buffer. The present invention may be used to permit efficient and coherent communication between one or more asynchronous busses and any number of channels when the bus is only permitted to communicate with one channel at a time. These and other objects, features, and advantages of the present invention will become more apparent in light of the detailed description of a best mode embodiment thereof, as illustrated in the accompanying drawings. Referring to Fig. 1, a functional block diagram of a generic MIL STD 1553 remote terminal interface 10 RTI is shown. The generic RTI 10 is shown interfacing with a bus interface unit 12 and a host CPU 14. It should be understood that the bus interface unit could be incorporated into the generic RTI 10 rather than being provided separately. The bus interface unit 12 interfaces with a pair of dual redundant MIL STD 1553 busses, designated as bus A 16 and bus B 18. The bus interface unit 12 includes transformer A 20 and transceiver A 22 which together serve the function of interfacing the RTI s digital logic with the data bus. The coupling transformer 20 may include fault isolation resistors where required for a connection to the data bus. The transceiver 22 includes a receiver which provides low level noise rejection and a digital output compatible with the digital logic. The transceiver 22 also includes a transmitter which drives the bi phase modulated signal to form data word formats defined in the military standard. Both the transformer and the transceiver portions are widely available packaged either separately or together. The bus interface unit 12 also includes a transformer B 24 and a transceiver B 26 which serve the same functions for bus B 18 as transformer A 20 and transceiver A 22 do for bus A 16. Dual redundant bus interface units 12 are also commercially available. Although the RTI is shown in Fig. 1 in the context of a dual redundant MIL STD 1553 bus, it should be understood that the present invention can be practiced in the context of any asynchronous bus system, single, double, and so on. The generic RTI 10 includes a remote terminal interface RTI gate array 28, a data receive RAM 30, a data transmit RAM 32, a mapping RAM 34, a time tag counter 36, a terminal controller TC gate array 38, an I O section 40, a clock 42, and I O and control buses 44. It should be understood that the RTI gate array 28 and the TC gate array 38, while shown separately, could as easily be incorporated into a single gate array. Similarly, many of the other constituent blocks shown in the generic RTI 10 of Fig. 1 can be provided separately or included into the generic RTI 10 of Fig. 1. The RTI gate array 28 may be implemented as a CMOS device. As disclosed in co pending application USSN 635,944 entitled DUAL REDUNDANT BUS INTERFACE CIRCUIT ARCHITECTURE, invented by G. Howland, assigned to the assignee of this application, and hereby expressly incorporated by reference, the RTI gate array 28, as contemplated herein, handles the complete MIL STD 1553 protocol and requires no CPU intervention for normal transfers of blocks between the operative bus and the host CPU. Key features of the 1553 RTI gate array as disclosed in the Howland specification include The 2K word data RAM is partitioned into a 1K word receive data RAM 30 and a 1K word transmit data RAM 32. The RTI gate array 28 deposits command words, mode words, and data words into the receive data RAM in blocks, and retrieves deposited blocks from the transmit RAM 32 for transmission on the active bus. The receive data RAM 30 is organized as a wraparound RAM memory by means of control signals from the TC gate array 38. This wraparound organization, shown in Fig. 2, consists of blocks in the sequence in which they are received. As each message is received by the RTI gate array 28, it is packed and time tagged by the TC gate array 38. There are no intermessage spaces for messages, even for messages of less than 32 word length. The organization of the transmit data RAM, on the other hand, follows the standard 1553B block format with 32 blocks of 32 words each in fixed locations for transmission by the RTI gate array 28. The mapping RAM 34 of Fig. 1 is initialized by the host CPU 14 and is used by the RTI gate array 28 and the TC gate array 38 to validate incoming transmissions and determine the appropriate response e.g., interrupts to the host CPU 14 or the bus controller not shown . The time tag counter 36 is a free running time counter which is cleared or preset by the TC gate array 38 on receipt of the synchronize mode codes from the bus controller. The time counter is used by the TC gate array 38 to time tag all incoming blocks. The TC gate array 38 is the central element of the generic RTI interface 10. The functions of the TC gate array 38 are as follows The TC gate array 38, in concert with the RTI gate array 28, produces all the necessary signals to mechanize the above functions as described in further detail below. To ensure data coherency, the TC gate array 38 provides logic that tests incoming blocks. The consistency of incoming blocks is readily determined and the host CPU is denied access to incompletely received message blocks. For out going data destined for the active bus, the TC gate array 38 arbitrates access to the transmit data RAM 32 between the RTI gate array 28 and the host CPU 14. The RTI gate array 28 has higher priority in accessing the transmit data RAM 32 than the CPU 14. Outgoing coherency is guaranteed by means of a block write disable signal generated by the TC gate array not shown and by initially algorithmically denying RTI read access to a block being written into. The TC gate array 38 provides the control signals and high speed processing capabilities of a state machine necessary to pack and time tag incoming blocks in real time. The formating of complete received blocks and the use of wraparound memory achieves the following important benefits The TC gate array 38 provides the necessary signals and I O port decodes for interfacing with the host CPU 14 with a minimum amount of software. The TC gate array 38 also generates the addresses of words within each block to minimize CPU 14 real time requirements. The TC gate array 38 responds to all MIL STD 1553B mode codes without CPU 14 intervention except for the following two mode codes for which CPU actions are essential The operation of the MIL STD 1553 remote terminal interface gate array 28 involves the participation of the interface hardware elements, as well as the host CPU. The functional features of the various elements involved were described above. Simple and efficient software algorithms and procedures can be developed in the host CPU for the acquisition, transmission, and absorption of the active bus data, and for the management of the 1553 RTI. The tasks performed by the 1553 RTI consists of the following operations Reception and processing of data transmissions by the RTI gate array 28 involves the following sequence of operations an equivalent flowchart description is shown in Fig. 3 Referring back to Fig. 2, an illustration of the memory organization of the data received RAM 30 is shown. Arbitrarily assuming a 1K memory, the memory addresses 50 are shown in a column adjacent to the wraparound data received memory 30. Each memory address is designated in digital format, i.e., 0 through 1023. The memory 30 has a great many more memory address locations for storing words than could possibly be usefully needed at any one time, i.e., worst case storage of over 20 milliseconds. Only a small portion of the total memory is illustrated in Fig. 2. The part of the memory 30 being actively used at the time illustrated in Fig. 2 is indicated by a bracket 52 indicating that words deposited in memory address locations 4 thru 27 are available for CPU usage. The host CPU can determine this by examining a start pointer 54 and a stop pointer 56 which point respectively to the beginning and end of the available message blocks. Only those blocks 57 which have not yet been read, and which have been completely written are made available for CPU usage. The command word format is illustrated in Fig. 4. Each RT in the 1553 system is assigned a unique 5 bit address for which it is responsible to respond when the address is transmitted as part of a command word on the data bus by the bus controller. The next bit indicates the action required of the RT, i.e., transmit T or receive R . The next 5 bits indicate either the subaddress identification of specific message blocks or an indication that a mode command is being transmitted. The next five bits indicate the quantity of data words to be sent out or received by the RT or an optional mode code. Referring back to Fig. 2, the next block being filled is indicated by a bracket 58 and includes, at the instant of time illustrated, the memory location addresses 28 thru 30. A next word pointer 60 is used by the TC gate array 38 of Fig. 1 to determine where to write the next word in the block. In this case, the next word will be written in memory location address number 31 which contains an old or stale piece of information that was formerly contained in a block already read by the host CPU as indicated by a bracket 62. The TC gate array 38 will continue to write blocks into the next available section of memory according to the next work pointer 60 and the host CPU 14 will continue to read these blocks either singly or in groups at its convenience. The TC gate array 38 will thus always stay slightly ahead of the host CPU and will always complete the writing of a block, thus ensuring its coherency, before it is read by the host CPU. In this way the memory is written in wraparound fashion as indicated by an arrow 64 until the physical limitations of the memory are exhausted as indicated by an arrow 66. At this point the 1K capacity of the memory is about to be exhausted. After writing into the memory location at address 1,023 the next word pointer 60 simply jumps to memory address number 0 again. And the block being written wraps around the physical boundaries of the 1K memory. Since the memory capacity is much larger than could ever be contemplated for use at any one time, there is never any coherency problem. Thus a circular , wraparound , stack , or pseudo FIFO type of memory which is much larger than anything that could be conceivably utilized at any one time is used to ensure message coherency on a block by block basis. By writing blocks sequentially in a packed format and leaving each word in its original location, very efficient access techniques are made available for use. Thus, the old techniques of double, triple, etc. buffering or FIFO type memory storage, where messages ripple through the stack, are avoided. Thus, data coherency is ensured in a very stable manner which ensures access with minimum hardware and software requirements. The CPU is able to unload one or more blocks and sort out the blocks according to their command words. The second level of coherency problems that exist due to the reception of data from two different subsystems in a group of received messages is solved by time tagging each message. Thus the CPU is able to determine precisely when each was received. Thus, if a flight control computer sends an airspeed signal at time t t₁ and a gyro computer sends pitch, roll, and yaw signals at time t t₂, both of these signals will be loaded into the stack and time tagged so that the CPU will be able to distinguish them time wise and not utilize them as if they were all generated at the same time. Since they are time tagged, a potentially disatrous time skew problem concerning the time frame in which a data word is received, can be avoided or corrected for. The CPU compares the different reception times of any two received messages, and then, using other information available to it concerning the interrelation of parameters and time, it interpolates or extrapolates the time skewed pieces of data for improved performance and integrity. The transmission of host CPU 14 deposited blocks to the active bus 16, or 18 involves the following steps an equivalent flowchart description is shown in Fig. 5 The initialization of the 1553 RTI gate array 28 is under the control of the host CPU 14 and involves one or more of the following individual tasks Self test of the RTI gate array 28 is performed under CPU control when commanded by the bus controller. This task is based on the internal wraparound BIT built in test capability of the RTI gate array and testing of the fail safe capability of the interface. The latter test involves exercising the transmitter hardware in the TC gate array. Fig. 6 illustrates the organization of the 1K transmit data RAM 32 of Fig. 1. As is shown in Fig. 6, there are 30 message blocks of up to 32 words each. The message blocks spaces are permanently reserved. In other words, memory address locations 1,056 through 1,087 will always contain a single message designated as message block 1 in Fig. 6. Similarly, the remaining transmit memory space contains 29 fixed message blocks spaces each containing up to 32 words. Each word is 16 bits wide. As described above, coherency is ensured by rescheduling host CPU block write actions if a message block is being read by the RTI and briefly locking the RTI out of the transmit RAM if the host CPU is writing into the block to be accessed until the host writes at least one word into the block, i.e., the RTI will briefly be kept waiting until the host CPU finishes writing a word into the message block and will then be allowed read access. Fig. 7 is an illustration of a gate array 300 incorporating both the RTI and TC functions. The gate array physical orientation and major connections are shown. It should be understood that the orientation shown is merely one of a great variety of orientations that could be chosen. It should also be understood that the devices and major connections made through the gate array are not all necessarily required in carrying out the inventive concepts disclosed herein. Nor should the invention be limited by the physical limitations of the individual devices. Fig. 7 illustrates an 800 microsecond timer 302 connected to the gate array 300 on three lines 303, a MAP PROM 304 connected to the gate array 300 by fourteen lines 305, an address bus 306 connected to the gate array by fifteen lines 307, a data RAM 308, a parity check section 310, and a data bus 312 all three connected by sixteen common lines 314 to the gate array 300, a write gate 316 connected by three lines 318 to the gate array 300 and, transceivers 320 connected by eight lines 322 to the gate array 300. The 800 microsecond timer 302 serves the function of protecting the bus from a rogue RTI which continues to send signals on the bus after its maximum allotted time has expired. Given that the longest transmission cannot last for more than 800 micro sec per MIL STD 1553, this time limit was chosen. The timer is started each time the bus talks to the RTI and permits the RTI to talk on the bus for a maximum of 800 micro sec after which the transceivers 320 are disabled. Thus, the timer 302 limits the maximum transmission time on the bus to 800 micro sec. The MAP PROM 304 serves the same function as the mapping RAM 34 of Fig. 1. Either a RAM or ROM may be used to accomplish this function. In an application where the host processor may wish to redefine a message during operation as legal or illegal, valid to receive or not valid, valid to interrupt or not valid, and valid to time tag or not, then a RAM with its associated host processor access path should be used. In a more typical system that does not require redefinition of these parameters during operation, the simpler PROM implementation may be used. The address bus 306 serves the function of sharing the data RAM s address between the RTI and TC array and the host processor, and also decoding the host processor address to provide it access to the internal registers of the RTI and TC array. The data RAM 308 serves a function similar to the data receive RAM 30 and the data transmit RAM 32 of Fig. 1. The parity check section 310 is provided to generate and store the parity bit associated with each word in the data RAM during a data RAM write. Parity is again generated during a data RAM read and compared to that stored during the write of that same word. A disagreement between these two indicates a RAM fault and is flagged to the host processor as such. Parity check is a reliability fault detection enhancement without which the interface will function but with lower reliability. The data bus 312 serves the function of providing a data transmission path between the gate array 300 and a host CPU interfaced thereto and also between each of these devices and the data RAM 308. The write gate 316 is provided to synchronize the RTI and TC gate array accesses to the data RAM to those of the host processor, thus providing a transparent DMA mode of operation. This makes the shared data RAM function effectively like a dual ported RAM. The transceivers 320 perform a similar function as the transceivers 22, 26 of Fig. 1. Fig. 8 is a simplified functional block diagram illustration of she control and data sections of the RTI and TC gate array 300 of Fig. 7. Each of the blocks illustrated in Fig. 8 illustrate in general form the hardware which may be incorporated in the gate array 300. The majority of the functions disclosed in Fig. 8 have already been disclosed in the copending Howland application previously incorporated by reference. The changes that have been made are changes which enlarge the capabilities of the Howland RTI by incorporating a TC which helps to ensure the data coherency which is the chief object of the present invention. Fig. 8 is divided by a dotted line 330 which separates the functional blocks into an upper control section and a lower data section. The upper control section illustrates six functional blocks which contain control logic having overall control of the flow of data illustrated in the lower data section of Fig. 8. A CPU access section 332 contains logic which allows the CPU to communicate with the gate array. This logic decodes the appropriate input signal indicative of the CPU s intentions , i.e., addresses, read write, chip select and internal selects 1 and 2 and allows the CPU to access registers internal to the RTI and TC gate array such as time tag, control and stop pointer registers. A state machine section 334 includes the top most control logic which ties the operation of the generic interface together. It is similar in function to the state machine disclosed by Gary Howland in the above referred to DUAL REDUNDANT BUS INTERFACE CIRCUIT ARCHITECTURE disclosure. The state machine interprets the action that must take place, i.e., write command word, write data word, read data word, write time tag, etc., and creates the necessary control signals required for that action to occur. A shutdown logic section 336 is provided to detect shutdown commands from the bus and to take appropriate action. Whenever a shutdown command is detected, the transmitter associated with the opposite half of the dual redundant 1553 bus is disabled per the military specification. A DMA section 338 arbitrates bus level access to the local RAM between the host CPU and the RTI utilizing the synchronization signals provided by the external write gate circuit. The DMA section arbitrates access to the data RAM s address and data lines creating what appears to both users as a dual part RAM. An error logic section 340 is included to detect errors in the 1553 serial stream. All of the checks required by MIL STD 1553 are performed. These include word parity, contiguous data, gap times, word counts, invalid modes, synch patterns, etc. A mode decode section 342 is provided to recognize mode commands which are capable of execution in the particular embodiment. All 1553 defined mode codes are decoded and implemented within the gate array except Reset Remote Terminal and Perform Self Test which must be passed on to the CPU for execution. The data section of Fig. 8, below the dotted line 330, includes a conceptual presentation of the flow of data within the gate array 300 of Fig. 7, according to the present invention. A front end section 344 includes level translation, a debouncing section, and also provides a test path similar to the self test aspect disclosed in the Howland disclosure previously incorporated by reference. The front end section 344 receives Manchester encoded data on lines 322 and also provides Manchester coded output. After level translation, debouncing and other appropriate tests, the bi phase signals are transmitted on lines 348 to a decoder section 350 which decodes the incoming Manchester signal. The decoders may be dual decoders in a dual redundant implementation. The decoded signals are transmitted on lines 352 to a command shift and multiplexer section 354. The shift section changes the incoming serial data to parallel form and the multiplexer section is used in dual redundant implementations to select the proper incoming channel. The multiplexed parallel command word is transmitted on lines 356 to a command latch section 358 where it is latched for later transmission. The latched command word is transmitted on lines 360 to an address out section 362 which provides an address on lines 307 to the address bus 306 of Fig. 7. The address out section 362 is a multiplexer which selects between the command latch 358 and a load pointer provided by a load stop section 364. When the interface is transmitting data the data is formatted in the data RAM 308 see Fig. 7 such that the address to the RAM is the lowest eleven bits of the command word which has been stored in the command latch refer to Fig. 4 . The lowest five bits of the command latch are a counter which decrements by one for each word transmitted thus producing the data format of Fig. 6. When the interface is receiving data the RAM is addressed by the load pointer on lines 366 and 307 thus producing the receive data format of Fig. 2. Also provided by the load stop section 364 is a stop pointer, or next word pointer 60 of Fig. 2. After a block is received and has passed all validity checks, the load pointer is copied into the stop pointer thus including the new block into the CPU s valid data area 57 see Fig. 2 . If at any time, an error is detected, the stop pointer is copied into the load pointer which effectively backs up the load pointer and eliminates the invalid data from the CPU s accessible area. It is not necessary to actually erase the invalid data from the RAM. It is in fact written over by the next incoming block and the CPU never sees the invalid data. All command words on the 1553 bus regardless of destination, are shifted into the command shift register 354. It is from here that an address comparison is made by RT M recognition logic 368. This is simply a comparison of the command word s five most significant bits refer to Fig. 4 to addresses which the CPU has written into the RT M recognition logic over lines 370. If an address matches with the RT address the interface responds as a remote terminal. If an address matches with a monitor address, the interface receives data but does not respond on the 1553 bus. Thus, it will behave as a bus monitor per the military specification. If no match at all is made the interface does nothing. The CPU may also program a monitor all in which case the interface will receive any and all bus data without regard to address. A control register 372 is provided within the gate array which allows the CPU to perform such functions as reset, enable channel A and or B, enable self test, enable time tag, etc., by setting the appropriate control register bits. A new command logic section 380 responds to decoded command, status, and data words on lines 382 from the decoder section 350. Incoming serial data is transferred from the new command logic section 380 on lines 384 to an In Out Shift Register 386 where they are assembled in parallel form for transmission on lines 388 to a receive multiplexer latch 390. The receive multiplexer latch 390 is also responsive to latched command words received on lines 392 from the command latch 358. Thus, the receive multiplexer latch 390 receives both latched command words and data words in parallel form for transmission on lines 394 to a Data In Out section 396 which may be a bi directional tri state data bus interface for interfacing on lines 314 with the data bus 312, parity check section 310, and Data RAM 308 of Fig. 7. A Time Tag Synchronizer section 398 provides time tag words for each message block for transmission to the receive portion of the data RAM 308 of Fig. 7. The Time Tag Synchronizer has a 16 bit free running counter which is incremented every 64 microseconds. If the time tag is enabled, this 16 bit count is written into the data RAM in the position indicated in Fig. 2. It is, of course, necessary to sychronize the incrementing of the time tag to the write cycle so that a stable word is written. This is done by postponing the increment until the write is over. The time tag counter is also presetable and is loaded by the CPU from data lines 314 or upon receipt of a synchronize with work mode code from the 1553 bus from lines 394 . Or the time tag counter is cleared when the mode decode logic 342 recognizes a synchronize mode code from the 1553 bus. Thus, in the receive mode, message blocks having a command word followed by a time tag with a number of data words are transmitted on the lines 314 to the receive data RAM. In response to a transmit command from the interfaced bus the decoders 350, command shift and multiplexer 354, command latch 358, and address out section 362 will all function in a similar fashion to provide the proper command to the interfaced hardware. In this case, messages stored in the transmit section of the data RAM 308 see Fig. 7 are transmitted on lines 314 to the Data In Out Section 396 for transmittal on lines 410 to a transmit multiplexer latch 412. The transmit multiplexer latch 412 is also responsive to status words transmitted from a transmit multiplexer level 1 414 on lines 416. The transmit multiplexer level 1 414 receives status words on lines 418 and which are assembled from various sources within the gate array. A last command section 420 provides a last command signal on lines 422 to the transmit multiplexer level 1 414. The transmit mux level 1 414 multiplexes the contents of the last command section or the status word information into the transmit latch. This provides the data paths to support the transmit last command and transmit status mode codes of the military standard. Once a status word and the subsequent data words are received by the transmit multiplexer latch 412 they are provided on lines 424 to the in out shift register 386 for serial transmission on a line 426 to an encoder 428. The encoder provides Manchester bi phase signals on lines 430 for transmission to the front end 344. From the front end 344, the Manchester encoded signals are provided on lines 322 to the transceivers 320 of Fig. 7 for transmission on the associated asynchronous data bus. A more detailed representation of the signals which interconnect the various sections of the generic interface of Fig. 7 including the signals which interface with the host CPU are shown in Figs. 9 10. Some additional signals, not central to the inventive concepts presented herein, are also shown and will be described in some detail. Fig. 10 is provided to show the relationship between many of the functional blocks presented in Fig. 8 and an actual hardware implementation as shown in Figs. 9 10. The gate array 300 of Fig. 9 is illustrated in Fig. 10 in a manner which presents several of the functional blocks of Fig. 8 connected to the external signals of Fig. 9. Not shown in Fig. 10 are those blocks in Fig. 8 which are dedicated solely to gate array internal signal processing. In particular, the signals on lines 322 of both Figs. 7 8 which are connected to the transceivers 320 of Fig. 7 are shown in Figs. 9 10 connected to the front end 344 on pins 13 23 of the gate array 300. The address out section 362 of Fig. 8 is shown in Fig. 10 interfacing with address out lines on pins 60 72 of the gate array 300. The Data In Out Section 396 of Fig. 8 is shown in Fig. 10 as providing and receiving data on pins 33 50 of the gate array 300. Various other control and data sections illustrated in Fig. 8 are shown in Fig. 10. Although not shown in Fig. 8 as interfacing with any devices external to the gate array, it will be seen from Fig. 10 that these various other internal functional blocks illustrated in Fig. 8 do in fact interface with external devices as well as internally with each other. Thus, it will be seen that the mode decode section 342, the command latch section 358, the RT M recognition section 368, and the control register sections 372, all contribute external signals on lines 305 which are provided to the MAP PROM 304 of Figs. 7 9. The mode decode section 342 provides MC SA 0 4 and MC SA signals to the MAP PROM 304 for the purpose of identifying the individual mode code or subaddress being acted upon. This allows that MAP PROM 304 to properly classify each individual command. The control register 372 provides a PROM SEL 1 signal and a PROM SEL 2 signal to the MAP PROM section 304. The function of these signals is to allow the host CPU to reconfigure the MAP PROM to function in any of four different quadrants. The RT M recognition section 368 provides an RT M signal on pin 81 of the gate array which serves the function of identifying to the MAP PROM 304 whether the command being serviced was the result of a remote terminal address recognition or a monitor address recognition. Both the mode decode 342 and the DMA section 338 respond to a DO RCV signal received on pin 80 of the gate array from the MAP PROM 304 of Figs. 7 9. If the command has mapped such that DO RCV is active, the interface will write the command and data if applicable into RAM. If DO RCV is inactive the interface will not write the message to RAM. The gate array is also responsive at pin 79 to a DO INT signal which is provided internally to the gate array to the LOAD STOP section 364. DO INT instructs the gate array to interrupt the host CPU when the message has been processed and written into RAM. This allows for immediate servicing of high priority data. The gate array is responsive at pin 78 to a DO T T signal provided to the control register section 372. The function of this signal is to identify messages which require a time tag to be included when they are written to RAM. The gate array 300 is also responsive at pin 77 to an ILL CMD signal from the MAP PROM. The ILL CMD signal identifies commands which have been defined in the system as illegal. The interface will respond by setting the appropriate errors in its status word. The constitutes a bus error. The gate array 300 provides a DMA REQ signal at pin 74 from the DMA section 338. This signal is intended for use as a test signal and has no function in the operating system. An ILL OUT signal is provided as an output on pin 73 of the gate array from the mode decode section 342. This signal is provisional and may be used to either flag or interrupt the host CPU if the host CPU needs to know when a bus error has occurred. The CPU access section 332 is responsive at gate array pins 55 58 to four signals from the address bus and ultimately from the host CPU. A PA 1 and a PA 2 signal are provided at pins 55 and 56. These are from the host CPU address bus and allow the host CPU to access the various registers internal to the gate array. The INT SEL 1 and INT SEL 2 signals are provided at pins 57 and 58. A PARITY TEST signal is provided from the control register as a gate array output signal at pin 54 to the parity check section 310 of Figs. 7 9. The host CPU can set this signal in the control register. The host CPU may write the entire RAM and then read the entire RAM and verify that no parity errors have occurred. The host CPU may then change the parity test bit which goes into the parity generation verification circuit. If the host CPU then reads the RAM, it should find that parity fails at every word. This test would normally be done at power up. The CPU access section 332 provides three output signals at gate array pins 51 53. These include an RWR signal which is provided both to the parity check section 310 and the data RAM section 308 of Figs. 7 9. This is the write signal for the data RAM 308. An RRD signal is provided at pin 52 to the parity check 310 and data RAM 308 sections as well. This is the read signal for the data RAM. Additionally, an RCS signal is provided at pin 53 to both the parity check 310 and the data RAM 308. This is the chip select signal for the data RAM. The gate array 300 is responsive at pin 32 to a RESET signal from the host CPU. This signal is used throughout the gate array in many different sections to initialize the internal gate array memory elements. RESET is normally issued at power up. As may be seen from Fig. 9 the RESET signal is utilized by the write gate section 316, the gate array 300 and the parity check section 310. The write gate section 316 utilizes the reset for initialization at power up. The parity check section 310 also uses the reset signal for initialization at power up. A W R signal from the host CPU is provided to pin 31 of the gate array and is used in the CPU access section 332 to identify whether the CPU is performing a read or a write cycle. A CS signal from the host CPU is provided at pin 30 of the gate array and is routed to both the DMA section 338 and the CPU access section 332. The CS signal is used in the DMA section 338 to synchronize DMA cycles to the host CPU cycles for the purpose of performing DMA cycles that are transparent to the CPU. The CS signal is used in the CPU access section 332 to indicate that the CPU is accessing either the gate array or the data RAM. The gate array provides a MUX BUS INT signal at pin 29 from the load stop section 364. This signal interrupts the host CPU at the completion of the message processing if the message has been mapped to be a high priority message by the MAP PROM as indicated by the DO INT signal. A not 800 micro s OUT signal is provided on pin 28 from the 800 microsecond timer 302 of Fig. 7. The not 800 micro s OUT signal comes into the gate array where it can be read by the host CPU. The host CPU can trigger the 800 micro s timer 302 and then poll not 800 micro s OUT to verify that the timer is functional. This will normally be done at power up. Fig. 11 is a schematic block diagram of the interface between two 300, 302 dual redundant MIL STD 1553 mux busses 304a, 304b, 306a, 306b and four redundant Digital Flight Control Computers DFLCC channels 308, 310, 312, and 314. A host CPU 316, 318, 320, and 322, in each channel can be interfaced with either bus 300, 302 which may be an avionics bus, hereinafter referred to as Mux Bus A, or bus 302, which may be a Display Bus, hereinafter referred to as Mux Bus B. Alternately, the interface for a given channel can be turned off by the host CPU. In the configuration illustrated in Fig. 11, each Mux Bus is connected to only one channel to ensure that the electrical requirements of MIL STD 1553 are met. Data received in a given channel is transmitted to the other channels over separate synchronous links 324 thus eliminating the potential for common mode faults. The ability of the host CPU in a channel to independently select the interface configuration allows the DFLCC RT interface to provide full operational capability for the first two channel failures and a single, selectable Mux Bus interface capability in case of a third channel failure. The channel sever hardware shown in Fig. 11 provides failure protected operation of the Mux Busses regardless of DFLCC failures. The host CPU s receive data management tasks are pictured in sequential form in Fig. 12 a . The procedure consists of the acquisition and placement of 1553 messages into the host CPU Local RAM not shown from which they are transmitted, under Input Output Controller IOC control, to the other channels via the interchannel links 324 of Fig. 11, as shown in Fig. 12 b . In Fig. 12 a , the timing of data acquisition by the local RAM is shown on a time line 400 during a repetitive time frame 402. The time frame 402 is merely one frame of a sequence of similar time frames each of which may be marked by synchronizing pulses 404a, 404b. A 1553 message block is filled in local RAM during a time period from t t₁ to t t₂. Thus, the 1553 blocks in local RAM are filled by the host CPU at specific scheduled times. Additional blocks may be filled, for example, during an interval 408 between time t t₅ to t t₆. The filled up 1553 blocks are then transmitted to all channels over the interchannel links starting at specific times as determined by the input output controller IOC as shown in Fig. 12 b . In a best mode embodiment, the starting times of these transmissions are completely definable and modification requires only a PROM change. Similarily, the size and number of the blocks are defined by software and are also easily alterable. In Fig. 12 b , a timeline 409 for data transmission during the same time frame as shown on timeline 400 illustrates data transmission from the local RAM 450 to link RAM 530. A 1553 block 410 is transmitted from a time t t₃ to t t₄. Similarily, additional data may be transmitted during an interval 412 from t t₇ to t t₈. The organization of the local RAM 450 and link RAM 530 in each channel is schematically shown in Fig. 13. As shown in Fig. 13, the 1553 blocks in local RAM 450 are filled as indicated on a line 452 by the host CPU at specific scheduled times. Again, these 1553 blocks are then transmitted, as indicated by a line 454, to all channels over the interchannel links starting at specific times as determined by the IOC not shown . The procedure for filling a 1553 block in the host CPU local RAM is given in Fig. 14. It involves filling the allocated 1553 block in the local RAM with as many complete 1553 received message blocks as possible, including associated labels and time tags. First, after entrance to the illustrated subroutine in a step 500, the data block pointers are examined in a step 502. Then, a determination is made in a step 504 as to whether a new data block is indicated. If not, an exit is made in step 506. If so, the data block header label is read in a step 508 and a determination is made in a step 510 as to whether the block will fit into local RAM. If not, an EOD label is stored at the end of the block in the CPU s local RAM in a step 512 and an exit is made in the step 506. If the block will fit into local RAM the message block is moved to local RAM in a step 514 and the block is time tagged in a step 516. A step 518 determines whether any more blocks are available. If so steps 508 518 are repeated again. If not, an EOD label is stored at the end of the data in the step 512 and an exit is made in the step 506. The entire 1553 block may then be transmitted by the IOC to all channels and is deposited in link RAM 530. Blocks originating, for example, from local ram 450 in channel No. 1 308 of Fig. 11 will be deposited in the link RAM of the other channels as shown in Fig. 13. The 1553 relevant contents of link RAM are made available to all channels . Using this technique, the 1553 relevant data is synchronously available to all channels in the link RAM. The procedure for received data management in case of interrupting message blocks is dependent on the required actions to be performed by the host CPU. Thus, the interrupting message block may or may not be required by all channels. The accessing procedure for interrupting messages is basically the same as for non interrupting blocks Fig. 13 except for the use of a different I O port provided by the TC gate array. It should be understood that the transfer of data from the host CPU s local RAM to link RAM is not necessarily under the control of an IOC. Nor is the transfer of data from the 1553 RTI to the host CPU s local RAM necessarily under the control of the host CPU. Either of these functions could be controlled by another entity. For example, the IOC could control transfers from a host s 1553 RTI to its local RAM. Similarly a host CPU could control transfers from its local RAM to its own and the link RAM. Referring back to Fig. 11, each of the busses 304a, 304b, 306a, 306b feeds a related transformer 304c, 304d, 306c, 306d. These may be center tapped transformers as shown in more detail in Fig. 15. The transformer shown in Fig. 15 is a step up transformer having a step up ratio of 1 to 2 and may be a DDC part number BUS 25679 5E5630 04 0001. As shown in Fig. 15, the 1553 bus is attached to terminals 7 and 5 and the DFLCCs 308, 310, 312, 314 are attached to terminals 1, 2, and 3. Referring now to FIG. 16, the transformers 304c, 304d,306c,306d of Fig.11 are shown in more detail. Each of the transformers is connected to each of the other channels as shown by the transformer fan out in Fig. 16. The transformers may be mounted on a transformer card 530 as shown. Referring now to Fig. 17, a specific implementation of one of the sets of relays 532, 534, 536, 538 of Fig. 11 is shown. Although each of the relays in Fig. 11 is a single pole, double throw switch having an off position, the implementation shown in Fig. 17 uses a somewhat different arrangement to accomplish the same function. A relay 550 has a pair of single pole double throw switches with break make type contacts. Each of the switches is hooked up to both an avionics and display mux bus as shown. Relay 550 is hooked up to bus 304a and 306a of Fig. 11 while relay 552 is hooked up to bus 304b and 306b. Depending on the energization level of the coils in the relays the switches will select either the avionics or display bus for the channel. A second set of relays 554, 556 are hooked into the circuit to perform the off N C function shown in, for example, the relay 532 of Fig. 11. Depending on the energization level of the coils within each of the relays, the selected mux bus can be severed from the channel. A control circuit is shown below the relays in Fig. 17 which is provided to control the selection of either the avionics or display bus and to permit severing of a mux bus from a channel. The least significant bits on the data bus not D14 D15 are used to accomplish this function. The least significant bit not D15 on a line 560 controls the relays 554, 556 to sever the selected mux bus from the channel. The next least significant bit not D14 is provided on a line 562 to control the selection of either the avionics mux bus or display mux bus. Both of these signals are provided under the particular channel s CPU control. Referring now to Fig. 18, an illustration of the relays 532, transceivers 564, transformers 304c, 304d, 306c, 306d of Fig. 11, and the 800 microsecond timer 302 of Fig. 7 are shown. The transceivers 564 will not be described in detail but may be of a type well known in the art such as CT 1487 transceivers and may be hooked up as shown in Fig. 20. The 800 microsecond timer 302 of Figs. 7 and 18 is shown in more detail in Fig. 19. It includes a decade counter 580, a synchronous four bit counter 582, and a pair of OR gates 584, 586. The timer responds to a signal on line 588 at the beginning of a transmission to or from the bus by counting clock pulses on the line 590 and providing an 800 microsecond out signal on a line 592 after 800 microseconds have elasped. This signal is used by the OR gates 584, 586 to shut down the transceivers 564 of Fig. 18 whenever a communication lasts too long. The OR gates are also responsive to signals on lines 303 from the gate array 300 as described above. Although the invention has been described in the very specific context of a MIL STD 1553 bus it should be understood that the invention may be practiced as well in any asynchronous bus context.