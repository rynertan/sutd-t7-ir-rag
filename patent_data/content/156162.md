# PROGRAMMABLE CONTROLLER

## Claims
Programmierbare Steuerung mit

## Description
The present invention relates to a programmable controller and more particularly to a programmable sequence controller. The programmable controller is a unit which processes input information by a processing unit CPU in accordance with a sequence program stored in a memory RAM by a user and selectively operates equipments connected to output terminals in accordance with the operation result to attain a programmed sequence control. The programming may be constructed by a sequencer language which is easy to use for the user, such as LOAD, AND and OR. A processing system for executing the sequencer language program by the processing unit CPU includes an interpreter system in which a quasi coded program is executed while it is sequentially decoded, and a compiler system in which the program is translated to a machine language so that it is instantly executed. The prior art programmable controller used one of those systems. A programmable controller of the type referred to is disclosed in US A 4 302 820. This controller includes a microprocessor which operates in response to machine instructions stored in a read only memory. A control program comprised of programmable controller type instuctions is stored in a random access memory. An instruction from the control program is executed after being translated by the microprocessor through an interpreter routine. The former system, however, has drawbacks of long time required for decoding instructions and low processing speed, and allows the processing unit CPU may overrun if the translated program is destroyed by an external disturbance such as noise because there is no check means. Since those problems directly relate to the performance and safety of the programmable controller, solutions thereof have been desired. It is an object of the present invention to provide a programmable controller having a high processing speed. It is another object of the present invention to provide a sequence controller in which a processing unit hardly overruns. According to the present invention these objects are achieved by the features recited in the characterizing part of claim 1. A basic configuration of the programmable controller is shown in Fig. 1. Numeral 1 denotes contacts which are input signal sources, numeral 2 denotes an input unit which receives input signals from the contacts 1, numeral 3 denotes a processing unit CPU for executing a sequence control, numeral 4 denotes a readable and writable memory user RAM which is a first memory unit for storing therein a sequence program prepared by a user, numeral 5 denotes a read only memory system ROM, a non volatile memory which is a second memory unit for storing therein a control procedure system program for executing the sequence program, numeral 6 denotes an output unit for transferring the operation result of the CPU 3 to external equipments, not shown, and numeral 7 denotes a program unit for writing the sequence program keyed in by the user into the user RAM 4. Fig. 2 shows a circuit diagram of one embodiment of the present invention, which comprises the CPU 3, the user RAM 4, the system ROM 5 and a peripheral circuit for transferring the operation code of the sequence instruction stored in the user RAM 4 and transferring a data in accordance with the sequence instruction. Numeral 8 denotes a data memory which is a readable and writable memory RAM for temporarily storing therein signals supplied to the input unit 2 of Fig. 1, signals to be supplied to the output unit 6 and the operation result of the CPU 3. Numeral 9 denotes an address bus, numeral 13 denotes a first data bus which serves as a main transfer line of instructions and data, and numeral 14 denotes a second data bus which is used to write the sequence program into the user RAM 4. The circuit for transferring the operation code and data includes the following elements. Numerals 15 and 16 denote address decoders. when an address signal from the CPU 3 is applied thereto, only the selected one of Y₁, Y₂ and Y₃ assumes 0 and non selected ones assume 1 . Numeral 17 denotes an OR gate, numeral 18 denotes a NAND gate, numeral 19 denotes an AND gate, and numeral 20 denotes an inverter. Those elements logically operate in accordance with the outputs of the address decoders 15 and 16. Numeral 21 denotes a step counter for selecting the contents of the user RAM 4 stepwise, numeral 22 denotes a latch for latching the signal from the user RAM 4 at a predetermined timing, and numeral 23 denotes a buffer which receives the output of the latch 22 and transfers it to the CPU 3 through the data bus 13 at a predetermined timing. The buffer 23 has three output states 0 , 1 and High Impedance . Except when the signal from the user RAM 4 is transferred, the output state is High Impedance so that other data transfer on the first data bus 13 is not impeded. Numeral 24 denotes a selector which selects the signal from the user RAM 4 and the buffer 23 or the signal from the address bus 9 and supplies the selected signal to the data memory 8, and numeral 25 an inverter which inverts or non inverts the output of the data memory 8 and supplies it to the first data bus 13. Fig. 3 shows an example of the sequence program stored in the user RAM 4. One sequence instruction comprises 16 bits of which 5 bits are used for an operation code, 1 bit is used for an inversion code and 10 bits are used for an I O number. Since the user RAM 4 uses a general purpose 8 bit memory, each sequence instruction is divided into an 8 bit H byte and an 8 bit L byte, which are sequentially stored in this order. The sequence program comprises a plurality of such sequence instructions. The operation code may be expressed in any manner. For example, it has one to one correspondence to the sequencer language instructions LOAD, AND, OR, OUT, etc. as shown in Fig. 4. In Fig. 3, low order three bits of the operation code are omitted. 00010 shown therein corresponds to 00010000 in the 8 bit code or 10 in a hexadecimal expression . Undefined operation codes in Fig. 4 are provided for use in error checking, which will be explained later. Fig. 5 shows a portion of the system program stored in the system ROM 5. Machine language instructions corresponding to the instructions are stored at addresses shown by JMP, LOAD, AND, OR and OUT. A jump to address of the JMP jump instruction at address 7000 consists of two words, 70 and XX . XX means that it is any code and the jump to address is not designated. The XX portion of the non designated jump to address is determined by the operation code of the sequence instruction stored in the user RAM 4, and the machine language instructions corresponding to the sequence instructions such as LOAD, AND, OR, OUT are stored at addresses designated by the operation codes of the sequence instructions, that is, jump to addresses of the JMP instruction 7000 designated by the operation codes. The JMP instructions at the addresses 7012, 7022, 7032 and 7042 are used to return the program to the address 7000 when the processing is executed in accordance with the sequence instructions. The addresses 7080 et seq contain an error check and error processing program which is used when the content of the user RAM 4 is destroyed. This will be explained later. The operation of the present invention is explained for a sequence shown in Fig. 6. When the CPU 3 supplies a predetermined address signal for example, 7000 to the address bus 9, the output Y3 of the address decoder 15 is selected and the output 0 thereof is supplied to the OR gate 17 and the address decoder 16 so that the decoder 16 is enabled. The output Y₁ of the address decoder 16 is selected and the output 0 thereof is produced. Since the non selected output Y₃ of the decoder 16 is 1 , the output of the inverter 20 is 0 and the OR gate 17 produces the 0 output. The system ROM 5 is selected by the output of the OR gate 17 and the content at the address 7000 shown in Fig. 5 is read out. Since the output Y₁ of the address decoder 16 is 0 and the output Y₂ is 1 , the NAND gate 18 produces 1 output on the stepping line 26 of the step counter 21. Thus, the step counter 21 is incremented by one and the signal thereof is transferred to the user RAM 4. Thus, the user RAM 4 is selected stepwise and the H byte of the sequence instruction shown in Fig. 3 the operation code, the inversion code and a portion of the I O number is read out. Since the content at the address 7000 is the JMP instruction, the CPU 3 supplies the address signal stored at 7001 to the address bus 9 to read out the next content of the system ROM 5, that is, the content at 7001. The latch 22 is enabled by the trailing edged of the output Y₁ of the address decoder 16 to latch the H byte of the sequence instruction read from the user RAM 4. The timing therefor is shown in Fig. 7. As the address signal at 7001 is generated, the output Y₃ of the address decoder 15 is selected and the output Y₂ of the address decoder 16 is selected. Accordingly, the output of the OR gate 17 is 0 and the system ROM 5 remains selected. Since the output Y₁ of the address decoder 16 is 1 and the output Y₂ is 0 , the NAND gate 18 again produces the 1 output on the stepping line 26 so that the step counter 21 is incremented by one. Accordingly, the L byte of the sequence instruction shown in Fig. 3 remaining portion of the I O number is read out. Then, the CPU 3 supplies the address signal stored at 7002 to the address bus 9 to read out the content at the address 7002. The Y₃ output of the address decoder 15 is selected and the output Y₃ of the address decoder 16 is selected and the 0 output thereof is inverted by the inverter 20. Thus, the output of the OR gate 17 is 1 and the system ROM 5 is non selected and the buffer 23 is selected by the output Y₃ of the address decoder 16. The buffer 23 receives the content latched in the latch 22, that is, five bits of the operation code in the H byte of the sequence instruction stored in the user RAM 4 and constructs an 8 bit code by adding 0 to three low order bits, and supplies the 8 bit code to the data bus 13. Accordingly, the CPU 3 fetches the 8 bit instruction code through the buffer 23 instead of the content at the address 7002 of the system ROM 5. The timing therefor is shown in Fig. 7. The CPU has thus fetched 70 and XX 10 from the addresses 7001 and 7002 of the system ROM 5. It then supplies the address signal 7010 to the address bus 9. Thus, the output Y₃ of the address decoder 15 is 0 and the output Y₃ of the address decoder 16 is 1 and the system ROM 5 is selected again. Accordingly, the processing by the CPU 3 is jumped to the jump to address 7010. Since the address 7010 contains the LOAD instruction instructing to read address 40 , the CPU 3 supplies the signal 40 to the address bus 9. Thus, the output Y₂ of the address decoder 15 assumes 0 and the output 0 is supplied to the AND gate 19 through the select line 27 and the data memory 8 is selected by the output 0 of the AND gate 19. The address decoder 15 is organized to let the output Y₂ 0 based on the signal 40. Since the I O number in the L byte of the sequence instruction fetched from the user RAM 4 and the I O number in the H byte of the sequence instruction latched in the latch 22 are supplied to the address line 29 of the data memory 8 through the selector 24, the contents of the data memory corresponding to the above I O numbers are supplied to the data bus 13 through the inverter 25 and supplied to the CPU 3. Since the current sequence instruction is Read input signal of contact 10 , the input signal from the contact 10 Hexadecimal which has previously been stored in the data memory 8 is fetched by the CPU 3. The inverter 25 inverts or non inverts the signal from the data memory 8 depending on whether the inversion code bit of the sequence instruction latched in the latch 22 is 1 or 0 . It is used to invert the input signal from the contact b. CPU 3 then read out the content at the address 7012 and executes it. Since the address 7012 contains JMP 7000 , that is, jump to the address 7000 , the processing of the CPU 3 again jumps to the address 7000. The execution of the sequence instruction shown in Fig. 3 is thus terminated and the next sequence instruction logical AND of the input signal at the contact 11 is started. In the following execution of the instruction, the machine language instruction corresponding to the sequence instruction is selected by the JMP instruction at the address 7000. Only the jump to address XX is different. The jump to address is determined by the operation code stored in the user RAM 4 and the CPU 3 executes the machine language instruction at the designated jump to address. Since the operation code of the sequence instruction stored in the user RAM 4 is read by the CPU 3 as the jump to address and machine language instruction stored in the system ROM 5 is addressed in accordance with the sequence instruction, the instruction decode routine which was necessary in the prior art interpreter system can be omitted and the fetched instruction can be instantly executed. Accordingly, the processing speed is significantly improved. For example, the processing speed was 40 ms kw in the interpreter system while it is 20 ms kw or less in the present system. Since the instructions for the operand codes are stored in the system ROM 5 as the machine language instruction, the instructions are not destroyed by an external disturbance such as a noise and the safety is guaranteed. In the present system, since the error check and error processing routine may be stored in the system ROM 5 as a part of the system program, the safety is assumed even if the content of the user RAM 4 is destroyed by the external disturbance such as noise. For example, in case the content of the user RAM 4 is destroyed, several undefined operation codes 80, 90 F0,00 are provided as shown in Fig. 4 and JMP 7800 is stored at each of the addresses corresponding to the undefined operand codes as shown in Fig. 5. Assuming that the address 7800 contains the error processing routine, the overrun of the CPU 3 is avoided and an alarm may be issued even if the content of the user RAM 4 is destroyed, by the jump to the error processing routine from the jump to address corresponding to the undefined operation code. The function of the selector 24 is now explained. The signals from the user RAM 4 and the latch 22 are supplied to the address line 29 through the selector 24. When the CPU 3 generates a specific address signal, the output Y₁ of the address decoder 15 is selected and the output signal thereof is supplied to the selector 24 through the select line 28. Thus, the selector 24 selects the signal such that the signal on the address bus 9 is supplied to the address line 29. Thus, the CPU 3 is allowed to directly access the data memory 8 as required. Through this function, the CPU 3 can read in the signals of the contacts 1 in Fig. 1 and store them in the data memory 8 and transfer the specified content of the data memory 8 to the output unit 6 by the direct access between the CPU 3 and the data memory 8 without intervention of the user RAM 4. Accordingly, high speed data processing is attained. In the above embodiment, the signals of the contacts 1 are collectively read at each scan time and stored in the data memory 8, and the specified content of the data memory 8 is read out by the signal from the user RAM 4. Alternatively, the I O number read from the user RAM 4 may be latched and it is supplied to the CPU 3 through the buffer at a predetermined timing in the same manner as that of the reading of the specified content of the data memory 8 by the signal from the user RAM 4 so that the input signal from the specific contact is read in without routing the memory each time the instruction is executed. The same is time for the data output to the output unit 6. In accordance with the present invention, the machine language instruction corresponding to the sequence instruction is selected using the operation code of the sequence instruction as the jump to address. Accordingly, it is not necessary to interprete the operation code each time it is fetched as is done in the prior art interpreter system and the processing speed is increased. Since the machine language instructions and the error processing routine are stored in the memory such as system ROM the content of which will not be destroyed by the external disturbance, the overrun of the CPU which occurred in the prior art compiler system is prevented and the safety is enhanced.