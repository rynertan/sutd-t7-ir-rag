# GRAPHICS DISPLAY RAPID PATTERN FILL USING UNDISPLAYED FRAME BUFFER MEMORY

## Claims
Verfahren zum Füllen einer vorbestimmten Form oder eines vorbestimmten Bereiches einer graphischen Bilddarstellung mit einem oder mehreren vordefinierten Mustern, wobei dieses Verfahren einen Rahmenspeicher verwendet, der in seinem ersten Abschnitt 20 die Informationen, die das darzustellende Bild beinhalten, empfängt, und den Schritt umfaßt, zumindest ein nachbildbares Muster zu definieren, das zum Einfüllen in die vorbestimmte Form verwendet werden soll, gekennzeichnet durch die Schritte

## Description
This invention relates to a graphics display method and apparatus. Graphics display units capable of filling predetermined areas of a graphics display screen with predefined repetitive patterns which generally are relatively small in size compared to the total area to be filled with the pattern are well known. See, for example, MINI MACRO CONFERENCE RECORD , May 1984, pages 1 8, Northeast, New York, US J.C. DALRYMPLE et al Display processor architecture in the Tektronix 4115B . Generally, however, existing arrangements are relatively quite slow in painting the patterns and require additional or special circuitry and storage capacity which add significantly to the cost of such displays. Moreover, in such arrangements replicating patterns generally involves considerable shifting, splitting, and partial word writes. What is needed is to be able to rapidly fill the predetermined areas of the screen without the requirement for substantial additional or special circuitry and memory and electronic manipulation required of prior art arrangements. Aspects of the present invention are set out in the accompanying claims. The above problem is solved in the preferred embodiment by effectively utilizing extra scan lines of the frame buffer memory, i.e., the lines of the frame buffer memory not being displayed on the screen, to house the patterns to be utilized in filling the predetermined shapes or areas, by first replicating those patterns as necessary in the undisplayed portion of the frame buffer memory, and utilizing portions of these stored patterns which coincide in at least one dimension with the shape s or area s to be filled, wherein the latter become filled one scan line at a time. Thereby, only the height of the patterns, as opposed to the areas to be filled in per se, is required to fit in the height of the undisplayed section of the frame buffer. An arrangement embodying the invention will now be described by way of example with reference to the accompanying drawings, in which Referring to Fig. 1, which depicts a display controller unit, and Fig. 2 which depicts in detail the picture processor 110 of Fig. 1, a 100 pixel wide by 100 pixel high frame buffer is considered by way of example herein Figs. 3 5 , wherein it is intended that the top 80 lines of the total of 100 scan lines of the frame buffer are to be displayed on a screen, i.e., the displayed portion 20 of Figs. 3 5. A 20 pixel high by 100 pixel wide undisplayed strip at the bottom of the frame buffer 10 is thus available. Also by way of example, a 50 by 50 pixel rectangle 25 is herein considered, as a representative shape to be filled in by say a 7 by 3 pixel paint pattern. The geometric shape of a rectangle or a square is chosen for convenience in illustrating the invention. Indeed, virtually any predetermined area of desired shape may be rapidly filled via this invention. For ease of explanation, Figs. 3 5 illustrate the upper left corner of the rectangle 25 as being positioned at point 30,20 , in a left handed coordinate system 0,0 in the upper left corner . A right handed coordinate system could equally well be considered. According to the invention, the sample 7 x 3 pattern is initially loaded into the frame buffer, in this example at pixel locations 0 6 in X horizontal dimension and 80 82 in Y vertical dimension . This is shown as rectangle 11 in Fig. 3. The pattern is then copied from there or reloaded from the original pattern specification to locations 7 13, 14 20, 21 27, etc. in X, all at 80 82 in Y. The entire width of the undisplayed portion 10 of the frame buffer is thus filled in this manner, as shown in Fig. 4. The final replication of the pattern, at 12, is truncated at the right edge of the screen, using only the left two columns of the pattern definition, in this particular example. Other patterns may, of course, be entered into the remaining unused area of the undisplayed portion 10 of the frame buffer. Having completed the preparatory phrase, the display unit may now actually fill the rectangle, one scan line at a time. This is done by copying, in this example, 50 pixel wide sections of the scan lines in the replicated pattern, from the undisplayed portion of the frame buffer, up into the rectangle. If the pattern is to align between adjacent rectangles, then the 50 pixel wide section of the pattern store used should be directly under the rectangle, and the top scan line of the rectangle should be filled from the line at 20 mod 3 80 82 in the pattern store. The next scan line of the rectangle should come from 21 mod 3 80 80 and so on. If pattern alignment between rectangles is not required, then the copying could always start with the top scan line of the pattern store and count down, resetting to the top scan line after every use of the bottom scan line of the replicated pattern. Where the example area being filled is a more general polygon, rather than simply a square or rectangle, the method of the invention still applies. The only change would be that each scan line of the section of the polygon may be a different width in a horizontal direction than the previous one or even multiple sections along the same line which are representative of different portions of the same shape or multiple shapes to be filled in with the same pattern . The proper scan line of the pattern store is copied to the appropriate section s of the polygon scan line, and the process repeated for the next line, just as for the rectangle. A principle advantage of this invention is the speed of filling in areas. Except for special cases where the width of the pattern is an integer fraction of the frame buffer word width, copying a section of one scan line to a section of another scan line at the same horizontal position is much faster than replicating the pattern across the scan line section. In the example above, the pattern was replicated across three full scan lines and then copied to 50 scan line sections, each 50 pixels wide. The alternative would have been to replicate the pattern across all 50 scan line sections. While the 100 x 100 pixel frame buffer size for the within described example was chosen for ease of illustration, typical real frame buffer sizes with undisplayed portions may be 512 x 512 with 512 x 384 or 512 x 480 displayed, 640 x 512 with 640 x 480 displayed, 1024 x 1024 with 800 to 1024 x 600 to 1000 displayed, and 1280 x 1024 with 1280 x 960 to 990 displayed. The word width of typical real frame buffer implementations generally varies from 16 to 80. Whereas replicating a pattern that is not an integer fraction of the word width generally involves much shifting, splitting, and partial word writes, with this invention copying from the pattern store requires no shifting and significantly fewer partial word writes, and can often be done with an entire frame buffer word per cycle. In connection with the example of the 100 x 100 pixel frame buffer herein described, one can consider an implementation of that frame buffer using, as example, 20 pixel memory words. Typically, one could assign memory words 0 4 to comprise scan line No. 0 top , 5 9 for scan line 1, etc., with words 0, 5, etc on the left, and words 4, 9, etc. on the right. The pixels within each word would be numbered from 0 on the left to 19 on the right. In this manner, the upper left pixel of the rectangle to be filled 30,20 would be pixel 10 of word 101, and the lower right pixel of the rectangle 79,69 would be No. 19 of word 348. In discussing operation of the display control unit DCU depicted in Fig. 1 in connection with the filling of the 50 x 50 pixel example rectangle with the 7 x 3 pixel pattern, it is to be noted that Fig. 1 in actuality shows a 1024 x 1024 pixel frame buffer built from 16 pixel words, whereas for the purposes of this example, there is assumed a 100 x 100 frame buffer built from 20 pixel words and 20 bit data paths throughout the picture processor and busses. Moreover, although Fig. 1 depicts monochrome operation, this invention is directly applicable to color arrangements. During system initialization, the microcode RAM 111 of the picture processor 110 is loaded with code capable of executing lists of commands display lists stored in memory in a so called display processor unit DPU . Although the DPU is not particularly shown in the figures, the local bus 120 connecting it with the display control unit DCU is shown in the lower left of Fig. 1. In this implementation, shadow register loop 130 is used for loading code. Commands in the display lists include ones to load paint patterns and ones to fill shapes e.g. rectangles, general polygons, etc. , preferably with the most recently loaded pattern. Multiple areas filled with differing patterns can be drawn by interspersing load paint pattern commands with the fill area commands in a display list. The graphics illustrated in Fig. 6 are representative thereof. It can be assumed, therefore, that the picture processor 110 in executing a display list, will at some point encounter a load paint pattern command with say a 7 x 3 pixel pattern. The picture processor pp 110 reads the pattern and left justifies it into three temporary registers each 20 pixels wide to match the frame buffer word width . These registers, though not particularly shown, may be called A1, B1, and C1. The pp copies these registers into another register set, called say A2, B2, and C2, and shifts these to the right 7 places. It logically OR s A1 into A2, B1 into B2, and C1 into C2. The shifting and OR ing is repeated once more to complete the first three words of the pattern store. The pp writes A2 into word 400, B2 into word 405, and C2 into word 410 of the frame buffer the left word of scan lines 80, 81, and 82 . The addresses for the write operations pass over the lines label led LDA1 LDA23 and the data over lines LDD0 LDD19 only LDD0 LDD15 are shown in the diagram as it depicts a 16 pixel word width machine . These three words now each contain two complete copies of the pattern and a 6 pixel wide section of a third copy. A similar set of shift and OR operations is used to form the next set of three 20 pixel words, which are written to words 401, 406, and 411 of the frame buffer. This second set of three words will contain two complete copies of the pattern with an additional one pixel wide section on the left to complete the 6 pixel wide section at the right of the previous three words and a 5 pixel wide section on the right. The remaining three sets of three words are each written in a similar manner. Having completed loading of the pattern store, the pp completes the load paint pattern command by storing the height of the pattern, 3, in a word of local memory or register within the pp. This value is used later for the modulo and wrap around calculations. The pp will subsequently encounter the example command of fill rectangle between 30,20 and 79 69. Using the modulo calculation discussed previously, the pp calculates that the first pattern store scan line to be used is 82. It further calculates that the first upper left frame buffer word in the rectangle is 101 and that only the right 10 pixels of this word are within the rectangle. The pp reads the frame buffer words No. 101 and 411 the word from line 82 of the pattern store directly under the word 101 into two temporary registers, say R1 and R2 respectively. It moves the right 10 pixels from R2 into R1 leaving the left ten pixels of R1 unchanged, then writes R1 back into frame buffer word 101. Next, frame buffer word 412 is read into a temporary register and immediately written to word 102, and word 413 similarly copied to word 103. A 50 pixel wide section of scan line 82 within the pattern store has now been copied into a 50 pixel section of scan line 20. The same procedure of reads and writes, except for different word addresses, is used to copy 50 pixels from scan line 80 into 21, line 81 into 22, 82 into 23, 80 into 24,..., 80 into 69. In this way, the entire rectangle becomes filled. More sophisticated frame buffers have the ability to write arbitrary sections of a word. In such cases moving 10 pixels from word 411 to 101 becomes a simple read and write, as would be the moves from 412 to 102 and 413 to 103 above. An even faster frame buffer can be constructed to provide for copying an arbitrary section of one scan line into the same section of another scan line as a single operation. In this case, the entire rectangle fill depicted herein would require only 50 operations. Without the present invention, filling this rectangle would require 8 x 50 400 writes of 7 or less pixels each, with shifting of the 7 pixels required on most of the writes. The operations described in this example all have the result of copying rectangular areas of pixels from one place to another. In the case of loading the paint pattern, it is copying a 7 x 3 pixel rectangle from the display list memory to multiple locations in the pattern store area of the frame buffer. In filling the rectangle, it is copying 50 x 1 pixel rectangles from the pattern store to the rectangle. For reference on copying rectangular pixel arrays, see Ingalls, D., The Small Talk Graphics Kernel, special issue on Small Talk, BYTE, 6 8 , August 1981. It again should be noted, however, that the patterning discussed in such article is restricted to 16 pixel wide patterns, which is the width of the frame buffer employed. It is referenced for rectangular area copying only, whereas the present invention provides more general patterning capability. As described in the BYTE article, copying can be expanded to include logical operations between the source and destination. For example, a logical OR operation between the pattern store and the rectangle to fill results in a transparent pattern. Wherever there are zeros in the pattern store, the corresponding areas of the rectangle are left unchanged. This gives the appearance of seeing through the rectangle as if it were a screen door. There has thus been described above a graphics display rapid pattern fill arrangement in which user defined patterns within a delta X value and a delta Y value of frame buffer memory may be replicated in X from a seed memory location block in the undisplayed section of the frame buffer memory, until the desired portion of that frame buffer section which may be the entire undisplayed section is consumed, with coordinated portions of such replicated pattern being utilized to fill in predetermined areas of the image to be displayed. In such arrangement, the boundary of the area or shape to be filled acts as a window to view the pattern and a replicated pattern will not actually be visible until the shape to be filled is drawn on the screen.