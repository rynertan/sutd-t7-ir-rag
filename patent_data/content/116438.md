# Binary digital processor.

## Abstract
A binary digital microprocessor is arranged to perform rotations and additions on complex input variables A jB by means of binary shifts and additions. The functions cos and sin are approximated by the functions C m and S m respectively, where C m 1 2

## Claims
Claims. 1. A binary digital processor for rotating a vector representative of two independent variables x ai d y by an angle in the xy plane by means of respective approximations to the operations of multiplication by sin and cos , said processor comprising adding means 7 12 and means 3 6 for performing controlled binary sfiifts on said variables so as to achieve multiplication of said variables by the functions S m or C m and thereby approximate to multiplication by sin or cos respect ively, where S m 2 m and C m 1 2 2mcl m being chosen such that tan S m C m 2. A binary digital processor as claimed in Claim 1, comprising similar x dndy sections arranged to process real x and imaginary jy components respectively of said vector each of said sections comprising a register 1,2 for storing the value of said real or imaginary component, a first binary shifter 4,6 coupled to the output of said register for multiplying said value by the function S m and an adder 7,12 having positive and negative inputs one of said inputs being coupled to the output of said register and the other of said inputs being coupled via a second binary shifter 3,5 to the output of said register, such that said value is multiplied by the function C m at the output of said adder 7,12 wherein the outputs of said adders 7,12 are added to or subtracted from the outputs of the complementary first binary shifters 6,4 so as to generate new x and jy components of a rotated version of the original vector x jy. 3. A binary digital processor as claimed in Claim 2, further comprising means 8,11 for feeding said new x and jy components into the respective inputs of said registers 1,2 and additionally comprising further adding means 8,11 connected to said respective register inputs for adding or subtracting independent input variables a i fro said new x jy components. A binary digital processor as claimed in Claim 3, further comprising controlled gating means 19 33 for controlling the vector rotation and the addition or subtraction of said input variables A jB . 5. A binary digital processor as claimed in Claim , further comprising a stored operating program Fig. 4a for controlling said gating means 19 33 . 6. A binary digital processor as claimed in Claim 4 or Claim 5, arranged to conditionally rotate a vector stored in said registers according to the sign of its x and or jy components. 7. A binary digital processor as claimed in any ofClaims 3 to 6, further comprising counting means 2 arranged to measure the angle of rotation of a stored vector. 8. A binary digital processor as claimed in any preceding Claim, arranged to evaluate the exponential terms WnNk of a discrete Fourier transform by successive vector rotations. 9. A binary digital processor as claimed in any preceding Claim, arranged to compute the radix N discreteFourier transform EMI15.1 where N is a prime number, Q is any integer such that Q p0 mod N and k is defined by the expression kkh mod N Q. 10. A binary digital processor as claimed in Claim 9 wherein Q 1. 11. An arrangement comprising one or more binary digital processors as claimed in Claim 9 or Claim 10, arranged to compute a radix N N discrete Fourier trans form by decomposition into two Fourier transforms of radix N1 and N2 respectively, N1 and N2 both being prime numbers. 12. A spectrum analyser incorporating a binary digits processor as claimed in Claim 9 or Claim 10, or an arrangement as claimed in Claim 11.

## Description
The present invention relates to digital processing circuits for performing mathematical operations on vectors and other variables which may be expressed in the complex form x jy , and to signal processing arrangements utilising such circuits. It is frequently necessary or convenient, when dealing with a vector of the form x jy , to rotate it in the xy plane by an angle , and this operation may be performed by the transformation 1 ... x jy x cos y sin j y cos x sin involving multiplication by sin and cos . In computing terms, the accurate calculation of cos and sin is time consuming and or uneconomic in terms of memory. An object of the present invention is to provide a digital processing circuit which is capable of rapidly and accurately performing calculations involving complex variables. Consider the expressions COS 1 2 a sin 2 mSince sin2 l cos2 sin2 2 l a 2 2a 2 l a a 1 But sin2 2 2m exactly true sina 2m 1 a 1 Thus in the transformation 1 above, if the functions cos and sin are replaced by the functions c m and s m where c m 1.2 2m l ... 2 s m 2 m ....3 and m is chosen such tan m that EMI1.1 then rotation of x jy by exactly the angle will be achieved.The modulus of x jy will be increased slightly by the approximation used for a in terms of m,thus 1 2 2m 1 ê 2 m ê cos2 sin2 1 2 4m 3 giving a per unit error k m of k m 2 4m 3 Thus the transformation x jy x.c m y.s m j y.c m x.s m ...6 is exactly equivalent to the transformationEMI2.1 where m is define by equation 4 . Having chosen an appropriate parameter m to give the desired angle ,x.c m and y.s m can be evaluated simply by shifting x and y 2m l and m places right respectively in a binary shift register, and in the case ofx.c. m , adding x. Thus the transformation 6 may be accomplished in a binary digital circuit arrangement using adders, shift registers and a set of stored values of m corresponding to various values of , no multi plication being necessary.Rotation by an angle which does not .correspond closely to an integral value of m may be achieved by successive rotations by 1, 2... N where n and each of 1, 2... N corresponds ciosely to an integral value of m. Therefore, according to the present invention, a binary digital processor for rotating a vector represent ative of two independent input variables x and y by an angle in the xy plane by means of respective approximations to the operations of multiplication by sin and cos comprises adding means and means for perfo ining controlled binary shifts on said variab cs so as to achieve multi p ication of said variables by the functions S m or C m and t.hei eby approximate to multiplication by sin or cos respectively, where S m 2 m and C m 1 2 2m l ,m bcirg chosen such that tan S m The processor may conveniently be incorporated in an integrated circuit. Means such as a look up table stored in a memory may be provided for supplying one or more values of m which is necessarily an integer to enable any desired angle of rotation to be achieved. In general this will involve the addition and substraction of a plurality of smaller rotations, each of which corresponds exactly to one or other value of m. The number of rotations required will depend on the desired accuracy of the required total rotation. T he processor may incorporate selectors and additional adders to enable vectors to be added, subtracted rotated and multiplied. Particular embodiments of the invention will now be described by way of example with reference toFigures 1 to 8 of the accompanying drawings, of which Figure 1 is a schematic representation of a simple vector rotator accumulator in accordance with the invention Figure 2 is a table showing the angle of rotation as a function of m and the corresponding magnitude error Figure 3 is a schematic representation of a more versatile digital processor which is suitable for use in a frequency analyser Figure 4 shows a microprogram for operating the processor of Figure 3 Figure 5 shows an arrangement for evaluating a discrete Fourier transform D.F.T. Figure 6 is a high level program for operating the arrangement of Figure 5 Figure 7 shows an arrangement for evaluating a complex D.F.T., and Figure 8 is a high level program for operating the arrangement of Figure 7. .. , Referring to Figure 1, the simple processor shown comprises an upper half which handles the real component of a vector x jy and a precisely similar lower half which stores the imaginary half of.x jy j being implied the instantaneous values of xand y being stored in binary registers 1 and 2 respectively. Shifters 3 and 11, 5 and 6 are associated with registers 1 and 2 respectively and shift the binary representations of and by either m places shifters 4 and 6 or 2m l places shifters 3 and 5 in accordance with an input value of m.Input data in the form of a vector a jb is added to the vector x jy stored in the registers and the latter is rotated by an angle m in accordance with equation 4 each time the registers are clocked. Each resulting new value of t iY is successively stored in registers 1 and 2. The operation of the processor is as follows When register 1 is clocked the stored value of x is applied to the positive input of adder 7 and the stored value of x shifted 2m l places to the right i.e.x.2 2m 13 is applied to the negative inDut of adder 7. The resulting output x 1 2 2m l which is equal to x c m is added to the output of adder 9, fed to the output of the processor, and stored as the new value of x in register 1. The output of adder 9 is a y.2 m m i.e. a y.s m and hence the ncw value of x output from the processor and stored in register 1 is x.c m y s m a The operation the other half of the ro or is precisely similar so that the new value of y output from the processor and stored in register 2 is y.c m x.s m b Thus each time the processor is clocked, inputting a, b and m, the stored vector x jy is transformed to the vector x.c m y.s m a j y.c m x.s m b From equation 7 it can be seen that this transformation corresponds to rotation of x jy by , multiplication of x jy by l k m where k m is given by equation 5 and addition of a jb to the rotated vector. It will be apparent that selectors may be inserted in series with the adders in Figure 1 to allow simple addition ofa jb to x jy or simple rotation of x jy . Figure 2 shows the values of m and k m corresponding to values of angle of rotation up to 14 . It can be seen that k m rapidly becomes negligible even at small values of m.A suitable program for choosing successive values of m to apply to the processor of Figure 1 so as to achieve a desired total rotation may readily be devised by a person skilled in the art and stored if necessary in aPROM programmable read only memory . The total values of both m and k m are equal to the respective sums of the individual S and keys. Since m halves with each increment in m, an accurate rotation may be achieved by using only a few successive values of m. It will be appreciated that rotations of 90, 180 and 270 degrees may be achieved exactly by signed transfer of data between registers. Rotation by zero degrees may be used for simple addition and to pad out compound rotation sequences to a fixed length.Reverse rotation may be achieved by changing the sign of the s m coefficients and rotation to the first quadrant may be achieved by using sign changes on negative data only thereby Icplac ing x jy by xl jlyl . The modulus of a stored vector may be determined by providing means for registering a change in sign of y from positive to negative rind for inhibiting further rotation, so that the vector is rotated onto the real axis in small steps. The x value is then equal to the modulus of the vector. The argument of the vector may be found by summing the rotations required to bring the vector on to the x axis. Gain control may be achieved by additing and or subtracting appropriate fractions of the input a jb achieved by binary shifts a controlled number of times before rotating the vector this facility is useful for example in windowing input waveform samples in FourierTransform frequency analysis. The extra functions described above may be achieved by simple modifications generally involving the insertion of selectors in the input paths of the adders to the processor of Figure 1. Some of these functions are incorporated in the more sophisticated processor of Figure 3, but will be apparent to one skilled in the art and will not therefore be described individually in detail. Figure 3 shows a processor which is similar to that shown in Figure 1, but which is more versatile, The operation of the processor of Figure 3 will be described with reference to the operating program tabulated inFigure 4. The processor employs the two is complement binary format., in which the most significant bits Xm and Ym stored in the X and Y registers 1 and 2 represent 2 C, where is the value of the next most significant bit. Thus each register can store a binary number having a value between 26 1 inclusive, X and Y having a m value zero for positive numbers and unity for negative numbers. Typically the X and Y registers, adders, shifters and selectors and the data buses between them might have a capacity of 24 bits without undue complexity. The processor of Figure 3 is controlled by a control section 39, which is in turn controlled by inputs X m and Ym, the most significant sign bits from theX and Y registers 1 and 2 respectively , a 3 bit binary code F corresponding to F2, F1, Fo in the program listed in Figure 4 a and a 1 bit sign code S listed in the same program. S 0 gives true input data or positive counter clockwise rotation. 5 1 gives negated input data or clockwise rotation. Control 39 generates 1 bit output codes a ,b,e,d,e,f,g,h,j,k in response to the inputs Xm, Ym, F and S and feeds them to the various adders and shifters referenced 3 to 34 in Figure 3.It will be appreciated that the upper and lower halves of this part of the processor handle the real input data from input A and imaginary input data from input B in precisely the same manner. Accordingly, each control code a,b, e,f,j,k is routed to two identical components as indicated, thus code a controls compoents 19 and 22, code b controls components 20 and 23 and so on. However XOR gates 27 to 30 are independently controlled by codes g,c, hand d respectively. An additional halt outputH is fed to a counter 42, which counter counts small known rotations of the vector x jy. Output H is gener ated by the sign bit m and has a value unity when changes from zero to unity, corresponding to rotation of x jy clockwise past the x axis. When H changes to unity, counter 42 is stopped, and thus registers the number of known small rotations typically one degree required to bring a vector x jy onto the x axis, which corresponds to the argument of the vector. Additional control signals are fed directly to some or all of the components of the processor, namely a clock signal a value of m in 4 bit code to shift registers 3,4,5 and 6 only a 1 bit transfer code T to selectors 35,36 and 41 , for either updating the output registers 37,38 and 40 T l or leaving them unchanged, T 0 a 2 bit output enable code 0 to selector 43 for selecting one of inputs 0,1,2 or 3 and a 1 bit output enable code E to a common output buffer 44. The states of transfer code T and output enable code 0 are tabulated in Figure 4 b and 4 c and labelled with two letter or three letter program codes which appear in the higher level programs of Figures 6 and 7. Codes RL,IM, NIM and ARC correspond to inputs 0, 2, 1 and 3 respec tiyely of selector 43. Inputs m, F,S,T,O and E, together with suitable write commands and source and destination addresses not shown are generated by a high level program Figure 6 which is suitably stored in ROM read only memory . Figure 4 a shows the eight operations in program code, NOP, LSI, ASI, ROT, RAC, RFQ, ROC and CAR which the processor can perform on input data A J.B, in terms of the inputs to control 39 and the corresponding outputs generated by control 39 It will be appreciated that those operations which involve rotation will additionally be governed by the variable m, which determines the angle of rotation m in accordance with expression 4 . Before describing the operations tabulated in Figure 4 a the hardware for implementing control of the processor shown in Figure 3 will be briefly described.Components 25 and 26 are NAND gates. Components 27,28,29 and 30 are XOR exclusive OR gates. Components 31,32,33 and 34 are selectors, which select inputs 1 or 0 according to the value of their bi nary control code j or e. Components 19,20,21,22,23,24 are AND gates and therefore behave as adders when their binary control codes are high a,b,f 1 . Components 13,14,15,16,17,18 are simple adders and components 1,2,3,4,5 nd 6 are the same as the correspondingly referenced components in Figure 1. Referring to Figure 4 a , the first operation listed is NOP no operation which simply leaves stored x jy unchanged, irrespective of the input data. This is achieved by feeding the contents of the x and y registers back into their inputs. Accordingly a path for the stored x data is formed through selector 31, XOR gate 27,AND gate 21 and adders 14 and 15 by putting k O blocking off gate 25 1 j O to select input 0 of selector 31 g O to open gate 27 and f l to open gate 21 . By setting h O a similar path is formed for the y register.The addition of A and B to x and y at adders 14 is prè vented by setting a O . These values are set out in the first row of the table of Figure 4 a . Outputs c,d and e are not specified. Since no operation is carried out, inputs S, Xm, Ym and H are immaterial such don t care inputs are indicated by crosses. Operation LSI exists in two versions and replaces x jy by either s m A jB if the sign bit S O or s m A jB if S l. Similarly, operation ASI achieves the transformation x J.y x jy s m A jB according to whetherS O making c O and d O or 1 making c l and d l . Operation ROT achieves the rotation in either direction p . J x jy x.c m T y.s m j y.c m x.c m according to whether S O or 1. Operation RAC performs the combined rotation and addition x jy x.c m y.s m A j y.c m x.s m B again according to whether S O or S 1. Operation RFQ exists in four different versions according to the state of X and Ym i.e. according to m the quadrant in which x jy falls . This changes the signs of x and y only if they are respectively negative thus the new x and y are always positive. Operation ROC leaves x jy unchanged if H l and rotates x jy by m if H O i.e. when H O, x jy x.c m y.s m j y.c m x.s m the direction of rotation depending on the value of S.If m is chosen to make small, the argument of x jy can be found by adding the s in counter 42 , as already described. The operation CAR rotates x jy by 900 according to the value of S. Figure 5 shows a processor P as described above with reference to Figure 3, incorporated in an arrangement for evaluating the frequency components of an input waveform by means of a discrete Fourier transform .F.T. Samples of the waveform are stored digitally in a memory M1, fed to the real input of processor P the imaginary input being left unused or used for some other function , processed and output to a memory M2, which is divided in two for storing the real and imaginary parts respectively of the output vector x J y. The arrangement is controlled by a controller sequencer C, which is in turn fed with the program tabulated in Figure 6.The program of Figure 6 is written in terms of the operations set out in Figure 4 and also includes WR write real and WI write imaginary commands for entering output data from P into memory M2 together with the necessary source and destination addressesSA and DAZES The general expression for an N point radix N discrete Fourier transform is EMI10.1 x is the value of the nth complex waveform sample and Xk. n is the amplitude of the kth frequency component. It has been shown by T.E. Curtis and J.E. Wickenden on pages 424 and 425 of I.E.E. Proceedings Vol. 130, Part F, Number 5 August 1983 that expression 8. may be re written as EMI10.2 in the special case where N is a prime number EMI10.3 where Q is any integer such that Q 0 mod N and k is defined by the expression kk mod N Q.The above mentioned article which starts at p.423 is hereby incorporated by reference. It will be noted that a single value of WQNwhich corresponds to a vector rotation in expression 9. may be chosen and used for all frequency comp nents k except 0 , different values of k using different input data sequences. nces. Thus expression 9. may be evaluated more easily than expression 8. , which requires a different rotation for each value of k. The program of Figure 6 evaluates expression 9. for a 5 point D.F.T. N 5, k 1,2,3,4 , which is equivalent to evaluating the matrix product EMI11.1 The matrix of xn above represents the Wnk mod 5 in the sum. The XO terms representing the D C. signal component are omitted.EMI11.2 is rotated by 25 72 . This is achieved in Figure 6 by a rotation of 900 and then two reverse rotations of approximately 140 m 2 and 40 m 4 respectively.Expression 12. is evaluated in lines 1 to 13 of the program source addresses 4,3,2,1, and 0 corresponding to x4, x3, x2, xl and x respectively and X1 is output in lines 15 and 16. Because of the conjugate symmetry of the matrix of Xn in expression 11. , X4 can be immediately derived from X1 and is output in lines 17 and 18 of the program. X2 is calculated in lines 14 to 26 of the program and output at lines 28 and 29, enabling X3 to be output at lines 30 and 31, and XO is calculated in lines 27 to 31 of the program and output at lines 33 and 34.Thus a set of complex harmonies X1 to X5 are output from memory M2. The arrangement of Figure 5, programmed as shown in Figure 6, may thus be used substantially as it stands to perform a frequency analysis on an input waveform. It will be appreciated that a D.F.T. having many more than 5 points will generally be used in practice. A program on the lines set out in Figure 6, but with a proportionally greater number of steps, may be derived without difficulty for a D.F.T,. having a large, prime number of points.Furthermore it will be appreciated that the processor ofFigure 3 is generally applicable to the calculation ofD.F.T.S, and not just the special form of prime radixD.F.T. of expression 9. , Thus the general D.F.T. of expression 8. may be written recursivelyEMI12.1 and computed by the processor of Figure 3 by summing the data samples in reverse order with a repeating compound rotation WN. However the prime radix D.F.T. 9. may be computed more efficiently and in particular a D.F.T.decomposed into a plurality of particularly 2 prime radix D.F.T. S such as 9. may be computed highly efficiently by a processor in accordance with the invention. On page 424 of the Curtis and Wickenden paper referred to above, it is shown that a radix N N D . F.T. can be efficiently evaluated by performing N1 radixN2 D . F.T. S and performing N2 radix N1 D.F.T. S on the result, if N1 and N2 are relatively prime i e the highest common factor 1 . This condition is of course fulfilled if both N1 and N2 are themselves prime numbers, and accordingly Figure 7 shows an arrangement for processing the complex output XO to X of the processor arrangement of Figure 5 to successively calculate five radix 3 D.F.T. S of the type shown in expression 9. . Thus the arrangement of Figure 7 is precisely similar to that of Figure 5 except that it handles complex input data, which is fed to a divided input memory M3. The input data is fed to the real and imaginary inputs of a processor P of the type shown in Figure 3 and the resulting output is fed to an output data store M4, where the modulus is extracted and output as a set of 15 frequency components.The arrangement is controlled by a controller sequencer C, which is in turn controlled by the program of Figure 8.This program is similar to that of Figure 6, except that rotations of 1200 approximately are used. The three computed output values are output at lines 20, 38 and 48 respectively.