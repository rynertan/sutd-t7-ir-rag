# Interrupt handler for a digital processing system.

## Abstract
An interrupt handler for a digital processing system includes routines for servicing interrupt requests received from a plurality of interrupt sources 31, 32, 33 . The interrupt servicing routines each interrupt regular processing within the system and perform predetermined work items required to immediately satisfy the received interrupt request. The active servicing routine then identifies and queues individual work items that must be performed to completely satisfy the received interrupt request, but that can be performed at a future time without affecting system performance. Regular processing is then reinstated and the queued work items are executed. By this means, regular processing is interrupted for a minimum amount of time while servicing individual interrupt requests.

## Claims
Claims 1. An interrupt handler for use in a digital processing system including means for receiving interrupt requests from a fixed number of interrupt sources means, responsive to said means for receiving, for identifying and queuing predetermined work items to form a work item queue, said work items to be performed to satisfy said interrupt requests means for stepping through said work item queue means, responsive to said means for stepping through, for executing individual tasks according to each work item. 2. The interrupt handler as recited in claim 1 wherein said means for stepping through said queue is interrupted by said means for receiving interrupt requests. 3. The interrupt handler as recited in claim 1 or 2 wherein said means for executing individual tasks also identifies and queues predetermined work items. 4. The interrupt handler as recited in claim 1, 2 or 3 wherein said work items each have a priority level. 5. The interrupt handler as recited in claim 4 wherein each interrupt source has one of a fixed number of interrupt priority levels. 6. The. interrupt handler as recited in claim 5 wherein the number of work items is greater than or equal to said fixed number of interrupt sources. 7. The interrupt handler as recited in claim 6 wherein the number of work item priority levels is greater than or equal to said fixed number of interrupt priority levels. 8. The interrupt handler as recited in any one of claims 5, 6 or 7 wherein a high priority interrupt request interrupts the stepping through of said work items, but stays only the receipt of a lower priority interrupt request. 9. A method of operating an interrupt driven digital processing system including the steps of receiving an interrupt request and interrupting the regular processing in said system servicing said interrupt request by identifying and queuing predetermined work items to form a work item queue, said work items to be executed to satisfy said interrupt request reinstating regular processing and executing work items in said work item queue during regular processing whereby regular processing is interrupted for a minimum time while servicing said interrupt request. 10. The method as recited in claim 9 wherein said work items in said queue are executed according to predetermined work item priority. 11. A method as recited in claim 10 wherein all high priority work items in queue are executed before any low priority work items in queue. 12. A. method as recited in claim 11 wherein work items are assigned a high priority or a low priority to optimize the performance of said digital processing system.

## Description
Description INTERRUPT HANDLER FOR A DIGITAL PROCESSING SYSTEMThis invention relates to interrupt handlers in digital processing systems, and particularly to an interrupt handler capable of performing work items in satisfaction of individual interrupt requests to optimize an interrupt driven digital processing system.In a typical digital processing system responsive to a plurality of interrupt requests generated by a plurality of interrupt sources, each interrupt request causes the system to cease regular processing and to perform a unique series of processing steps or work items in order to satisfy that particular interrupt request. The initiation of each unique series of work items is done by what is termed in the art, an interrupt handler.In a typical prioritized interrupt system, the interrupt sources are each given a predetermined priority level ranging from high priority to relatively low priority. An interrupt request of a high priority can interrupt regular processing as well as the processing of an interrupt request of a lower priority. Conversely, an interrupt request of low priority can interrupt regular processing but cannot interrupt the processing of an interrupt request of equal or higher priority.As is often the case, each individual work item in the series of work items required to be performed to completely satisfy a given interrupt request may not carry the same urgency as the instigating interrupt request. For example, in a data processing system including a keyboard device with a serial interface between the keyboard and a data processor, the striking of a particular key will send a keyboard frame, comprising a series of individual bits, from the keyboard to the data processor.The receipt of each keyboard frame includes an interrupt request which irltlates an cs servicing routine that performs the following steps the data pin is read and the bit value is stored second the frame bit counter is incremented third, the frame bit counter is read to determine if an entire frame has been received fourth, if an entire frame has not been received, preparation is made to wait for subsequent bits, the receipt of which requires the repetition of steps one through three fifth1 if an entire frame has been received, the frame is processed for use by the data processor.Processing the keyboard frame for use by the data processor typically includes the steps of determining if the frame is a valid frame determining if the information in the frame contains basic commands suca as resend , system reset , or set system trap11 initiating an audible keystroke click and finally, sending the frame to the data proces sor. In addition, a prudently designed system will be able to report device errors should they occur during the processing of a keyboard frame in order to facilitate servicing the system. While these steps are being performed, interrupt requests of equal or lower priority are disabled.Of the steps required to completely satisfy a keyboard interrupt request, only the first few require immediate attention. The others can occur at a time in the future without affecting the performance of the interrupt handler.By requiring the completion of all steps before returning control back to regular processing, a conventional interrupt handler interrupts regular processing for much longer than is actually necessary. Since an interrupt servicing routine cannot be interrupted by another interrupt request of equal or lower priority, this results in inefficient operation of the interrupt driven system.A second problem with existing interrupt handlers is that digital processing systems built using existing hardware are often limited to using a fixed number of interrupt sources as defined by the hardware. Also, the hardware often fixes the number of priority levels assignable to the individual interrupt sources. Certain applications of interrupt driven data processing systems would realize improved performance if the execution of individual work items required to satisfy individual interrupt requests could be organized to optimize a particular system requirement. For example, in a communications adapter with limited local storage, rather than performing work items in series in response to random, asynchronous interrupt requests, it would be beneficial to organize the work items to place a high priority on work items that transmit data from adapter storage, and to place a low priority on work items that accept data into adapter storage. In this manner, a special system requirement, i.e., conserving local storage, would be satisfied and system performance would be optimized. Yet another problem with conventional interrupt handlers is that some work items required to handle a first interrupt request are often the same as the work items required to handle a second interrupt request. Storing these common work items in each interrupt servicing routine results in a waste of storage. For example, in a communications adapter for accepting data from several sources for application to a single host, each data source would be capable of initiating an interrupt servicing routine for transferring data from that individual source to the host. Each interrupt servicing routine would contain a work item wherein data is buffered for transmission to the host.Rather than repeating this work item in each interrupt servicing routine, it would be much preferable to identify a single generic work item to be performed to buffer data for the host regardless of source. This would result in more efficient use of storage. The present invention solves the aforementioned problems present in conventional interrupt handlers by providing an improved interrupt handler having a first stage responsive to individual interrupt requests. The first stage suspends regular processing in response to interrupt reqestsg r c s those work items that require immediate attention, aia then identifies and queues individual work items that may be performed at a future time without affecting system performance. Regular processing is then reinstated and the identified individual work items are performed during regular processing.This improved interrupt handler disables interrupt requests of a given priority for the minimum amount of time while servicing an interrupt request of the same or higher prior In addition, individual work items in the work item queue may be performed at different times as intermediate processing steps to satisfy more than one interrupt request. Since some work items are applicable to satisfy several different interrupt requests and since each work item is stored only once, storage space is minimized. Also, the work item queue can itself be prioritized to ensure the performance of certain work items before other work items.By this means a particular interrupt driven system can be optimized for a particular application.In the preferred embodiment, a hardware system with fixed number of interrupt sources and a fixed number of priorities assignable to those sources is used to construct a work item queue having an arbitrary number of work items with an arbitrary number of priority levels assignable to each work item.In light of the foregoing, it is a primary object of the invention to provide an interrupt handler that holds off interrupt request servicing for a minimum amount of time while servicing an interrupt request of equal or higher priority.Another object of the invention is to provide an interrupt handler capable of performing noncritical work items for satisfying a particular interrupt request at a atime other than when regular processing is suspended.Yet another object of the invention is to provide an interrupt handler capable of identifying and performing individual work items in satisfaction of individual interrupt requests to optimize an interrupt driven system for a particular application.These and other objects and features of the invention will become apparent from the following detailed description in which the preferred embodiment is set forth with reference to the accompanying drawing.Fig. 1 is a hardware communications adapter embodying the present invention.Fig. 2 is a flow chart depicting the flow of control in response to interrupt requests in the circuit of Fig. 1.Fig. 3 is a flow chart of the flow of control in the main control loop during normal processing in the circuit of Fig.1.Fig. 4 is a flow chart of the flow of control during the processing of low priority work items detected in Fig. 3.Fig. 5 is a flow chart depicting the flow of control in the servicing routine for a KEYBOARD RECEIVE INTERRUPT request detected in Fig. 2.Fig. 6 is a flow chart depicting the flow of control in the servicing routine for a KEYBOARD TRANSMIT INTERRUPT request detected in Fig. 2.Fig. 7 is a flow chart depicting the flow of control in the servicing routine for a TIMEOUT TIMER INTERRUPT request detected in Fig. 2. Fig. 8 is a flow chart depicting the flow o c o. c servicing routine for a HOST INTERRUPT request det ect Yx Fig. 2.Fig. 9 is a flow chart depicting the flow of control in the servicing routine for a SPEAKER FREQUENCY INTERRUPT 1 request detected in Fig. 2.Fig. 10 is a flow chart depicting the flow of control in the servicing routine for a SPEAKER FREQUENCY INTERRUPT 0 request detected in Fig. 2.Fig. 11 is a flow chart depicting the flow of control in t servicing routine for a UART INTERRUPT request detected inFig. 2.Fig. 12 is a flow chart depicting the flow of control to perform the work item PROCESS KEYBOARD FRAME detected in Fig.3.Fig. 13 is a flow chart depicting the flow of control to perform the work item INITIATE SYSTEM RESET detected in Fig.3.Fig. 14 is a flow chart depicting the flow of control to perform the work item INITIATE SYSTEM TRAP detected in Fig. 3.Fig. 15 is a flow chart depicting the flow of control to perform the work item PROCESS SERIAL PORT RI detected in Fig.3.Fig. 16 is a flow chart of the flow of control to process the work item CHECK HOST TRANSMIT detected in Fig. 3.Fig. 17 is a flow chart of the flow of control to process the work item PROCESS HOST COMMAND detected in Fig. 4.Fig. 18 is a flow chart of the flow of control to process the work item PROCESS HOST TRANSMIT INFO detected in FIg. 4. Fig. 19 is a low chart of the flow of control to process the work item PROCESS KEYBOARD TRANSMIT detected in Fig. 4.Fig. 20 is a flow chart of the flow of control to process the work item CHECK UART TIMEOUT detected in Fig. 4.Fig. 21 is a flow chart of the flow of control to process the work item CHECK EYLOCK SWITCH detected in Fig. 4. Fig. 22 is a flow chart of the flow of control to process the work item CHECK KEYBOARD RECEIVE COMPLETE detected in Fig. 4.Fig. 23 is a flow chart of the flow of control of the conditional device error enqueueing procedure according to this invention.Fig. 24 is a flow chart of the flow of control of the conditional information code enqueueing procedure according to this invention.Referring to Fig. 1, a communication adapter is disclosed which embodies the subject invention. Generally, the communications adapter controls data communication between host processor 30 and peripheral input output devices such as mouse 31, speaker 32, keyboard 33, and key lock switch 34.Keylock switch 34 is connected to microcontroller 36 by keylock switch line 47. The adapter comprises microcontroller 36, peripheral interface circuit 37, command register 38 and device drivers receivers 39.Microcontroller 36 can be, for example, a 8051 type microcontroller manufactured by Intel Corporation of SantaClara, California and peripheral interface circuit 37 can be, for example, an 8255 type peripheral interface circuit also manufactured by Intel Corporation.Microcontroller 36 is a dedicated microprocessor based system including RAM 40, ROM 45, and universal asynchronous receiver transmitter UART 42. Hicroconrolr ot bs programmed to provide communications ports 43 and t used ts communicate with speaker 32 and keyboard 33, respectively.Port 44 also communicates c with keylock switch 34 through keylock switch line 47 . RAM 40 includes command buffer 41 for receiving host commands from command register 38. The programs disclosed hereinafter reside in ROM 45 and microcontroller 36 is capable of initiating system trap and system reset functions through lines 48 and 49, respectively.The operation and architecture of the 8051 microcontroller is described in Intel Corporation publication number 210359 00B entitled Microcontroller User s Manual which is expressly incorporated herein by reference by way of background material.In operation, microcontroller 36 is susceptible of interrupt requests from a total of five sources with each source assignable to one of either a high priority level or a low priority level. When an interrupt request is received, regular processing within microcontroller 36 is suspended until the interrupt is serviced. A high priority interrupt can suspend regular processing or the processing of any low priority interrupt but cannot suspend the processing of another high priority interrupt. In contrast, a low priority interrupt can suspend regular processing but cannot suspend the processing of any interrupt. In the preferred embodiment, the interrupt requests are initially conditioned by the program depicted in Fig. 2. The five interrupt requests are detected in a known manner by interrupt vectors 50. Interrupt EXTI0 is given a high priority and is accepted from the keyboard. Interrupt TIMER0 is given a low priority and is generated upon overflow of a timer not shown internal to microcontroller 36 Fig. 1 .Interrupt EXTI1 is given a low priority and is accepted from host 30 Fig. 1 . Interrupt TIMER1 is given a low priority and is generated upon overflow of a different timer not shown r,al to microcontroller 36. Finally, interruptSINT is given a low priority and is accepted from mouse 31 viaUART 42 Fig. 1 .When block 50 of the program of Fig. 2 detects an interrupt request, the contents of a program counter are pushed onto stack memory and regular processing is suspended while the proper interrupt servicing routine is executed. Regular processing, as defined within the content of the preferred embodiment, is shown in Figs. 3 and 4 and will be described in detail below.Referring to Fig. 2, if block 50 detects the high priority interrupt EXTI0, control is transferred to decision block 51 where the keyboard transmit mode is sensed. If data is to be received from the keyboard, control is transferred to block 52 to execute the program steps shown in Fig. 5. If data is to be transmitted to the keyboard, control is transferred to block 53 to execute the program steps shown in Fig. 6.If low priority interrupts TIMERO, EXTI1, or SINT are detected by block 50, control is transferred to blocks 54, 56, or 62, respectively, and the program steps shown in Figs. 7, 8, or 11, respectively, are executed.If low priority interrupt TIMER1 is detected by block 50, control is transferred to block 57 where a speaker frequency counter not shown internal to microcontroller 36 Fig. 1 is decremented by 1 . Control is then transferred to decision block 58 to determine if the value of the speaker frequency counter is greater than or equal to zero. If greater than zero, control is transferred to block 59 where the program steps shown in Fig. 9 are executed. If equal to zero, control is transferred to block 61 where the program steps of Fig. 10 are executed.At the completion of each of the servicing routines shown inFigs. 5 11, the regular program count is popped from stack memory and placed back into the program POblpGr regular processing can continue.Referring now to Fig. 3, when the communications adapter sh in Fig. 1 is reset, for example, when power Ls initially applied to the system, control will reside in reset block 63.Control is then transferred to block 64 where system diagnostics are performed and where certain initialization procedures are followed. Control is then transferred to block 66 where the main processing loop is entered.Generally, regular processing in the adapter of Fig. 1 is occupied by checking the status of each bit of twelve bit work queue register 46 shown in Fig. 1 within RAM 40 The sequence of checking the work queue register is co lmanded by the programs shown in Figs. 3 and 4. Work queue register 46 is divided into six high priority work item bits and six low priority work item bits. When checking the work item bits, each high priority work item bit is checked before the first low priority bit. Then each high priority bit is again checked before the second low priority bit, and so forth.In detail, the main loop is started with control in decision block 67 where it is decided if any high priority work items, represented by high priority bits in work queue register 46 Fig. 1 , are in queue. If there are no high priority work items in queue, control is transferred to block 68 where the first low priority work item is checked. The operation of block 68 is described in detail below with reference to Fig.4.If decision block 67 discovers high priority work items in queue, control is transferred sequentially to decision blocks 69 73. If decision block 69 detects that the first high priority work queue bit WQH0 is set, control is transferred to block 74 and the program steps shown in Fig. 12 are executed.Control is then looped back to decision block 67 to decide if any more high priority work items are in queue. If decision block 69 detects that work queue bit WQHO is not set, control is transferred to decision block 70 where work queue bit WQH1 is checked. If bit WQH1 is present, control is transferred to block 75 where the program steps shown in Fig.13 are executed. As will be described in detail with respect to Fig. 13, processing is eventually aborted in block 75 and control is not returned to block 67.In a manner similar to the operation of decision block 69, decision blocks 71 73 check the status of high priority work queue bits WQH2, WQH4 and WQH5, respectively. If the respective work queue bits are detected by blocks 71 73, control is transferred to blocks 76 78, respectively, to execute the program steps shown in Figs. 14 16, respectively.Here it should be noted that the preferred embodiment does not use high priority work queue bit WQH3. This is because only five high priority work items are necessary to satisfy the specific requirements of the preferred embodiment. This fact, and the fact that a twelve bit work queue register is used with six high priority bits and six low priority bits should not be construed to delimit the invention in any manner. It will be understood by a skilled artisan that the present invention can be used to enqueue work items of an arbitrary number. In addition, the fact that only two work item priority levels are described in the preferred embodiment will not be construed to place limitations on the invention. One skilled in the art will appreciate that any number of work item priority levels may be used without departing from the spirit and scope of the present invention.Referring now to Fig. 4 to describe low priority work queue bit checking, control begins in block 81 having been transferred from block 67 of Fig. 3. Control is transferred to block 82 where the value of the work queue low pointer is determined. The work queue low pointer is an integer having a value of from 0 to 5. During system initialization Block 64,Fig. 3 , the work queue low pointer is set to ot so that the first time decision block 82 is addressed conb ji e transferred to decision block 83 where the status of w priority work queue bit WQL0 is checked.If bit WOLO la detected, control is transferred to block 84 where the processing steps shown in Fig. 17 are performed.After block 84 is finished, control is transferred to block 86. If decision block 83 does not detect the presence of bitWQL0, control is transferred directly to block 86 without first activating block 84. Block 86 then increments the value of the work queue low pointer by 1 so that it now holds the value 1 . Control is then transferred from block 86 to block 67 Fig. 3 for continued processing.The next time the routine of Fig. 4 is activated by block 67 of Fig. 3, decision block 82 will decode work queue low pointer to be the value 1 and will transfer control to block 87 to check the status of low priority work queue bit WQL1. If bit WQL1 is detected, control is transferred to block 88 for executing the program steps shown in Fig. 18. Else, control is transferred directly to block 86 for incrementing the work queue low pointer. After block 88 completes execution, control is also transferred to block 86. Block 86 then increments the work queue low pointer to the value 2 . Each time block 86 is activated, the work queue low pointer is incremented by 1 . If the pointer holds the value 5 , block 86 rolls the pointer over to the value 0 . By this means, each time block 67 of Fig. 3 activates the WORKQ LOW TEST routine of Fig. 4, only one low priority work queue bit is checked depending on the value of the work queue low pointer.If the work queue low pointer is decoded by block 82 to be the value 2, 3, 4, or 5, control is transferred to blocks 89, 90, 91, or 92, respectively where low priority work queue bitsWQL2, WQL3, WQL4, or WQL5, respectively, are checked. If the respective work queue bits are detected, blocks 89 92 transfer control to blocks 93 96, respectively, to execute the program steps shown in Figs. 19 22, respectively. If the respective work queue bits are not detected, decision blocks 89 92 LLt 0n.E control directly to block 86 for incrementinq the work queue low pointer.As a result of the foregoing, the main programming loop shown in Figs. 3 and 4 checks work queue register 46 Fig. 1 in a predetermined priority sequence and performs work items corresponding to detected work queue bits. The main loop ofFigs. 3 and 4 is interrupted during the servicing of interrupt requests as shown in Fig. 2.The individual work queue bits in work queue register 46 are set and reset by interrupt servicing routines shown in Figs.5 11 as well as by work item routines shown in Figs. 12 22, and by conditional routines shown in Figs. 23 and 24.Referring to Fig. 5, intererupt servicing routineKEYBOARD INTERRUPT is shown. This routine is activated when microcontroller 36 of Fig. 1 receives the high priority interrupt request EXTI0 indicating that a bit of a keyboard frame is being sent from keyboard 33 to microcontroller 36.Control begins at block 100 where the keyboard data pin is read and the value is stored in a keyboard frame buffer. A keyboard frame bit counter is then incremented and control is transferred to decision block 101 to determine the count of the keyboard frame bit counter. If the frame bit counter is la, indicating that the first bit of a frame has been received, control is transferred to block 105. Block 105 sets low priority work queue bit WQL5 and then returns control to regular processing. If the frame bit count is between 2 and 10, block 101 causes the servicing routine to be exited immediately and regular processing is reinstated.If block 101 detects that the frame bit count is 11, indicating that an entire frame has been received, control is transferred to block 102 and then to 103 where work queue bitWQH0 is set and bit WQL5 is reset, respectively. Control is then transferred to block 104 where the device error DE routine of Fig. 23 is executed. The servicing routine is e exited and regular processing is reinstated.Here it should be noted that instead of interrupting regular processing while receiving and processing a frame of bits from the keyboard, the present invention interrupts regular processing only as long as it takes to read and store each individual bit within the frame. All other work items required to be completed to receive a keyboard frame are deferred until regular processing is reinstated so that the communications adapter can be more responsive to other interrupt requests.Referring now to Fig. 6, the interrupt servicing routineKEYBOARD TRANSMIT INTERRUPT is shown. This routine is activated when microcontroller 36 of Fig. 1 receives the high priority interrupt request EXTI0 indicating that keyboard 33 is ready to receive a bit of data from microcontroller 36.Here, control begins at block 106 where a data bit is written to the keyboard data pin and the keyboard fr ame bit counter is incremented. Control is then transferred to decision block 107 where the value of the frame bit counter is determined.If the value is from 1 to 11, the servicing routine is exited and regular processing is reinstated. If the frame bit counter is greater than 11, indicating that the entire frame has been transmitted to the keyboard, control is transferred to block 108 where a status bit WAIT KEYBOARD TRANSMITCOMPLETE, indicating that a keyboard transmission is in process set in Fig. 19 , is reset. The servicing routine is then exited and regular processing is resumed.Referring now to Fig. 7, the TIMEOUT TIMER INTERRUPT servicing routine is shown. This routine is activated when microcontroller 36 of Fig. 1 receives the low priority interrupt TIMER0 indicating that the time increment of a speaker tone has expired and that the speaker should be turned off if no other time increments remain. Control begins in block 109 where a speaker duration counter is sensed. If the value of the counter is greater than 0 , control is transferred to block 111 where the duration counter is decremented by 1 and control is returned to regular processing. If block 109 detects that the duration counter has reached 0 , control is transferred to block 112 where the speaker is stopped and where the microcontroller interruptsTIMER0 and TIMER1 are disabled.Control is then transferred to block 113 where the conditional information code IC procedure of Fig. 2t is executed. Regular processing is then reinstated. This routine allows a number of time increments, equal to the number initially stored in the duration counter, to expire before stopping the speaker request thereby extending the timing capabilities of internal timer TIMERO. Referring to Fig. 8, the HOST INTERRUPT servicing routine is detailed with control beginning in block 114. This routine is activated when microcontroller 36 of Fig. 1 receives low priority interrupt request EXTI1 indicating that host 30 wishes to send data to microcontroller 36. Block 114 reads command register 38 as well as host generated data from peripheral interface circuit 37 both shown in Fig. 1 .Control is then transferred to block 116 where low priority work queue bit WQL0 is set. Microcontroller interrupt EXTI0 is then disabled by block 117 before control is returned to regular processing. Figs. 9 and 10 show the interrupt servicing routines forSPEAKER FREQUENCY INTERRUPT 1 and SPEAKER FREQUENCY INTERRUPT 0, respectively. Each are activated when microcontroller 36 of Fig. 1 receives low priority interrupt request TIMER1 indicating that the signal sent to the speaker should be complimented. In the INTERRUPT 1 routine a speaker frequency timer is reloaded by block 118 before control is returned, whereas in the INTERRUPT 0 routine, the speaker frequency pin is complemented by block 119 and then the speaker frequency timer is reloaded by block 121 before returning control to regular processing. These routines drive speaker 32 Fig. 1 with a square wave by timing half a square wave period before complementing the speaker pin and t iminq another half period.Since counter 58 of Fig. 1 only activates the complementing routine INTERRUPT 0 when the frequency count equals 0 , number of time increments, equal to the count initially stored in the frequency counter, can expire before complementing the speaker frquency pin thereby extending the timing capabilities of internal timer TIMER1.The final interrupt servicing routine is the UART INTERkUPT routine shown in Fig. 11. This routine is activated u microcontroller 36 of Fig. 1 receives low priority interruptSINT indicating that a frame of data is to be sent to or received from mouse 31 by UART 42. Control begins in decision block 122 where it is determined if a UART receive interrupt has been received. If so, control is transferred to block 123 where the data is read from the UART and where microcontroller interrupt SINT is disabled. Control is then passed to block 124 where high priority work queue bit WQH4 is set. Control is then transferred to block 126 where the low priority work queue bit WQL3 is reset before returning control back to regular processing.If decision block 122 determines that a UART receive interrupt has not been received, control is transferred to decision block 127 to determine if a UART transmit interrupt has been received. If not, control is transferred to block 128 to perform the DE routine of Fig. 23 before reinstanting regular processing. Else, control is passed to block 129 where transmit controls are updated to reflect the received interrupt before transferring control to block 130 for executing the IC routine. Control is then transferred to block 126 to reset bit WQL3 before returning control to regular processing.Figs. 12 22 show the eleven work item routines of the preferred embodiment. These work items are performed during regular processing as determined by work queue register 46 Fig. 1 which is interrogated by the programs of Figs. 3 and 4 described earlier. These work items are required to be performed to completely satisfy the five interrupt requests.However, it has been determined that these eleven work items can be performed at a time later than the performance of the respective interrupt servicing routines Figs. 5 11 . Here it should be noted that the work queue bits in work queue register 46 corresponding to each work item can be set and reset by an interrupt servicing routine Figs. 5 ll , or by the execution of an individual work item Figs. 12 22 , or by the conditional routines Figs 23, 24 .The priority of performance of each individual work item is chosen to optimize system performance. For example, within the environment of the communications adapter of the preferred embodiment, blocks 74 and 77 of Fig. 4, representing the routines of Figs. 12 and 15 respectively, are given high priority in order to clear the frame buffers contained withinUART 42 and port 44 Fig. 1 as soon as possible. This practice avoids collisions between data presently stored in the frame buffers and incoming data. On the other hand, blocks 84 and 95 of Fig. 4, representing the routines of Figs. 17 and 21, respectively, are given low priority. In the case of the PROCESS HOST COMMAND routine of Fig. 17, host 30 ofFig. 1 is an intelligent source that can recognize that microcontroller 36 is not ready to receive a command and can defer sending that command. Similarly, keylock switch 34 ofFig. 1 is a mechanical switch that is capable of being actuated much slower than the possible sampling rate of microcontroller 36. Therefore, sampling keylock line 47 in the routine of Fig. 21 can be delayed without affecting system performance.Referring to Fig. 12, work item PROCESS KEYBOARD FRAMF is shown which is activated when block 69 of Fig. 3 determines that high priority work queue bit WQH0 is set. Control begins in block 131 where work queue bit WHQ0 is reset. Block 132 then resets the frame bit counter before passing control Eo decision block 133. Block 133 determines if it is the proper time to process the keyboard frame. If not, control is transferred to block 134 where the controls are updated for keyboard receive mode. If it is the proper time to process the keyboard frame, control passes from block 133 to block 136 where it is decided if a valid fr ame has been received from the keyboard. If not, control is transferred to block 137.Blocks 137, 135, and 139 are then executed to send a resent command to the keyboard. In the process, block 139 sets low priority work queue bit WQL2.If a valid frame has been received, control passes from block 136 to block 138 to determine if the keyboard frame contains a resend request from the keyboard. If it does, control is transferred to the series of blocks 141, 142, and 143 where the previous frame transmitted to the keyboard is prepared to be retransmitted. In the process, block 143 sets low priority work queue bit WQL2.If block 138 determines that the frame does not contain a resend request, control passes to block 144 where it is determined if keyboard acknowledgement is required. If acknowledgement is required, control passes to the series of blocks 146, 147, 148, and 149 where the keyboard response is queued for transmission to the host. During this response queueing, block 147 sets low priority work queue bit WQL1.Block 149 then passes control to block 134 before returning control back to the main loop of regular processing.If acknowledgement is not required, block 144 passes control to block 151 to determine if, even though acknowledgement is not required, acknowledgement has been received. If yes, control is transferred to block 152 to execute the DE routine of Fig. 23. If the keyboard has not sent an acknowledgement, control passes from block 151 to decision blocks 153 and 154 to determine if special keystroke sequences A or B have been received. If block 153 determines that keystroke sequence A has been received, control passes to block 155 where high priority work queue bit WQH2 is set. If block 154 determines that keystroke sequence B has been received, control passes to block 156 where high priority work queue bit WQH1 is set.Control then passes to block 157 where the keyboard frame is queued for transmission to the host and where an audible key click is generated. Control then passes to block 158 for execution of the IC routine of Fig. 24, and then to block 159 where the low priority work queue bit WQL1 is set. Control then passes to block 134 and then back to block 67 of Fig. 3.Special keystroke sequence B is used in the preferred embodiment as a user request for a system reset, and special sequence A is used as a user request to set a system trap.Figs. 13 and 14 show the work items for INITIATE SYSTEM RESET and INITIATE SYSTEM TRAP activated by the work queue bits WQH1 and WQH2, respectively. In Fig. 13, block 161 activates system reset line 49 on microcontroller 36 Fig. 1 . Block 162 then resets work queue bit WQHl. Processing is then aborted. In Fig. 14, block 163 resets work queue bit WQH2 and block 164 activates system trap line 48 of microcontroller 36 Fig. 1 . Control is then returned to block 67 of Fig. 3. Fig. 15 shows the work item PROCESS SERIAL PORT RI which is activated when block 72 of Fig. 3 determines that high priority bit WQH4 is set.Block 166 resets bit WQH4 and passes control to decision block 167 to determine if it is the proper time to process the UART frame. If not, control is passed to block 175 where the SINT interrupt of microcontroller 36 Fig. 1 is enabled before returning control back to block 67 of Fig. 3.If block 167 determines that it is the proper time to process the UART frame, control is transferred to block 168 where it is determined if a valid frame has been received from the UART. If yes, control passes to block 169 where t information received from the UART is queued for transmiss n to the host. If not, control passes to block 175 fo operation identical to that described above.After block 169 queues the UART information for transmission to the host, control is transferred to block 170 where low priority work queue bit WQL1 is set. Control then passes to block 175 and then control returns to block 67 of Fig. 3.Referring now to Fig. 16, the work item CHECK HOST TRANSMIT is shown. This work item is activated when block 73 of Fig 3 recognizes that bit WQH5 of work queue register 46 Fig. 1 is set.Control begins in block 171 where it is determined if the previous transmission to the host has been accepted. If not, control is immediately returned to block 67 of Fig. 3. If the previous host transmission was accepted, control is transferred from block 171 to block 172 where work queue bitWQH5 is reset.Control then passes to block 173 to determine if a new host transmission is ready. If yes, control is transferred to block 174 where source identification and data are written to the pins of peripheral interface circuit 37 Fig. 1 . Control then passes to block 176 where work queue bit WQH5 is set.Control is then transferred to decision block 177 which is where control is directly transferred if decision block 173 determines that there is no new host transmission ready.If decision block 177 determines that the UART block is ready for transmission, control is transferred to block 178 where the UART block byte is dequeued and made ready for transmission to the host. If decision block 177 determines that the UART block is not ready for transmission, control passed to decision block 179 where it is determined if a RAM block is ready for transmission to the host. A RAM block is a plurality of bytes stored in RAM 40 of Fig. 1 containing n orma ticn that can be requested by and sent to host 30. For example, a block of bytes in RAM 40 can be used to store a history of device errors that can be usedby host 30 for diagnostic purposes. If a RAM block is not ready for transmission, control is immediately returned to block 67 ofFig. 3.If yes, control passes from block 179 to block 181 where the RAM block is dequeued and made ready for transmission to the host. When the work itemCHECK HOST TRANSMIT is completed, control passes to block 67 of Fig. 3.Fig. 17 shows the work item PROCESS HOST COMMAND which is initiated when block 83 of Fig. 4 recognizes the presence of low priority work queue bit WQL0. Control begins in block 182 where bit WQLO is reset before passing control to decision block 183 where the host command is decoded. Block 183 then activates one of blocks 184 to perform the proper function to satisfy the decoded host command. Control then passes to block 186 where the proper host command response is made ready for transmission back to the host. Block 187 then sets high prior,ity work queue bit WQH5 and passes control to block 188 where microcontroller 36 Fig. 1 interrupt EXTI1 is enabled.Control is then returned to block 86 of Fig. 4.Fig. 18 shows the work item PROCESS HOST TRANSMIT INFORMATION which is activated when decision block 87 of Fig.4 recognizes the presence of low priority work queue bit WQL1.Control begins in decision block 189 where the availability of the host data transmission buffer is checked. If the buffer is not available, control is immediately returned to block 86 of Fig. 4. If the buffer is available, data can be accepted from one of five different sources within microcontroller 36 Fig. 1 . This data includes a device error code a UART block a keyboard byte an information code or a RAM block.These data sources are checked in this priority order by decision blocks 191 195. When one of decision blocks 191 195 detects the presence of queued data from the respective source, control is transferred as shown to one of bloo. t s 196 200, respectively. If none of decision blocks l91 indicates that data is queued for transmission to the hose, processing is aborted.When the active one of blocks 196 200 finishes dequeueing data to the host transmission buffer, control passes to block 201 where high priority work queue bit WHQ5 is set. Control then passes to block 202 where it is decided if work queue bit WQL1 should remain set. If other data remains to be transmitted to the host, bit WQLl remains set. Otherwise, bit WQL1 is resetsControl is then passed to block 86 of Fig. 4.Fig. 19 shows the work item PROCESS KEYBORRD T.R NSHIT which is activated when block 89 of Fig. 4 determines that work queue bit WQL2 is set. Control begins in block 203 where it is determined if it is the proper time to transmit data to the keyboard. If not, execution of the work item is stopped and control passes to block 86 of Fig. 4. If block 203 decides affirmatively, control passes to block 204 where request to send protocol is initiated between microcontroller 36 and keyboard 33 both shown in Fig. 1 . The DE routine of Fig. 23 is then executed to report errors discovered by block 204.Then, work queue bit WQL2 is reset by block 205.Block 206 then sets status WAIT KEYBOARD TRANSMIT , COMPLETE and passes control to block 207 where request to send protocol is completed. The DE routine is again executed and then block 208 awaits for the status bitWAIT KEYBOARD TRANSMIT COMPLETE to be reset by the interrupt servicing routine of Fig. 6 indicating that the transmission to the keyboard is complete.The DE routine is then executed again, followed by an update of the keyboard interface status by block 209, followed by another execution of the DE routine. When work item PROCESS KEYBOARD TIIANSMIT is completed, control passes to block 86 of Fig. 4. Fig. 20 shows the work item CHECX UART TIMEOUT which is activated when decision block 90 of Fig. 4 detects that low priority work queue bit WQL3 is set. Control begins in block 211 where a UART wait counter is decremented by one. Decision block 212 then reads the UART wait counter and returns control to block 86 of Fig. 4 if the count is greater than zero. If the count is equal to zero, indicating that there may be a problem with UART 42 Fig. 1 , block 212 passes control to block 213 where work queue bit WQL3 is reset. The DE routine is then executed to report the potential UART problem to the host. This signifies completion of work itemCHECK UART TIMEOUT and control returns to block 86 of Fig. 4.Fig. 21 shows the work item CHECK KEYLOCK SWITCH which is activated when decision block 91 of Fig. 4 recognizes the presence of low priority work queue bit WQL4. Control begins in block 214 where the keylock switch line 47 Fig. 1 is sampled. Control is then passed to block 216 where the status of the keylock switch is calculated. The IC Fig. 24 routine is then executed to prepare the keylock status for reporting to the host. Control is then passed to block 86 of Fig. 4. Fig. 22 shows the work item CHECK KEYBOARD RECEIVE COMPLETE which is activated by decision block 92 recognizing that low priority work queue bit WQL5 is set.Control begins in block 217 where a keyboard wait counter is decremented. Decision block 218 then determines the value of the keyboard wait counter and returns control to block 86 ofFig. 4 if the count is greater than zero. If the count is zero, indicating there may be a device error in keyboard 33 Fig. 1 , control is transferred to block 219 where the work queue bit WQLS is reset. The DE routine is then executed to prepare the keyboard device error for reporting to the host.The keyboard interface is then cleared, including changing the keyboard mode to receive , in block 220 and control is returned to block 86 of Fig. 4. Figs. 23 and 24 shows the conditional device error DE an information code IC enqueueing routines, respectiveiL These routines are called periodically throughout the abo described interrupt servicing routines Figs. 5 11 and wor items Figs. 12 22 to report device errors or informatios codes to the host.Control begins in the DE routine in Fig. 23 at decision block 221 where it is determined if any device errors are to be reported. If not, control is returned to the higher leve program that called the DE routine. If a device error is tt be reported, control passes to block 222 where the errer cs is queued for transmission to the host. Block 223 then set low priority work queue bit WQL1 and returns control to thf higher level program.The IC routine of Fig. 24 begins with control in decisio block 224 to determine if any information codes requir reporting. If not, control is immediately returned to th higher level program that called the IC routine. If ar information code is to be reported, control is passed fro block 224 to block 226 where the information code is queue for transmission to the host. Control then passes to bloc 227 where the low priority work queue bit WQL1 is set. The I routine is then complete and control returns to the highe level program that called the IC routine. It will be understood that the preferred embodiment herei presented is for illustrative purposes, and, as such, will nc be construed to place limitation on the invention. ThoE skilled in the art will understand that changes in the for and detail of the preferred embodiment herein disclosed may L made without departing from the spirit and scope of t invention.