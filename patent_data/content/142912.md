# CODE DETERMINATION USING HALF ADDER BASED OPERAND COMPARATOR

## Claims
Ein Datenverarbeitungssystem mit Speichervorrichtung, Befehlsverarbeitungsvorrichtung und Befehlsausf端hrungsvorrichtung, wobei das System Datenverarbeitungen unter der Steuerung von Befehlen durchf端hrt, die Operationscode zum Angeben von auszuf端hrenden Operationen und Operanden Felder zum Erkennen von Operanden aufweisen, die bei der Ausf端hrung der Operationscode zu verwenden sind, und wobei Befehle in Segmenten verarbeitet werden, wo jedes Segment eine Dauer gleich einem oder mehreren Taktzyklen aufweist, umfassend

## Description
The present invention relates to the field of instruction controlled digital computers and specifically, to the processing of condition code setting instructions and branch on condition instructions, such as defined, for example, by OS 370 architecture. Branch on condition instructions are an important part of the data processing system. The manner in which these instructions are processed is an important factor in the cost and performance of the system because such instructions are statistically common instructions in programs. According to these existing systems, when branch instructions are processed, they require the interrogation of a condition code CC , which is set by a previous condition code setting instruction, to determine which of the two instruction streams will be thereafter followed. In a pipelined environment, the branch on condition instruction will start execution before the completion of execution of the condition code setting instruction. The condition code setting instruction should determine the condition code as soon as possible because if it does not, processing of the branch instructions may be delayed until the condition code is set. Any delay in instruction processing, of course, deleteriously affects the performance of the data processing system. U.S. Patent 3,881,173 describes a method and apparatus for use in a data processing system wherein the condition code upon which a branch instruction acts is set as a function of the condition code setting instruction and a related comparison of the operands of the instruction. The condition code can be calculated before the completion of the execution of the condition code setting instruction. The criteria for comparing the operands are determined by the instruction being executed. In that patent, means are provided within the execution unit for decoding the OP code of an instruction and controlling a comparator within the execution unit for selecting an appropriate comparison criteria for comparing the operands. The operands are concurrently gated into the comparator and a determination is made to set the condition code. The condition code is set within one cycle of the data processing system, or two cycles for double word processing, independently of how many execution cycles are required for a complete execution of the instruction. When a branch instruction interrogates the condition code latch and determines that a branch is to be taken, the branch instruction immediately causes the instruction processing pipeline to be cleared of any instructions in the non taken instruction stream and commences immediately to process instructions in the to be taken instruction stream. While the comparison carried out by the method of patent 3,881,173 has proved to be very satisfactory, there is still a need for an improved comparator capable of high speed at low cost. The design of a half adder HA unit, and the means of implementing the functions thereof, are disclosed in E.L. Johnson and M.A. Karim, The present invention provides a data processing system as set out in claim 1. The operand comparator forms comparison results in the form of Carry out predictions indicated in parentheses simultaneously for one or more of the following types of additions The Logical Compare uses the carry outs TC and CT. The Logical Addition uses the carry outs BOZ, TT and CC. The Logical Subtraction uses the carry outs CT and TC. The Algebraic Compare Signs Equal uses the carry outs TC and CT. The Algebraic Compare Signs Different uses the carry outs TC and CT. The Logical Exclusive OR uses the carry outs TC and CT. The Algebraic Addition Signs Equal uses the carry outs TT and BOZ. The Algebraic Addition Signs Different uses the carry outs TT and CC. The Algebraic Subtraction Signs Equal uses the carry outs TC and CT. The Algebraic Subtraction Signs Different uses the carry out CT. Refer to Chart 4 for a detailed description. The carry outs for 31 bit operands are derived from the 32 bit operands by dropping the highest order bits. The 31 bit carry out predictions are used for floating point short compares and for determining overflow in algebraic additions and subtractions. The comparator has the ability to predict a carry out if both operands are two s complemented, and hence have two carry ins. This processing of two carry ins simultaneously with two operands provides a high speed comparison which enhances the speed of the comparator. In accordance with the above summary, the present invention achieves the objective of providing an improved apparatus, using an improved half adder operand comparator, for setting codes in a data processing system. The present invention can also be used for internal control of the execution unit. The internal controls include tests for operands equal, OP1 less than OP2, and quotient overflow for fixed point divide. Additional objects and features of the present invention will appear from the following description in which the preferred embodiments of the invention have been set forth in detail in conjunction with the drawings. FIG. 1 depicts a schematic representation of a data processing system including an operand comparator. FIG. 2 depicts a schematic block diagram of the operand comparator utilized in the FIG. 1 system. FIG. 3 depicts a further detailed block diagram of the operand comparator of FIG. 2. FIG. 4 depicts a logic diagram of a bit slice which forms part of the FIG. 3 comparator. FIGS. 5 through 9 each depict logic diagrams which form intermediate logic blocks which combine signals from the bit slice logic blocks of the FIG. 4 type. FIG. 10 is a logic diagram of outputs from the intermediate blocks of FIGS. 5 through 9 and forms the output for three half adders TT, TC, CT represented in FIG. 2. FIGS. 11, 12, and 13 represent the final accumulation logic for the fourth half adder CC represented in FIG. 2. FIG. 14 represents the intermediate and final accumulation logic blocks for determining when the logical AND of the operands is non zero. In FIG. 1, a data processing system includes a memory unit 1, an execution unit 2 and instruction unit 3. Memory unit 1 is a generalized memory which typically includes main store, buffer store and architecturally defined internal registers. Instructions are fetched from the memory unit 1 by the instruction unit 3 and are sequentially executed in an instruction pipeline 4. The execution unit 2 includes the OWRL register 11 which holds the first operand, OP1, and the OWRH register 12 which holds the second operand, OP2. The first and second operands are used by the additional execution unit hardware 9 in the execution of the instruction. Some condition code setting instructions take many E cycles for complete execution. It is often desirable to know certain properties e.g., operands are equal, one operand is greater than the other about the results of the execution prior to the time that the actual execution is completed in order to set the condition code early. If a branch on condition instruction follows this instruction, the branch can be determined early and time is not wasted on the execution of the unselected instruction stream. In FIG. 1, the operand comparator 34 compares OP1 and OP2 at an early time. The comparator 34 supplies comparison results to the condition code setting logic 26 which sets the condition code register 27 1, and also sets other registers 27 2,..., 27 P for internal control of the execution unit 2. The outputs from the half adders 14 through 17 and logic block 18 of FIG. 2 are summarized in the following CHART 1 Each of the first seven outputs listed above is logically true if there is a carry out from the indicated addition. K32CC is logically false if there is a carry out of two from that addition. One detailed implementation of the comparator 34 involves partitioning the 32 bit operands into eight slices of four bits each. Information is computed from each slice and then assembled to form the outputs listed above in CHART 1. In FIG. 2, a schematic representation of the operand comparator 34 of FIG. 1 is shown. The operand comparator 34 includes four half adders 14, 15, 16, and 17 and a logic block 18. Each of the half adders 14 through 17 and the logic block 18 receives as inputs OP1 and OP2 from the registers 11 and 12, respectively, of FIG 1. The complements are generated by the inverters 22, 23, 24, and 25 in FIG. 2. The half adder 14 receives the true values of both OP1 and OP2. Accordingly adder 14 has the labels T and T on its inputs. The half adder 15 receives the true input for OP2 and the complement input for OP1 and hence its inputs are labelled T and C, respectively. The half adder 16 receives the complement input for OP2 and the true input for OP1 and hence its inputs are labelled C and T, respectively. The half adder 17 receives the complement input for both OP1 and OP2 and hence has its inputs labelled C and C. The half adders 14 through 17 of FIG. 2 generate carry outs but do not perform a full addition. Specifically, the TT half adder 14 generates the carry out for the 31st bit designated as K31TT and generates the carry out for the 32nd bit designated as K32TT. Similarly, the TC half adder 15 generates the outputs K31TC and K32TC. The CT half adder 16 generates the outputs K31CT and K32CT. Finally, the CC half adder 17 generates a K32CC output. The output K31CC not shown is not generated by the half adder 17 but such an output can be readily generated if desired. The outputs from the half adders 14 through 17 and from logic block 18 are provided as inputs to the condition code setting logic 26 of FIG. 1. Instruction pipeline 4, in one typical embodiment, includes a plurality of segmented stages. For example, the G stage 4 1 generates the memory addresses of the operands to be processed by the instruction. The B stage 4 2 accesses the operands from the memory unit. The L stage 4 3 performs logical and checking operations on the operands. The E stage 4 4 controls the execution of the instruction. The W stage 4 5 writes the results of the execution into memory. The stages in the pipeline 4 are shown as representative. Additional or other stages can be employed. For additional stages which are frequently employed, reference is made to U.S. Patent 3,881,173 which describes an instruction pipeline with multiple stages. An example of how instructions are sequenced is given in the following CHART 2 In CHART 2, an instruction stream including instructions I1, I2, I3, I4, ..., I9 is shown. A first instruction, I1, is fetched by the I unit 3 and is processed by the G stage 4 1 during cycle CYC1. During cycle CYC2, the I1 instruction is processed by the B stage 4 2. In a similar manner the I1 instruction is processed by the L stage 4 3, E stage 4 4 and the W stage 4 5 at cycles CYC3, CYC4 and CYC5, respectively. The second instruction I2 in the instruction stream is a condition code setting instruction which is processed by the G stage 4 1 during CYC2. The I2 instruction is processed by the instruction pipeline so that it appears in the B, L, E and W stages at CYC3, CYC4, CYC5, CYC6, respectively. Since instruction I2 is a condition code setting instruction, one example representing the processing is as follows. During CYC2, the G2 stage determines the addresses for OP1 and OP2. During CYC3, the B2 stage accesses OP1 and OP2 from memory unit 1 and clocks them into the OWRL register 11 and the OWRH register 12, respectively at the end of CYC3. After OP1 and OP2 have been clocked into the registers 11 and 12 and at the end of CYC3, the operand comparator 34 of FIG. 1 commences the comparisons of OP1 and OP2. The L stage 4 3 controls the condition code setting logic 26 to set the CC register 27 1 at the end of CYC4. The outputs from the CC register 27 1 and other execution unit status are sent back to the I unit 3 for use in controlling the branch decision and interrupts. Referring to CHART 2, it is assumed for purposes of explanation that the instruction I3 is a branch on condition instruction. The condition code determining whether or not to branch is set by the instruction I2 as previously explained. In cycle CYC3, the I3 instruction is processed by the G stage 4 1. Since the condition code register 27 1 is set at the end of CYC4 by I2, the branch decision cannot be made prior to cycle CYC5. Therefore, the I unit 3 causes a delay in the processing of the instruction I3 to line up CYC5 with B3. This delay is represented in CHART 2 by a repeat of the G stage G3, which appears during CYC4. If the branch is taken, then the G9 segment of the target instruction I9 will be processed during cycle CYC6 and segment B4 of I4 will be cancelled. If the branch is not taken then the B4 segment of the next instruction, I4, is processed during CYC6. If the condition code cannot be set at the end of the CYC4 by I2, both G4 if branch is not taken or G9 if branch is taken will be delayed by as many additional cycles as it taken to set the condition code by I2. In the case that the condition code is set from the result of the I2 execution, it will be set at the end of cycle CYC5 at the earliest. Either G4 or G9 will be delayed by one cycle. In FIG. 3, a detailed implementation of comparator 34 for 32 bit operands, is shown. The eight 4 bit slices are represented by the eight logic blocks 36 0, 36 1,...,36 7. In FIG. 3, each of the 4 bit slices receives four of the bits of each of the input operands OP1 and OP2. For example, block 36 0 receives the four input bits 0, 1, 2, and 3 for each operand. Block 36 1 receives the four input bits 4, 5, 6, and 7 and so on until block 36 7 receives the inputs 28, 29, 30 and 31. Each of the blocks 36 0 through 36 7 includes four 1 bit slices. For example block 36 0 includes the 1 bit slices 37 0, 37 1, 37 2, and 37 3. In FIG. 3, each of the eight blocks 36 0 through 36 7 provides outputs to a corresponding intermediate block 38 0, 38 1,...,38 7 and to an intermediate block 40. Each of the blocks 38 0 through 38 7 in turn includes five sub blocks. For example, the block 38 0 includes the sub blocks 39 0, 39 1,...,39 4. The outputs from the blocks 38 0 through 38 7 connect as inputs to the final accumulation blocks which are the TT block 40 1, the TC block 40 2, the CT block 40 3 and the CC blocks 42 and 43. In FIG. 3, the intermediate block 40 provides outputs to the output block 44 which determines when the AND of OP1 and OP2 is non zero. In FIG. 4, a 1 bit slice 37 0 of the block 36 0 of FIG. 3 is shown as a typical one of the 32 one bit slices. The FIG. 4 bit slice is labelled with the inputs OP2 BITm,n and OP1 BITm,n. The letter m has the values 0,...,3 and therefore the FIG. 4 bit slice represents the four bit slices 37 0 through 37 3 within the block 36 0 of FIG. 3. The letter n has the values 0, 1...,7 and therefore the bit slice of FIG. 4 also represents the bit slices for each of the eight blocks 36 0 through 36 7, each in turn having m equal to 0,...,3. Accordingly, there are 32 bit slices of the FIG. 4 type in the FIG. 3 embodiment. In FIG. 4, gate 51 provides the true and complement outputs for the input bit OP2 BITm,n. Similarly the gate 52 provides the true and complement outputs for the input bit OP1 BITm,n. The gates 53 1 through 53 7 provide various logical combinations of the OP1 and OP2 input bits. The logical combinations in FIG. 4 are summarized in the following TABLE 1. In TABLE 1, the inputs shown in the left hand column and the outputs shown in the right hand column correspond to the inputs and the outputs in FIG. 4. In TABLE 1, the comment explaining the significance of the output term appears in parentheses. Note that the value of m in TABLE 1 is equal to 0,1,2 and 3 and the value of n is equal to 0,1,...,7. Accordingly, there are 32 different values for each of the inputs and each of the outputs in TABLE 1. In FIG. 4 and TABLE 1, individual corresponding bits of OP1 and OP2 are matched against each other to determine if both are 1 s TT , both are 0 s CC , both are the same BS , both are different BD , and how different TC or CT . In FIGS 5 9 the outputs from FIG. 4 are assembled in groups of four to form the signals in the following CHART 3 The manner in which the signals of CHART 3 are formed are shown in detail in FIGS. 5 through 9. Additionally, the following TABLE 2, TABLE 3,...,TABLE 6 summarize the inputs, as shown in the left hand column, and the outputs, as shown in the right hand column for the logic blocks of FIGS. 5 through 9, respectively. In FIGS. 5 through 9, TABLES 2 through 6, the value of n is equal to 0,1,...,7. These values of n correspond to the logic blocks 38 n in FIG. 3, that is, 38 0, 38 1,...,38 7. In FIG. 10, the intermediate terms from the logic blocks 38 0 through 38 7 of FIG. 3 and TABLE 2 through TABLE 6 FIGS. 5 through 9 are assembled to provide the outputs for three of the four half adders, namely the half adders 14, 15 and 16 of FIG 2. In FIG. 10, the term YY used in the INPUT and in the OUTPUT represents one of three variables, namely, TT, TC, or CT. When the variable YY represents TT, FIG. 10 represents the logic block 40 1 in FIG. 3 which forms the output from the half adder 14 of FIG. 2. When the variable YY represents TC, FIG. 10 represents the logic block 40 2 of FIG. 3 which forms the output from the half adder 15 of FIG. 2. When the variable YY represents CT, FIG. 10 represents the logic block 40 3 of FIG. 3 which forms the output from the half adder 16 of FIG. 2. The INPUT and the OUTPUT for FIG. 10 for the values of YY equal to TT, TC, and CT are represented by TABLE 7, TABLE 8, and TABLE 9, respectively. FIGS. 11 through 13 illustrate how K32CC is formed. Because of the need to carry in two instead of one, two carry propagate structures are required. One structure handles propagation of two while the other handles propagation of one . These two structures are merged in FIGS. 11 and 12, and the final term is computed in FIG. 13. The INPUT and OUTPUT for FIGS. 11, 12, and 13 are shown in the following TABLE 10, TABLE 11, and TABLE 12, respectively. In FIG. 14, the intermediate logic block 40 assembles the TTm,n outputs from the FIG. 4 bit slices the form the end result not 0 signals, ARNZ0, ARNZ1,..., ARNZ7 from the gates 57 1, 57 2,...,57 7. These signals are summarized in the following TABLE 13. In FIG. 14, the logic block 44 assembles, with OR gates 58 1, 58 2 and 58 3, all of the intermediate outputs from logic block 40. The output from gates 58 1 through 58 3 connect as inputs to the gate 59 to provide the final output AND RNZ. This signal indicates that the logical AND of OP1 and OP2 is non zero. The logical functions set forth in the right hand column of the following CHART 4 are the logical combinations performed by selection logic 26 of FIG. 1. The L stage 4 3 of FIG. 1 selects one of the logical combinations of CHART 4 when a prediction listed in the left hand column is desired. In Chart 4, the symbol denotes the 1 s complement of the quantity, the symbol denotes the logical AND function, and the symbol denotes the logical OR function.