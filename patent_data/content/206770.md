# CODED MODULATION SYSTEM WITH A SIMPLIFIED DECODER CAPABLE OF REDUCING THE EFFECTS OF CHANNEL DISTORTION

## Claims
Ein moduliertes Trägersystem umfassend einen Sender 10 und einen Empfänger 40 , um auf der Grundlage von entsprechenden von Rauschen beeinflußten Signalen, die über einen verzerrenden Kanal empfangen wurden, zu entscheiden, welche Signalpunkte von einem Sender 10 gesendet wurden, wobei die von Rauschen beeinflußten Signale Informationen über eine besondere Folge von Codierzuständen tragen, die in einer Reihenfolge von Zeitintervallen durch ein sequentielles Verfahren finite state process besetzt sind, das eine endliche Anzahl der möglichen benannten Codierzustände besitzt, wobei die benannte endliche Anzahl eine Konstellation definiert, die in Teilmengen unterteilt ist, wobei der Empfänger umfaßt

## Description
This invention relates to modulated carrier systems, for example so called coded type systems in which digital symbols to be sent over a band limited channel are encoded as a sequence of discrete signal points selected from an available signal point alphabet, with dependencies being introduced between successive signal points in the sequence to increase immunity to noise and distortion. In typical such coded systems, for example the systems described in Csajka et al. US A 3,877,768, and Ungerboeck, Channel Coding with Multilevel Phase Signals , IEEE Transactions on Information Theory, Vol. IT 28, No. 1, January, 1982, information about the dependencies between successive signal elements is exploited at the receiver using a decoding technique based on the Viterbi algorithm described in Forney, The Viterbi Algorithm , Proceedings of the IEEE, 61 3 268 March 1973 , incorporated herein by reference. In such a technique, instead of decoding each received signal independently into the signal point closest to the received signal in the sense of Euclidean distance a sequence of received signals is decoded into the sequence of signal points closest to the sequence of received signals in the sense of the algebraic sum of squared Euclidean distances. In such coded systems, final decisions are delayed for a sufficient number of signaling intervals to assure to an acceptably high probability that the sequence of which signal points were sent will be correctly decided. By contrast to coded systems, in conventional uncoded systems each symbol is encoded into signal point based only on the symbol to be encoded, with no dependencies between successive signal points at the receiver, decoding proceeds one symbol at a time. Receivers for data transmission systems typically include an equalizer to reduce the effects of intersymbol interference introduced by the channel, as described in Qureshi, Adaptive Equalization , IEEE Communications Magazine, March, 1982, incorporated herein by reference. A so called linear equalizer for a quadrature amplitude modulation QAM system, for example, is typically a transversal filter which takes samples of a received signal, multiplies each sample by a complex coefficient, and adds the products to obtain an equalized received signal for use in decoding. For channels with severe amplitude distortion, such a linear transversal equalizer enhances noise and correlates the noise in successive intervals. In coded systems using the conventional Viterbi algorithm decoder, such noise correlation will increase the probability of making decision errors. In conventional uncoded systems, a decision feedback type equalizer DFE can be substituted for the linear equalizer to perform equalization with less noise enhancement. DFEs also have the property of producing uncorrelated noise samples. DFEs are described in the Qureshi article cited above, in C.A. Belfiore and J.H. Park, Jr., Decision Feedback Equalization , Proceedings of the IEEE, August, 1979, and in D.D. Falconer, Application of Passband Decision Feedback Equalization in Two Dimensional Data Communication Systems , IEEE Transactions on Communications, October, 1976, incorporated herein by reference. Generally, a DFE multiplies previous decisions by feedback coefficients and sums the products to produce a value to be applied to the demodulated, partly equalized, undecoded received signal to correct for the anticipated channel intersymbol interference due to previous signal points in the currently received signal. Receivers for conventional uncoded systems sometimes use modified DFEs which may be called noise predictors to predict and compensate for the noise component in the received signal, as described in the Belfiore and Park article. The noise predictor output is a weighted sum of past error signals each based on a comparison of a past received signal with the corresponding decision , where the weighting coefficients are selected to minimize the average power of the residual noise signals after prediction by removing the correlation which exists between successive error signals before prediction. Unlike the conventional DFEs, in noise predictors the coefficients of the linear or forward equalizer are independent of the noise predictor or feedback coefficients. The forward equalizer coefficients can be updated to minimize the mean square error before prediction as in a conventional linear equalizer. Typically the number of feedback coefficients is small. For example, in high speed voice band modems a single coefficient can be sufficient even for worst case channels and high baud rates of the order of 2800 Baud. Fig. 1 illustrates a noise predictor having only a single predictor coefficient. Other decision feedback techniques have been used to correct for other kinds of channel imposed distortion. For example, adaptive phase predictors correct for phase jitter using the history of actual phase errors reflected in the most recent decisions as an indication of phase distortion. In using decision feedback techniques with conventional uncoded systems, decisions of which signal points were sent are available without delay. In coded systems, using DFE generally requires tentative decisions with no delay. Tentative decisions could be obtained from the most likely path history of the Viterbi algorithm, but such tentative decisions would not be reliable enough for feedback. Use of the Viterbi algorithm as an optimum method of detecting a sequence of transmitted signals received over a noisy channel with intersymbol interference ISI in a conventional uncoded system is described in Forney, Maximum Likelihood Sequence Estimation of Digital Sequences in the Presence of Intersymbol Interference, IEEE Transactions on Information Theory, vol. IT 18, No. 3, May 1972. This application of the Viterbi algorithm is similar to detecting a sequence of signals transmitted by coded modulation in that in both cases dependencies between successive signal elements are introduced by a finite state process. In coded modulation systems, the finite state process is the encoder in the transmitter. In conventional uncoded systems with ISI, the ISI model of the channel including transmit and receive filters represents the finite state process as explained in the Forney article. The state in the finite state process is determined by the K most recent signal points, where K is the number of ISI terms in the channel model. Thus, assuming L bits are sent every signaling interval, the Viterbi algorithm will be based on 2 It is also possible to use the Viterbi algorithm as an optimum method for exploiting the noise correlation at the output of a linear equalizer. In terms of performance, this would be equivalent to the more conventional use described in the Forney article, provided the linear equalizer eliminates ISI. In this approach the Viterbi algorithm will again be based on 2 In coded systems it is also possible to use the Viterbi algorithm for reducing the effects of channel distortion in an optimum manner, as described, for example, by A. Viterbi and J. Omura in Principles of Digital Communication and Coding , McGraw Hill Book Company, 1979. In this approach the Viterbi algorithm will simultaneously provide decoding and channel equalization using a larger number of states than used in the encoder. Specifically, for each encoder state a new set of decoder states is defined in terms of K possible previous signal points such that with N encoder states a large number To summarize, in coded systems the combination of decision feedback equalization and Viterbi detection is generally not directly available due to the decoding delay and to implementation complexity, respectively. IEEE Global Telecommunications Conference, San Diego, California, 28th November 1st December 1983, Globecom 83, Conference record, vol. 2, pages 1032 1038, IEEE, New York, US R Fong et al Four Dimensionally Coded PSK Systems for Combatting Effects of Secure ISI and CCI , discloses that it is advantageous to use 4D constellations for channel coding with multilevel phase signals, this resulting in a considerable coding gain. A family of trellis coded multi dimensional systems is disclosed in EP A 0200505, claiming a priority of April 25, 1985, and published on 10th December 1986. For example, a code for sending 7 bits per signalling interval could use a 32 state encoder which takes two intervals worth of bits 14 bits at a time and maps them into two 2 dimensional 2D signal constellations to obtain two 2D signal points transmitted in two successive signaling intervals. The received signals can be decoded with a Viterbi algorithm having 32 states where the path metrics and path histories are updated once every two signaling intervals based on 4D branch metrics. In multi dimensional systems, the Viterbi algorithm can again be used to reduce the effects of channel distortion in an optimum manner. Unless indicated otherwise, in what follows we will use the term signal points to mean the transmitted symbols sent every signaling interval and the term signal constellation to mean the set of different possible signal points. It is an object of the invention to overcome or at least reduce the problem of combining decision feedback equalization and Viterbi detection. The present invention provides a modulated carrier system comprising a transmitter and a receiver for deciding which signal points were sent from said transmitter based on corresponding noise affected signals received via a distorting channel, said noise affected signals carrying information about a particular sequence of encoding states occupied in a succession of time intervals by a finite state process having a finite number of possible said encoding states, said finite number defining a constellation that is divided into subsets, said receiver comprising The preferred embodiments include the following features. The number of encoder states can be one i.e., an uncoded system . In some embodiments, the finite state process is a coder in the transmitter that draws the signal pints from encoder subsets of the signal point constellation and associates encoding state transitions with encoder subsets. In other embodiments, the finite state process is imposed by the distorting characteristics of the channel. The different modified versions are based on alternative decisions on the received signals. The alternative decisions are generated after no delay or after a delay of fewer time intervals than for final decisions. Each alternative decision is associated with a particular decision subset. The decision subsets are formed by partitioning the constellation. In some embodiments, the decision subsets are the same as the encoder subsets in others, the decision subsets are not the same as the encoder subsets, for example they may be unions of the encoder subsets. The decision subsets may have a dimensionality larger than the dimensionality of the signal constellation. The alternative decisions are the signal points in the decision subsets that are closest to the most recent received signal. Each modified version is obtained by a noise predictor that offsets each received signal by a noise prediction value that is based on errors between prior received signals and corresponding alternative decisions. The time interval between successive encoding states may span a plurality of e.g., 2 successive signaling intervals. The transmitter has a modulator and the receiver has a demodulator. The number of path histories is greater than two. There may be four decision subsets and four modified versions. Decoder states are formed by combining encoder states with decision subsets. The decoder may make branch metric calculations successively with respect to each of the signal points spanned by the time interval. The invention enables using better equalization techniques in coded systems by exploiting the noise correlation at the output of a linear equalizer. The invention can provide a simplification of the Qureshi scheme when the number of feedback coefficients is small. The invention also provides a new means for reducing the number of states in the optimum Viterbi algorithm when used to reduce the effects of channel distortion in systems with a large number of signal points. The decoder is simpler compared to prior art decoders because generally fewer branch metric computations and received signal modifications are needed. The additional decoder complexity relative to a conventional Viterbi decoder is generally independent of the number of states in the Viterbi algorithm and of the dimensionality of the encoder. The lower complexity of the decoder could allow its use with high speed voiceband modems using a typical digital signal processor. The decoder can operate at a near optimum performance at reduced complexity by taking into account the channel distortion in the decoding process. The actual performance advantage will depend upon the channel attenuation distortion, the coding system employed, and the complexity allowed at the receiver. In a typical application, a signal to noise ratio advantage of 0.5 to 1.5 dB can be obtained with noise predictors having just a single coefficient and using the same number of states in the decoder as in the encoder. Other advantages and features will become apparent from the following description of the preferred embodiment and from the claims. We first briefly describe the drawings. Fig. 1 is a block diagram of a receiver for use with an uncoded system and including a prior art noise predictor. Fig. 2 is a block diagram of a transmitter of a 32 state 4 dimensional coded modulated carrier communication system. Fig. 3 is a block diagram of the encoders and selector of Fig. 2. Fig. 4 is a block diagram of a receiver for use with the transmitter of Fig. 2. Fig. 5 is a block diagram of the decoder of Fig. 4. Fig. 6 is a diagram of a two dimensional signal constellation for use with the transmitter of Fig. 2. Fig. 7 is a block diagram of the encoders and bit converter of Fig. 3. Fig. 8 is a chart of 4D subsets, 2D subset pairs, and corresponding bit patterns. Fig. 9 is a representative portion of a trellis diagram. Fig. 10 is a trellis chart. Fig. 11 is a bit chart corresponding to the block encoder of Fig. 7. Fig. 12 is a block diagram of the noise prediction circuitry and decoder of Fig. 4. Fig. 13 is a flow chart of the decoding process. Fig. 14 is a representative portion of a trellis diagram. Fig. 15 is a block diagram of a 16 QAM system employing the simplified Viterbi decoder. Fig. 16 is a partitioned 16 QAM signal constellation. Fig. 17 is a trellis chart. Referring to Fig. 2, in transmitter 10 a scrambler 12 receives a serial bit stream of information to be sent over a channel 14 at the rate of 7 bits per signaling interval. The 14 information bits that appear in each pair of successive signaling intervals, denoted as I1 Referring to Fig. 3, encoders and grouping device 18 include a serial to parallel bit converter 29 which receives the serially appearing scrambled bits, organizes them into groups of information bits each having 14 bits and delivers each group to a differential encoder 30 which receives the information bits and differentially encodes some of them. The information bits including the differentially encoded ones are then passed through a finite state device in the form of a convolutional encoder 32 which convolutionally encodes some of the bits, adding one redundancy bit indicative of the current state of the finite state device represented by the convolutional encoder. The information bits including the differentially and convolutionally encoded bits are then passed through a bit converter and block encoder 34. The block encoder encodes some of the information bits and adds an additional bit. The bit converter reorganizes a set of the bits including the differentially and convolutionally encoded bits. The output bits of the bit converter and block encoder 34 is a set of 16 point selection bits which are organized as the two groups Z0 Because the current state of the finite state device represented by the convolutional encoder depends both on its prior state and on the current information bits, the output bits of the convolutional encoder and hence the transmitted signals carry historical information about the information bits being sent. This historical information is exploited at the receiver end of channel 14. Referring to Fig. 4, in receiver 40, the received modulated carrier channel signals are passed through an A to D converter 41, a linear equalizer 44, and a demodulator 45. Equalized and demodulated coordinate pairs are delivered serially from equalizer 44 to a modifying circuitry 46. Four modified versions of the received signals are then delivered respectively over four lines 47 to a decoder 48. Decoder 48 after a delay of several signaling intervals delivers final decision bits, for each group of 14 information bits which were sent, to a descrambler 52 to recover the original serial bitstream. Referring to Fig. 5, in decoder 48 the modified versions of the received signals are delivered to a modified Viterbi algorithm device 60 which after some delay delivers two final coordinate pair decisions. Parallel to serial coordinate pair converter 62 applies the coordinate pairs serially one pair at a time to a bit mapping table 64. For each coordinate pair applied to table 64, a corresponding group of eight decision bits is delivered to a serial to parallel bit group converter 65, then to a bit deconverter and block decoder 66, then to a differential decoder 68, and finally to a parallel to serial bit converter 69. The deconverter and decoder perform the reverse processes from the conversion and coding performed at the transmitter. The differential decoder then provides the estimates of the original groups of seven information bits, I1 Returning again to the transmitter, the fourteen information bits which appear in two successive signaling intervals are encoded into two 2D signal points drawn from a 2D constellation having 192 points. Fig. 6 shows how the 2D constellation 70 is constructed and partitioned. The 2D constellation includes the same 128 point cross constellation 72 located within the boundary shown which is typically used with an uncoded system for sending 7 bits per signaling interval. Those 128 points indicated as dots within the boundary are called inner group points. The 2D constellation also includes an outer group of 64 points, half as many points as are in the inner group. The outer group points are selected from the possible points lying on an extension of the inner group rectangular grid to regions beyond the boundary of the 128 point cross constellation. The outer group points are arranged as close to the origin as possible. The 192 point 2D constellation is partitioned into four equal sized subsets, denoted A, B, C, and D. In Fig. 6, the subset to which each point belongs is indicated by a lower case letter, a, b, c, or d. The subsets are grouped into two 2D families, denoted AUB the union of A with B and CUD. All subsets have the same numbers of inner group points and outer group points. The ratio of the number of outer group points to the number of inner group points in each subset is the same as the ratio for the entire 2D constellation. The minimum squared distance, 4d 2 o, between points belonging to the same subset is greater than the minimum squared distance, 2d 2 o, between points belonging to different subsets within the same 2D family, which is in turn greater than the minimum squared distance, d 2 o, between any two points. Examples of such distances are shown with reference to point 74 on Fig. 6 . In the constellation of Fig. 6, some of the 2D points are labeled with a six bit value representing the bit pattern Z2 Two identical such 2D constellations taken together can be conceived as a single 4D constellation having 36864 192 x 192 4D points, the four coordinates of each 4D point being the same as the two pairs of coordinates of the corresponding pair of 2D points, one from each 2D constellation. Only 32768 2¹⁵ of the 36864 4D points are used, namely the ones whose corresponding pair or 2D points do not belong to the outer group. From now on, in discussing the 32 state code for transmitting 7 bits per signaling interval, we will refer to this 32768 point 4D constellation as the 4D constellation. We now define 16 4 x 4 4D subsets, each corresponding to a pair of 2D subsets, and denoted as A,A , A,B ,..., and D,D . Each 4D subset has 2048 points and the minimum squared distance between two 4D points belonging to the same subset is 4d 2 0, which is the same as the minimum squared distance between two 2D points belonging to the same 2D subset. The squared distance between two 4D points is simply the sum of the squared distances with respect to the two pairs of 2D points to which those two 4D points correspond. Note also that each 4D subset like the 4D constellation generally, contains only 4D points for which the corresponding pair of 2D points do not both belong to the outer groups of the 2D subsets corresponding to that 4D subset. The sixteen 4D subsets are grouped into two 4D families, denoted as OU1U2U3U4U5U6U7 and 8U9U10U11U12U13U14U15. The minimum squared distance, 4d 2 0, between 4D points belonging to the same 4D subset is greater than the minimum squared distance, 2d 2 0, between 4D points belonging to different 4D subsets within the same 4D family, which is in turn greater than the minimum squared distance, d 2 o, between any two 4D points. The design of 32 state, 180 degree rotationally invariant linear convolutional code with these sixteen 4D subsets is illustrated in Figs. 7 and 8. A rate 3 4, 32 state linear convolutional encoder 84 is used to generate four bits Y0 In convolutional encoder 84, each box marked 2T represents a temporary storage element which holds any input value for two signaling intervals the value held in the element always appears at its output. The circles marked plus are exclusive or elements . The outputs of the 2T elements are bits marked W1 Only certain sequences of state transitions of the convolutional encoder are allowed as represented by the branches in the trellis diagram of Fig. 9. In Fig. 9, the 32 possible current states are represented by a column of dots 86 each marked with the corresponding pattern of state defining bits. The 32 possible next states are represented by column 88. Trellis branches 90 connecting current states to next states represent allowed state transitions Only representative portions of the trellis are shown in Fig. 9. The entire trellis can be reconstructed from the chart of Fig. 10 . Each state can be followed by only eight possible transitions. Each transition has a 4D subset assigned to it. The assignment for transitions from each current state are represented by the 4D subset numbers appearing in column 92 to the left of that state. For example, the eight transitions from current state 00000 are assigned 4D subsets 01452367 respectively, as shown in Fig. 10. Only the first three transitions are labeled in Fig. 9. We now describe how to map the four output bits of the convolutional encoder and the eleven remaining uncoded information bits into the 4D constellation. Four coordinate values are needed to define each 4D point. A table of 96 48 x 2 2D coordinate values is used twice to look up the four needed coordinate values. The table being referred to can be constructed from the constellation of Fig. 6 simply by associating with the coordinates of each point the eight bits needed to represent the point, namely, the six bits marked under the point and the two bits needed to specify its 2D subset. For example, for point 74 the coordinates 5,5 are associated in the table with the eight Z bits 10001010. Referring again to Figs. 7 and 8, after using the four output bits of the convolutional encoder to specify a 4D subset, a bit converter 96 converts the four bits Y0 The eleven uncoded information bits which remain are used to select a particular 4D point from the previously selected 4D subset. Referring to Figs. 7 and 11, a 4D block encoder 97 takes three of the remaining uncoded information bits I1 There are sixteen 2D points in the outer group or in either half of the inner group of a 2D subset, and eight uncoded information bits remain for selecting from among those 2D points. Those eight bits are taken in two groups of four bits each, and are renamed as Z4 To summarize, the bit converter 96 and 4D block encoder 97 take the four output bits of the convolutional encoder and the eleven remaining uncoded information bits and produce sixteen coded selection bits. Those sixteen selection bits are then grouped by sampler 36 into two groups of eight selection bits each, Z2 In effect, the sequence of signal points sent from encoder 26 carries with it information in the form of the subsets from which those signal points were drawn about the encoder s path through the trellis. At the receiver, decoder 48 exploits this historical information to estimate the path through the trellis which was likely to have been tranversed at the transmitter by also taking into account the noise correlation, and using that estimated path determines the signal points which were sent. The decoding process is based on a modification of the Viterbi decoding algorithm. As of each point in time represented in the trellis e.g., the time represented by column 86 of Fig. 9 the decoder stores for each of the possible thirty two states a contending path history comprising the list of the L most recent 4D signal points lying on some likely trellis path which ends in that state. 2L is the number of signaling intervals for example which elapses between the time a signal is received and the time a corresponding final decision is made about which signal point was sent . The decoder also stores for each possible state a contending path metric which represents the aggregate squared distance between the 4D signal points on the contending path ending in that state and certain noise corrected versions to be described below of the sequence of received 4D signals. After two more signaling intervals have elapsed, the decoder extends the trellis to the next point in time along the trellis e.g., the time represented by column 88 in Fig. 9 . Extending the trellis is done in general by identifying the minimum metric contending trellis path ending in each next possible state based on the previously stored contending path metrics and on calculations of the squared distances branch metrics for alternative possible transitions branches leading to each next possible state. Once the trellis has been extended, the oldest 4D signal point in the most likely one of the contending path histories becomes a final decision. This process of extending the trellis is repeated every two signaling intervals. More specifically, referring to Fig. 12, modifying circuitry 46 includes four noise predictors 102, 104, 106, 108, associated respectively with the four different 2D subsets A, B, C, D. For example, predictor 104 is associated with 2D subset B. In what follows we represent 2D subsets by integers according to Although in this example the subsets associated with the predictors are the same as the subsets used in the encoder, in general the subsets used with the predictors can be different and thus will be called decision subsets while the subsets at the encoder will be called encoder subsets. Modifying circuitry 46 receives from the demodulator pairs of 2D received signals each pair corresponding to two intervals worth of bits encoded by the transmitter. The two received signals in each pair are delivered in sequence. The currently received pair are respectively denoted r In all of the predictors, the same predictor coefficient is used for both received signals of the currently received pair and is denoted b Referring to Fig. 13, the decoding for each pair of signaling intervals proceeds on an interval by interval basis. In the first interval of the pair 120 , the first step is to update the predictor coefficient b The next step is to compute a noise prediction for each of the four predictors 124 based respectively on the points in the previous signaling interval C and Next, each predictor uses its noise prediction to modify 126 the currently received signal r Then, four 2D branch metrics are computed 128 for each modified received signal, namely the branch metrics for the signal points in the four 2D encoder subsets which are nearest to that modified point. A total of sixteen 2D branch metrics are thus calculated d 2 1 j,i , i 0, 1, 2, 3, j 0, 1, 2, 3, where d 2 1 j,i is the squared distance between the modified received signal r Next, the closest points in each 2D decision subset C and In the second signaling interval 132 , those noise predictions are used to modify the received signal 134 . The outputs of the four modifying circuitry are then Next, for each modified received point, four 2D branch metrics are computed, d 2 2 j,i , i 0, 1, 2, 3, j 0, 1, 2, 3, where d 2 2 j,i is the squared distance between the modified received signal r The 2D branch metrics saved in the first and second intervals are then combined 138 into a total of 64 4D branch metrics. Each 4D branch metric is the sum of one of the first interval 2D branch metrics and one of the second interval 2D branch metrics. Each of the 64 4D branch metrics is denoted where l represents the 4D subset corresponding to the 2D encoder subsets j and k. For example, the 4D branch metric D² l,i is the sum of a the squared distance between the first interval output of the ith modifying circuitry, and the nearest 2D point from the first 2D encoder subset j corresponding to the lth 4D subset, plus b the squared distance between the second interval output of the modifying circuitry associated with first 2D decision subset j corresponding to the lth 4D subset, and the nearest 2D point from the second 2D encoder subset k corresponding to the lth 4D subset. Restated, the 4D branch metric is a concatenation of two 2D branch metrics for the two signaling intervals. The 2D metrics are respectively based on the closest points from the two 2D encoder subsets making up the 4D subset. In the first interval the metric is measured from some i th modified received signal in the second interval from the modified received signal associated with the 2D decision subset of the first interval. The 64 4D branch metrics are then used to extend the trellis 140 by first assigning to each trellis branch an appropriate one of the 4D branch metrics. Specifically, a trellis branch to which a 4D subset l has been assigned and which originates from a state with a path history whose most recent 2D signal point is in 2D decision subset i will be assigned branch metrics D² l,i . Once the branch metrics have been assigned, the extension of the trellis is accomplished in the usual way by finding the best contending paths with minimum accumulated metric ending in each possible next state. Next, the best contending trellis path is identified. The most recent 4D signal point C and Because of the simplification in the 4D constellation mapping, the mapping from each finally decided 4D point back to the 14 information bits in decoder is simplified. Each 2D point of the pair of 2D points corresponding to the 4D point can first be mapped back to eight Z bits, using a single bit mapping table 64 Fig. 4 . Then performing the inverse conversions corresponding to the bit converter and 4D block encoder produces the 14 information bits. Thus, the number of noise predictors is not dependent on the number of states or the number of dimensions of the code. Only 16 possible branch metrics need to be calculated in each signaling interval, and only 64 4D metrics need to be calculated. With relatively few branch metric and noise prediction calculations to be made, the decoder can be relatively simple with no major sacrifice in performance. Other embodiments are within the following claims. The code can be other than 4D, for example 2D, 8D, 16D, etc., and can have other numbers of states, for example, 8 states, 16 states, 64 states, etc. The noise predictors can be replaced by or combined with other feedback devices such as adaptive phase predictors. A baseband communication system can be used. In generating modified versions of the received signal, the modifying circuitry may use a finer or coarser partitioning of the 2D signal constellation than the partitioning used in the encoder. For example, in the 32 state code, the modifying circuitry may partition the 192 point 2D signal constellation into 8 decision subsets with 24 points in each decision subset again keeping the distance between points in a decision subset as large as possible. In this case, 8 noise predictions and 8 modified versions of the received signal will be generated. For each modified version, 4 2D branch metrics are computed with respect to each of the 2D encoder subsets A,B,C, and D. The 32 branch metrics computed in each signaling interval are combined to obtain 128 4D branch metrics D² l,i , l 0,1,...,15, i 0,1,...,7. A trellis branch to which a 4D subset l has been assigned and which originates from a state with a path history whose most recent 2D signal point is in the 2D decision subset i 0 7 will be assigned the branch metrics D² l,i . Otherwise, the decoding proceeds in the same manner as described above. The scheme can also be used with multiple predictor coefficients. In this case, the decision subsets will be multi dimensional. For example, in the 32 state code, to use two predictor coefficients, we can choose the 16 4D encoder subsets as the decision subsets. Then, each signaling interval, 16 4D alternative decisions are formed. For example in the first signaling interval, the modifying circuitry first forms 4 2D alternative decisions C and where l i,j represents the 4D decision subset associated with 20 subsets j and i. The quantitites b For each modified version, 4 2D branch metrics are computed with respect to 4 2D encoder subsets A, B, C and D, the resulting 64 branch metrics are then used together with the 64 branch metrics from the first signaling interval computed in the same manner to obtain 256 4D branch metrics D² i,l , i 0,1,...,15, l 0,1,...,15. A trellis branch to which a 4D subset i has been assigned and which originates from a state with a path history whose most recent pair of signal points is in the 4D decision subset 1 0 15 will be assigned the branch metrics D² l,i . The trellis update can otherwise proceed in the same manner as described before. Again the decision subsets can be different from the encoder subsets. For example in principle, only 8 decision subsets need be used. The decoder may employ a larger number of states than required by the encoder, to achieve improved performance. For example, for the single coefficient case, in the 32 state 4D decoder each current encoder state can be replaced by 4 new decoder states based on the most recent 2D decision subsets. More specifically, when the decision subsets are the same as the 2D encoder subsets, the new decoder states can be denoted as i,a , i,b , i,c and i,d , where i 0 31 represents the encoder state and a,b,c, or d represent the 2D decision subset associated with the most recent signal point in a trellis path. Thus, there will be 128 32x4 decoder states with 8 transitions branches from each decoder state. The state transition diagram for this new decoder state assignment can be easily obtained from Fig. 10. In general, the state k,j with k 0 31 being an encoder state and j a,b,c, or d a 2D decision subset will have transitions from decoder states n,a , n,b , n,c , n,d and m,a , m,b , m,c , m,d with n and m representing the two encoder states which have a transition to encoder state k corresponding to a 4D subset the second 2D subset of which is j. For example, the transitions to state 0,a will be as shown in Fig. 14. In the decoding process 128 contending path metrics and path histories will be stored. The generation of the four modified versions of the received signal and the calculation of 64 4D branch metrics will be the same. The trellis update can proceed in a similar manner. For example, the new path metric for state 0,a will be the minimum accumulated path metric of all contending paths shown in Fig. 14 leading to state 0,a . The tentative decisions C and The described decoder has a reduced number of states relative to an optimum Viterbi decoder optimum for combined decoding equalization because the states are defined in terms of subsets of signal points rather than in terms of the individual signal points. Note that for the single coefficient case the optimum decoder would need 6144 32 x 192 decoder states and substantially more complicated branch metric computations. The set partitioning used in the decoder can again be different from the partitioning used in the encoder. In the special case when the number of decision subsets is equal to the number of signal points, the decoder will become optimum for the single coefficient case. By using a moderate number of decision subsets, near optimum performance can be obtained with significantly less complexity than required by the optimum decoder. The method can be applied for codes with any number of states or dimensions. It can also be used in conjunction with the Qureshi scheme, by modifying received signals with alternative decisions taken directly from path histories or previous branch metric computations. Multiple predictor coefficients can be handled by defining states in terms of multi dimensional decision subsets. This method can also be used to implement a reduced state Viterbi algorithm detector in an uncoded system with channel distortion. Referring to Fig. 15, in an uncoded 16 QAM communication system, a stream of binary digits 160 are collected in groups of four by serial to parallel converter 162 and encoded in the mapping device 164 at the signaling rate into a complex signal point according to the signal point mapping shown in Fig. 16. The signal points are modulated, filtered in a transmit filter and D A converted 166 to generate an analog signal to be sent over a bandlimited, noise affected channel. In the receiver, the noise affected signal is A D converted and passed through a linear equalizer 168 to generate a sequence of received signals at the signaling rate. The equalizer suppresses any ISI introduced by the channel, but its output is corrupted by a noise sequence which is typically correlated between successive intervals. For simplicity, we assume that a single coefficient predictor is sufficient for minimum mean square error prediction of this noise sequence. This means that an optimum Viterbi detector would need 16¹ 16 states. The received sequence is fed into modifying circuitry 170 which partitions the signal constellation into four decision subsets according to Fig. 16. When a new signal r The received signal r where b For each modified signal the Viterbi algorithm will compute four branch metrics according to where C and i,j is the signal point in subset j which is closest to the i th modified signal r The methods for exploiting noise correlation at the output of a linear equalizer can also be used in other forms of DFE or Viterbi detectors. Other approaches for updating the predictor coefficients can be used.