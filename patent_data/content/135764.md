# SYNCHRONIZATION OF CLOCKS IN A DISTRIBUTED COMPUTING NETWORK

## Claims
Verfahren zum periodischen Synchronisieren lokaler Uhren in einem Netzwerk mit gleichartigen CPU s, die Nachrichten senden und empfangen, wobei sowohl die Driftrate zwischen den Uhren als auch die Übertragungs und Verarbeitungszeiten der Nachrichten im Netzwerk zwischen sendenden und empfangenden CPU s begrenzt sind, und das Verfahren an jeder CPU des Netzwerkes die folgenden Schritte umfaßt

## Description
This invention relates to the synchronization of clocks in a distributed computing network in the presence of faults, the network processor nodes exchanging information asynchronously. In distributed computing systems, it is assumed that each processor node consults its own internal clock. Since clocks in distributed systems drift apart, they must be periodically resynchronized, that is, brought very close together in value. This resynchronization is necessary in order to carry out many protocols for distributed systems. One such protocol is described in U.S. Patent No. 4,569,015. In a seminal article, Lamport, Time, Clocks, and the Ordering of Events in a Distributed System , Vol. 21, Communications of the Association of Computing Machinery, pages 558 565, July 1982, Lamport uses the concept of one event happening before another in order to define a partial ordering of events. Further, Lamport describes a protocol for extending this partial ordering to a total ordering for synchronizing events and then applying this to a system of physical clocks. This guarantees that a set of correct clocks will differ by no more than a specifiable amount. A paper by Lamport and Melliar Smith, Synchronizing Clocks in the Presence of Faults , SRI Technical Report, published July 13, 1981, describes clock resynchronization in a distributed system in which each processor is required to broadcast its time value. In turn, each processor receives the clock value from every other processor, discards extreme values, and uses an averaging process for synchronization. In order to achieve clock synchronization in the presence of f faults, Lamport requires 2f 1 processors. Since an averaging process is used, there must be more non faulty processors than faulty ones for the described technique to work. Note, clock synchronization in this context is simply the condition that clocks differ by no more than a specified upper bound. In the previously mentioned U.S. Patent No. 4,569,015, there is described a method for achieving Byzantine Agreement among n processors in a reliable f 1 connected network with guaranteed early stopping in the presence of faults, and eventual stopping for f n 2 faults. Byzantine Agreement is a protocol which guarantees that eventually all correct processors will agree on a value. By way of contrast, clock synchronization protocols must guarantee that all correct processors agree within a specified margin of error on a time. Prior art protocols have required a significant quantity of message passing. In the Lamport and Melliar Smith case approximately n In U.S. Patent No. 4,531,185, the described method requires that during each period, the network of processors previously agree upon an ordered list of participants, and that at specified time in the period, the first processor on the list attempts to synchronize all to its own clock. The result of this is either a synchronization of all correct processors clocks to be within the desired tolerance or an agreement among all other correct processors that the first on the list has failed. If the first fails, then the second tries, etc. It is an object of the present invention to devise a method for clock synchronization in a distributed computing network of n processors in the presence of faults using exchange of information. Said method ought not to require any minimum number of processors in order to handle f processor faults so long as the network remains connected. Relatedly, said method should achieve synchronization using reduced message traffic, be continuously operable in a faulty environment, and avoid averaging. Faults could be manifest in several ways in centralized synchronization of local clocks. First, the synchronizer could broadcast different messages to different processors, or it could broadcast the same message but at different times, or it could forget to broadcast to some processors. Illustratively, there could be a failure in the synchronizer in the middle of its broadcast of the message the time is 9 00 a.m. . It could then spontaneously recover five minutes later and continue broadcasting the message. Thus, one half of the processors would receive the message the time is 9 00 a.m. at 9 00 a.m. while the other half would receive it at 9 05 a.m. If the role of the synchronizer is distributed, then every correct processor will try to act as a synchronizer at roughly the same time, and at least one will succeed. To insure that this occurs at approximately the same time, the method guarantees that the processors will essentially always agree on the expected time for the next synchronization. The method of this invention is directed to periodically synchronizing local clocks in a network of counterpart communicating processors nodes . In this regard, both the drift rate between the clocks and the network message transit and processing times are bounded. The method steps are executable at each CPU. The first step includes ascertaining whether a time value message has been received within a current synchronizing interval. Next, if said message has not been received within said interval, then the CPU originates and broadcasts to all network connected CPU s exactly one time value message. To this message, the CPU appends thereto its unforgeable signature, resetting the expected time of next resynchronization, and updating its local clock. The method steps further include ascertaining whether a received message is valid according as to whether said message was received within a period determined as a function of the number of signatures appending the message. Lastly, if said received message is valid, then the CPU appends thereto its unforgeable signature and passes exactly the one message on by broadcasting to all network connected CPU s, resets the expected time of next resynchronization, and updates its local clock otherwise, the CPU returns to a wait state. This method guarantees that the clocks used by correct processors never deviate by more than some maximum amount dmax. During the resynchronization, a clock of a correct processor is never set back. Resynchronization is achieved by creating new clocks and, after a certain period of overlapping existence, discarding the old clocks. The difference between the reading of the new clock and that of the old is always non negative and never exceeds a fixed amount ADJ. The invention will now be more closely described in connection with the accompanying drawings where As a preliminary, the method of this invention is executable upon a computing system of the type including one or more CPU s, each having a main store, input output channel, control unit, direct access storage devices, local addressable clocks, and other I O devices coupled thereto, Such a system is described in Amdahl et al, USP 3,400,371, issued September 3, 1968, and entitled Data Processing System . The Amdahl system includes as a resource, all of the facilities of either the computing system or of an operating system running thereon which are required for the execution of a process including the method of this invention. Typical resources include a main store, I O devices, the CPU, data sets, arid control or processing programs. Furthermore, such systems are capable of multiprogramming . The latter pertains to the concurrent execution of two or more processes by a computing system, and can be managed on a computer running under IBM System 370 operating system as described in IBM publication GC28 6646, July 1973, and listed in IBM System 360 bibliography, GA22 6822. Networks of asynchronously operating CPU s are described in Fitzgerald, USP 3,940,743, Interconnecting Unit for Independently Operable Data Processing Systems , issued February 24, 1976, and Antonacco et al, USP 4,223,380, Distributed Multiprocessor Communication System , issued September 16, 1980. It is art recognized that clock synchronization in a distributed system must be bounded in several ways. One expression of this was provided by the aforementioned Lamport and Melliar Smith reference which stated that at any given time, the difference between the times on any two correct processors clocks is bounded by a constant dmax and at the end of each phase, the amount by which any non faulty clock is increased is bounded by a constant. In this invention, a distinction is made between real time as measured in an assumed Newtonian time frame that is not directly observable, and clock time, the time measured on some clock. If c is a non faulty clock, then c t denotes the time on clock c as read at real time t. Let ρ designate a bound on the rate at which c is drifting apart from real time. Further, for the correct functioning of this invention, the following conditions must exist There exists a bounded rate ρ at which the time on the clock of a correct processor diverges from real time. The bounded rate of drift is represented by the following relation If two processors and the link joining them are non faulty, then there exists a known upper bound tdel time delay on the time required for a short message such as the time is t to be prepared, transmitted along a network route, and processed at the receiving node. The processors are numbered 1,2,..,n. If processor i intends to send a message m, then there exists an encoding function e All messages sent from processor i to processor j along the route from i to j are received in the order in which they are sent. An alternative condition is that the rate of drift and the number of tolerated faults observe the relation Clocks currently used are efficiently precise as to guarantee ρ 10 ⁶ seconds per second for condition 1. Further a timed delay of tdel 0.1 seconds approximates instances for condition 2. The use of encryption techniques to satisfy the authenticity of a message source unforgeability of signatures are well known from Rivest et al, A Method for Obtaining Digital Signatures and Public Key Crypto Systems , CACM, Vol. 21, No. 2, February 1978. The first half of condition 4 can be guaranteed by the following protocol. All messages from processor i to j are numbered consecutively. If processor j receives a message numbered n, it ignores it until all messages which have a lower number have been received. Note that if ρ 10 ⁶ as above, then the second half of condition 2 holds whenever f 499,999. Referring now to FIG. 1, there is exhibited a high level decision flow diagram of the method of centralized clock synchronization as set out in the U.S. Patent No. 4,531,185. Residing at each processor clock node in the network is an ordered list of nodes. First, the first node on the list broadcasts a time value with its unforgeable signature to all other nodes including itself. Next, a message exchange proceeds wherein receiving processors in the network pass such a message on with their own unforgeable signatures to all active processors including themselves. If the message is received within an interval predetermined as a function of the number of signatures, then the time value is accepted as valid and the local clock is set forward. If the time value is not received within the interval, then the first node on the list is replaced with the next node and the replacement node broadcasts an updated time value with its unforgeable signature to all nodes including itself and repeats the message exchange. The first node on the list announces to the other processors what the current time is. Because such a synchronizer could be faulty, the ordered list constitutes a method for replacing such a faulty synchronizer. With decentralized clock synchronization according to the invention each processor in the network executes a collection of tasks at least one of which is in the wait state. To further the description of the decentralized synchronization method, it is desirable to define terms involving time and clocks, characterize the relevant aspects of the network, and relate these to the task implemented method steps of the invention. First, synchronization is modeled by starting up a new clock. After the kth synchronization, processor i will have its clock c k i running. Since the processors will not be able to agree precisely on when the kth synchronization is to take place, real time is broken up into non overlapping intervals Initially, all processors start their c⁰ running simultaneously. For simplicity, this start time is called zero. Mathematically stated, Typically, the length of an interval END The following is a list of names of variables and constants. The constants global to the network are The variables local to a particular processor include The primitives for task scheduling include timers and monitors. Timers measure duration of time. A monitor which wakes up a processor upon the occurrence of some event such as that of a timer going off will possibly be a wake up message from some other task. The existence of a broadcast protocol by which one processor can broadcast a message to all the others is assumed. There are many such described in the literature. Dmax must be chosen as a function of the network topology and the number of faults to be tolerated. Given a network G and upper bounds f Note, if there are n nodes in G, then for all f Referring now to FIG. 2, there is shown a global flow for a network of processors. Each processor will have its clocks and intervals initialized to predetermined values after which two tasks are invoked which run perpetually. The first task, termed a time manager monitor , is triggered if its clock has attained the current value of et, in which case it signs and broadcasts a message the time is et to all other nodes in the network and updates its local clock, interval number, and value of et. The other task, task 2, denominated a message manager monitor , is triggered by the receipt of a message. It then tests the validity of the message. If it is valid, the processor signs the message and passes it on to all other processors. It also updates its local clock, interval number, and value of et. This flow is detailed in FIG. 3. During resynchronization the clock of a correct processor is never set back. Resynchronization is achieved by creating new clocks and, after a certain period of overlapping existence, discarding the old clocks. The difference between the reading of the new clock and that of the old is always non negative and never exceeds the fixed amount adj. When the current clock of processor i reads et, then the processor signs and sends out an encoded message to all processors saying the time is et . A new clock is started with time et. Then et and curint are incremented. In pseudocode format Suppose processor i receives an authentic message with s signatures saying the time is t . This message can be decoded so as to show that it has been signed by s processors and not altered in any way. Consequently, if the message arrives at a reasonable time , then processor i updates et Suppose that the synchronization interval per is set equal to one hour and the next synchronization is expected at 11 00, i.e. et 11 00. If any processor has not received a valid message by 11 00 on its clock, where a message is said to be valid if it passes all of the tests of task 2, then task 1 will be executed on that processor. If on the other hand the processor does receive a valid message before 11 00, then task 2 is executed. Once one of these tasks is executed, et is updated to 12 00, so neither task will be executed again in the same period. Although a valid message may arrive at any time within an interval that has size several multiples of dmax, the correct processors will be synchronized to be within dmin, which is less than dmax, at the beginning of each resynchronization period. If the message provides the time is t arrives early , it is said to be valid, even if it arrives sxdmax before t, where s is the number of signatures. To appreciate the necessity for this aspect, suppose dmax is .1 seconds. Further, suppose that processor i receives a message with three signatures stating the time is 11 00 . Lastly, suppose this message arrives .3 seconds before 11 00. It follows, that processor i according to the invention, will consider this message valid. Suppose, to the contrary, that processor j is correct and is running .1 seconds slower than processor i. Moreover, if processor j receives processor i s message almost instantaneously, processor j will receive the message roughly .4 seconds before 11 00 on its clock. Since the message now has four signatures, processor j will also consider it valid. This illustration can be extended to a circumstance in which a fixed bound on the interval in which a message is considered valid that is independent of the number of signatures on the message will simply not work. Recall that del is the maximum rate at which correct clocks might drift apart. Roughly speaking, all correct clocks and their associated local processors, will decide to synchronize within a real time interval of length dmin brt f As an illustration, suppose ρ 10 ⁶ seconds, tdel 0.1 seconds, and the network is completely connected with n processors. It follows as long as there are If a network is restricted to only processor failures, then the following values can be used per 1 hour, dmax .11 seconds, dmin .1 seconds, and adj .11f seconds. Note here that dmax is roughly equal to dmin. Lastly, dmin and dmax can both be made smaller by giving the synchronization process high priority in the scheduling of the operating system of each local processor. The enumerated tasks 1 and 2 as shown in FIGS. 2 and 3, are expressible in a high level programming language such as PL I. In this regard, PL I is fully described in IBM Systems Reference Library Manual S 360 29, catalog no. GC28 8201 4, 5th Edition, copyrighted December 1972. Reference also should be made to the aforementioned U.S. Patent No. 4,569,015, for a discussion of the attributes of monitors, especially wakeup and broadcast monitors and their implementation in each local node processor execution environment.