# A MULTIPLE WINDOW DISPLAY SYSTEM

## Claims
Mehrfachfenster Anzeigesystem mit einer wiederholt abgetasteten Anzeigeeinrichtung, mit einem Bildschirmpuffer 12 , der unmittelbar auf die Anzeigebereiche der Anzeigeeinrichtung abgebildete Anzeigedatenelementstellen aufweist und mit Zugriffsmitteln, welche die Anzeigedatenelementstellen synchron mit dem Durchlauf der Anzeigebereiche der Anzeigeeinrichtung durchlaufen und mit einer Einrichtung zum Kompilieren eines Satzes anzuzeigender Datenelemente potentiell aus einer Mehrzahl unabhängig durch einzelne jeweilige Benutzer erzeugter Fenster, dadurch gekennzeichnet, daß die Kompilier Einrichtung durch eine Bildschirmmatrix 24, 40 gesteuert ist, die unmittelbar auf die Anzeigebereiche der Anzeigeeinrichtung abgebildete Kompiliersteuerstellen aufweist und unmittelbar auf die Inhalte der Steuerstellen anspricht, um die verfügbaren Datenelemente aus den verschiedenen Festern, von Anzeigebereich zu Anzeigebereich automatisch zu filtern.

## Description
The present invention is generally related to a multiple window display system and more particularly to hardware and software implementations that display multiple data windows on cathode ray tube CRT , gas panel, liquid crystal displays LCD and other like displays commonly used in computer and data processing systems. The invention has its primary application in multi tasking computer environments wherein each window displays data from a different one of the tasks. Generation of video data for a raster scanned CRT is well understood. EP A 0 055 167 discloses a process and apparatus for displaying data in a raster scanned display apparatus, such as a cathode ray tube display, using a composite paged memory. In US A 4 197 590 a computer graphics display system is described, which includes random access raster memory for storing data to be displayed, a raster memory control unit for writing data into the raster memory, and a video control unit for causing such data to be displayed on a CRT screen. Figure 1 shows a typical implementation. A CRT controller 10 is used to generate memory addresses for a display refresh buffer 12. A selector 14, interposed between the controller 10 and the buffer 12, is used to provide an alternate source of addressing so that the contents of the refresh buffer can be modified. Thus, the selector 14 may pass the refresh address from the controller 10 or an address on the system address bus to the display refresh buffer 12. By time division multiplexing TDM the refresh buffer band width, interference between refresh and system accesses can be eliminated. For an alphanumeric character display, the display refresh buffer usually contains storage for a character code point and associated attributes. The character code point is used to address the character pel generator 16. Outputs from the character generator 16 are produced in synchronism with the scan line count output from the CRT controller 10. Attribute functions such as reverse video, blink, underscore, and the like are applied to the character generator outputs by the attribute logic 18, and the resultant pels are serialised to the video monitor. A number of operating system OS programs and application programs allow a computer to carry on multiple tasks simultaneously. For example, a background data processing task might be carried on with a foreground word processing task. Related to the background data processing task might be a graphics generation task for producing pie or bar charts from the data generated in the data processing task. The data in all these tasks might be merged to produce a single document. The multi tasking operating may be performed by a single computer such as one of the more popular micro computers now on the market, or it may be performed by a micro computer connected to a host computer. In the latter case, the host computer generally carries out the background data processing functions, while the micro computer carries out the foreground operations. By creating a composite display refresh buffer, the system shown in Figure 1 can also be used to display windows from multiple tasks. Each task is independent of the others and occupies non overlapping space in the system memory. User definable windows for the tasks resident in system memory can be constructed so as to display, within the limits imposed by the screen size, data from each of the tasks being processed. Figures 2A and 2B illustrate this concept. From the user perspective, windows can be displayed as either non overlapping, as shown in Figure 2A, or layered or overlapping, as shown in Figure 2B. It will be understood by those skilled in the art, however, that an overlapping display of the type shown in Figure 2B does not imply lost data in the system memory. On the contrary, it is necessary to preserve the data for each task so that as an occulting window is moved about the display screen or even removed from the display screen, the underlying display data can be viewed by updating the refresh buffer. While the implementation shown in Figure 1 is adequate for a class of use, it can become performance limited as the number of display windows and tasks is increased or as the display screen size is increased. As the time required to update the display refresh buffer significantly increases, system response time increases and therefore throughput decreases. Slower system response times can result from the following factors It is therefore an object of the present invention to provide a multiple data window display on a computer display that does not adversely effect the system response times as the number of data windows is increased or, in other words, to provide a multiple data window display that is especially effective for use in multi tasking environments. The foregoing can be attained by providing a multiple window display system including a repeatedly scanned display device, a screen buffer having display data element locations mapped directly onto the display areas of the display device and accessing means traversing the display data element locations in synchronism with the traverse of the display areas of the display device and a facility for compiling, from, potentially, a plurality of windows generated independently by individual respective users, an aggregate of data elements to be displayed, characterised in that the compiling facility is controlled by a picture matrix having compile control locations mapped directly onto the display areas of the display device and is directly responsive to the contents of the control locations to automatically filter the available data elements from the various windows, display area by display area. The term user is adopted to span task, processor or operator since to the display there is no apparent difference between these. The above can be achieved by both hardware and software arrangements. With respect to hardware implementation, plural screen buffers are simultaneously read out in a cyclic manner, and task selection means couples the output of a single one of the buffers to video output at any given time. For any given point on the screen, the data displayed originates from a selected buffer appropriate to the over all composition producing a screen picture compiled from more than one of the screen buffers. The task selection means may be a separate task selection buffer and decoder, in which case the task selection buffer is synchronously addressed with the screen buffers and the decoder enables the read out of a single one of the screen buffers for any point on the display screen. Alternatively, one of the screen buffers may be designated to perform the operation of the task selection buffer. The display data in the designated screen buffer is non transparent in the sense that it cannot, at a location corresponding to a given screen location, also be used for display data for that screen location, since that buffer location is loaded with unique selection code used to indicate one of the other buffers from which the data for that location is to be taken. The absence of one of these selection codes at the accessed non transparent buffer location allows the data at that location to be displayed, as a default condition, at the corresponding screen location. In this way, it will be apparent how the display is compiled from data, in part, from the non transparent buffer and, in part, from the other screen buffers. Software implementation makes extensive use of system memory. The system memory provides presentation spaces for receiving application data for plural windows of the displayable area. Each window defines the whole or a subset of a corresponding presentation space. A window priority matrix mapped to the display screen filters the data from the windows of the presentation spaces to the screen buffer to designate which of the data will be shown in corresponding positions of the display screen. In a hybrid version, display data filtering can be performed both on loading a screen buffer and also on selective read out of the screen buffers where more than one such is provided The arrangements described, whether prior art or according to the present invention, are for use with a CRT display. However, CRT displays are but one of many types of display, including gas panels and liquid crystal displays, to which the present invention may be applied. Therefore, those skilled in the art will understand that the mention of CRT displays is by way of example only. It follows therefore that the term refresh buffer, while having a particular meaning as applied to CRT displays, is fully equivalent to either a hardware or software screen buffer for storing data to be displayed. The problems of slow system response time for multiple display windows in a multi tasking environment are overcome by utilising the implementation shown in Figure 4 wherein the same reference numerals designate the same or similar circuits as in Figure 1. Each task is given a dedicated refresh buffer which can be directly addressed by the task. However, those skilled in the art will understand that this does not logically preclude including these addresses within a system memory map. Thus, there are provided screen refresh buffers 12₁ to 12 For display refresh purposes, all the refresh buffers are accessed in parallel. A task selection memory 24, having a location for each screen display area so that the contents of the task selection memory can be referred to as a screen matrix, is also accessed in parallel, via its selector 26, using the CRT controller produced address, to enable the output of a single selected refresh buffer. This is accomplished by means of decoder 28 which responds to the contents, which are essentially codes, read out of the locations as they are scanned in synchronism with the screen buffers, and, of course, the display itself, to generate enable outputs 1 to n. These enable outputs are provided to the corresponding refresh buffers 12₁ to 12 The main features of this scheme may be summarise as follows A simplified variation of the system shown in Figure 4 can be implemented as is shown in Figure 6. The task selection memory 24 is eliminated by designating one of the refresh buffers to be non transparent and effectively take the place of the task selection memory. In the case shown in Fig. 6, refresh buffer 12₁ is so designated. The decoder 28 is retained and a gate 30 is added. Unique filter codes, loaded into the non transparent refresh buffer, can then be used as the selection mechanism for the remaining transparent refresh buffers 12₂ to 12 In the implementation illustrated in Figure 7, only two discrete hardware buffers 12₁ and 12₂ are used, though extensive use of defined areas of homogeneous system memory is made and the filtering function, still determined by a screen matrix referenced 40 and maintained in memory is split between selection of what is loaded into one of the buffers, relatively speaking a one time function and which of the two buffers is to provide the current output to the screen, as in the previous embodiments. The effect is the same. Though more work is done in manipulating memory, this is offset by the reduction in the frequency at which it is performed. In the specific case illustrated, a micro computer connected to a host computer is assumed with buffer 12₂ being the micro computer buffer, but it will be understood by those skilled in the art that the pre buffer filtering under the control of the screen matrix can be applied also to a single computer with a single buffer, provided there is sufficient system memory available. As shown, this implementation employs screen control blocks 32, window control blocks 34, presentation space control blocks 36, presentation spaces 38, and a screen matrix 40. There may be, for example, ten screen control blocks and ten sets of window control blocks, one each for each screen layout. A given screen control block 32 points to a corresponding set of window control blocks 34. Each presentation space 38 has at least one window per screen layout. The presentation spaces, but not the windows, are common to all screens. The window control block 34, corresponding to a given presentation space 38 in that screen layout, defines the origin upper left hand corner of the window in the presentation space, the width and height of that window in the presentation space and the origin of the window on the display screen. The screen matrix 40 is a map of the data to be displayed and, in one embodiment, maps, on a one to one basis by character, that which is to be displayed on the CRT screen, but the mapping could be on a pel or any other basis. All display output from the several tasks is directed to memory and, specifically, to the presentation spaces 38 rather than to the hardware refresh buffer. In the arrangement illustrated in Fig. 7, a micro computer, such as the IBM R.T.M. Personal Computer PC , is assumed to be attached to a host computer such as an IBM 3270 computer via a controller such as an IBM 3274 controller. For this case, the PC hardware buffer 12₂ acts as the PC presentation space. Each presentation space is assigned an identification tag and has an associated window defined by the operator or an application program as to size and screen location. When the human operator or application program adjusts the windows relative to one another, the system builds an image in the screen matrix 40 consisting of the identifying tag aligned in the appropriate locations. The matrix 40 may be created in a reverse order from that appearing on the CRT screen allowing overlapping windows to be built up by overwriting. Alternatively, by using a compare function, the matrix 40 can be created by beginning with the uppermost window and so on, down through the overlay. The choice of the method of creating the matrix 40 is based on desired system performance. The system directs display output to the refresh buffer by filtering all screen updates through the screen matrix 40, allowing a performance increment in an overlapped window system by only allowing those characters that actually need to be changed or displayed on the screen to reach the refresh buffer.Those characters that are not currently required,do not reach the refresh buffer, will not cause an unnecessary redraw. The absence of these unnecessary redraws removes the requirement for continual updates of all windows whenever the contents of one is altered. In order to write a character, the IBM 3274 controller, a supervisor application or the PC writes character code into presentation space 38 at locations designated by that presentation space s cursor value control block. No other updates are required. the new character will be displayed or not according to whether it falls within the window designated by the corresponding window control block 34 and the portion of that window designated for display by the screen matrix 40. To use the PC buffer 12₂, a window control block is established for the PC the same as any other window control block 34 including width, height, presentation space origin, and screen origin. The screen matrix 40 is updated, and data from the window in the PC buffer defined by the window control block 34 will, to the extent allowed by the screen matrix 40, appear on the CRT screen. Data within a window may be scrolled by decrementing or incrementing the X or Y value of the window origin. No other control updates are needed. Only the corresponding window in the screen buffer is rewritten or, if a PC window, the offset register is changed. A window can be relocated on the screen by changing the origin coordinates in the window control block 34 for that window. The screen matrix 40 is updated, and the entire non PC screen buffer is rewritten with data for non PC tasks and codes hexadecimal FF for the PC. To enlarge the visible portion of a presentation space without scrolling, the window control block 34 for that presentation space 38 is first updated by altering the width and or height. This adds to the right or bottom of window only unless there is also a change in the origin of the window. Ordinarily, there is no change in the origin unless there is an overflow off the presentation space or screen, in which case, the corresponding origin is altered. Next, the screen matrix 40 is updated by over writing window designator codes of the matrix, starting with the lowest priority window control block. Then, all windows to non PC refresh buffer 12₁ are rewritten with data from the presentation space for the non PC windows and the hexadecimal code FF for the PC window. Figure 8 illustrates the general shape of the process for window updating. In block 42, the presentation space PS row is set to the first PS row needing update the screen row is set to the row on the display screen of the PS row the PS column is set to the first PS column needing update the screen column is set to the column on the screen of the PS column the number of rows is set to the number of PS rows to be updated and the number of columns is set to the number of PS columns to be updated. Then, the procedure which follows is done for the number of rows to be updated. For the number of columns to be updated, the matrix 40 is checked to determine if the screen row and column is within the window to be updated. This is indicated by the decision block 44. A test is made for the PC, since hardware buffer 12₂ is the presentation space for the PC, and the hexadecimal code FF is used to denote the PC window. If the decision of block 44 is yes, then the screen row and column are set to the PS row and column as indicated by block 46, and the screen column and the PS column are incremented as indicated by block 48 otherwise, the screen column and PS column are incremented without setting the screen row and column to the PS row and column. When this process is complete for the number of columns to be updated, the PS column is updated to the first PS column needing update as indicated by block 50. Then, the PS row is incremented, and the screen row is incremented as indicated by block 52. Figure 9 illustrates the general shape of the process for building the screen matrix 40. First, the window is set to the bottom window as indicated in block 54. Then for all windows not known to be hidden, the following procedure is performed. In block 56, the column is set to the first window column on the screen, and the row is set to the first window row on the screen. For the number of window rows, the procedure indicated within block 58 is followed, and this procedure includes the procedure indicated within block 60 for the number of window columns. In block 60, the matrix row and column is set to the window identification as indicated in block 62. Next, the column is incremented as indicated by block 64. Exiting block 60 but still within block 58, the column is set to the first window column on the screen as indicated by block 66. Then, the row is incremented as indicated by block 68. Now exiting block 58, the window is incremented to the next window as indicated by block 70. The function which draws the multiple window display is driven by any one of the following Application programs may cause the draw function to occur for cases 3 and 4 above by using the following functional calls These functional calls are set forth in detail below