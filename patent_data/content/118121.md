# IMPROVEMENTS IN OR RELATING TO AN APPARATUS FOR ENCODING AND DECODING SEQUENTIAL INFORMATION IN DATA HANDLING SYSTEMS

## Claims
Vorrichtung zum Bilden eines vergrößerten Satzes von selbstsynchronisierenden Code Symbolen von variabler Länge zur Verwendung bei einer sequentiellen Datenverarbeitung und insbesondere Datenübertragung,

## Description
The present invention relates to formation devices, translation devices, transmitter and receivers for forming, translating and communicating variable length augmented codes and fixed length depletion codes in data handling systems. The variable length augmented codes have the property of enabling character synchronization to be established substantially automatically upon applying simple decoding procedures. In the preferred form the present invention relates to applications of these codes to the encoding and serial transmission or storage of digitally represented data. Much literature has already been assembled on the subject of comma free codes and synchronizable codes. In the context of the following the term word will refer to any sequential ordering of characters which have been defined such that this ordering has significance in representing information content. It is possible that a word so defined will in the process of an encoding scheme be associated with characters taken from some further system of represention or character set. Thus the terms character and word or code and code word , depending on the context, may be interchangeable without introducing any ambiguity. A finite code is called synchronizable if and only if there exists a least integer m such that the knowledge of the last m characters of a message suffices to determine separation of code words. The concept of comma free codes was first introduced by Golomb et al Comma free codes Can. J. of Math, Vol. 10 pp 202 209, 1958 although Scholtz later suggested Mechanization of codes with bounded synchronization delays , IEEE T IT Vol. IT 16, pp 438 446 July 1970 that the term comma free could be interpreted to include any codes which can be used without resorting to the use of commas i.e. a special symbol or signal to mark character separation . It is this definition I have chosen to use, for while the codes introduced here do not comply with the definition provided by Golomb in 1958, they may in fact be used without resorting to the use of commas in accordance to Scholtz s interpretation. The term bounded synchronization delay BSD code describes any code for which any segment of a sequence of code words can be synchronized after observing at most d code symbols for some finite integer value of d. US Patent Specification No. 3 716 851 Neumann relates to the encoding of digital information and to encoders and decoders for coding informtion in near optimum variable length codes having self synchronization capabilities. Variable length sequential encoders are designed utilising basic variable length prefix code kernels. Code kernels are the fundamental codes which are used as a basis for construction or other codes. The mapping of such kernel words into the sequential input output matrix is designed to have certain properties which tend to maximize self synchronization. All code words corresponding to a given input value ore arranged to end in the same digit regardless of the corresponding output. This property aids in detecting the end of each code word and thus reduces the time necessary for resynchronization after errors occur. According to the present invention, there is provided a device according to claim 1 for forming an augmented set of self synchronizing variable length code symbols for use in sequential data handling and transmission as defined in claim 1 below. According to further aspect of the present invention, there is provided a device for forming depleted fixed length code symbols for data storage and manipulation as defined in claim 3 below. According to another aspect of the present invention, there are provided translation devices for translating from the augmented variable length code symbols to the depleted fixed length code symbols and vice versa as defined in claims 7 and 6 respectively. According to the present invention, there are yet further provided transmitters for transmitting data in the form of an augmented set of self synchronizing variable length code symbols as defined in claim 9 below. According to the present invention, there are yet further provided receivers for receiving and decoding variable length augmented codes according to claim 14 below. According to the present invention, there is further provided a receiver for establishing synchronization when decoding an incoming indefinite length string of variable length augmented codes according to claim 16 below. Important elements of embodiments of the invention are discussed below. The augmentation means for forming said augmented codes comprises a means to form a first set of unique character symbols, a means to repeat said first set of characters, a means to delete a selected character and to augment said repeated first set of characters by prefixing said repeated first set of characters with said deleted character to form an unambiguous code set, and a means to assign values to elements of said code set. The augmentation means further includes means to repeat said steps a selected number of times, said first set of unambiguous characters of one cycle of steps, other than in the first cycle, comprising the unambiguous code set of the preceding cycle of steps. The augmented character set resulting from repeated application of a single cycle of the augmentation process will hereinafter be referred to as an augmented set of degree q, where q is an integer equal to the number of times the augmentation process is repeated for the augmented character set. The means for forming a corresponding set of fixed length binary codes or depletion codes includes means for performing the steps of forming the complete list of 2 The means to first delete said binary codes in which the L least significant bits correspond to an integer w deletes only said binary codes for which said w satisfies the criterion that The means to group said remaining binary codes forms groups comprising exactly n codes each, and preferably said means to regroup said binary codes subsequent to said deletions in alternate groups forms said binary codes in groups double in size of previous grouping or regrouping cycle and includes in the code count for each group an allotted space corresponding to said deletions made previously in alternate groups. The means to delete said binary codes in alternate groups includes a deletion in the first group in each cycle, said cycle involving the steps of both grouping or regrouping and deleting, and deletions in the subsequent alternate groups corresponding in relative position within the respective groups to the said deletion in said first group. The means to delete said binary codes is limited to deleting just one code in each alternate group during each cycle, said cycle comprising the steps of grouping or regrouping and deleting. The means to repeat said cycle of grouping, or regrouping and deleting is limited to a total of q cycles. The coding means repeats said augmenting step a selected number of times, said first set of unambiguous characters of one cycle of steps, other than the first cycle comprising the unambiguous code set of the preceding cycle of steps. The means to determine point of synchronization comprises means to decode said augmented data sequence, using said augmented codes of degree k, starting said synchronization process with k 0 or 1, means to check for receipt of codes satisfying a predetermined criterion, and then means for decoding using the augmented codes of degrees k 1 if the predetermined criterion is met, means to repeat said decoding and checking process until the degree of said augmented code set involved in the decoding has reached a predetermined value q, at which point synchronization is deemed to have occurred. The means used for checking codes in said sequence includes means for checking if received code, as decoded using said augmentation set of a degree k for k q, is other than the k 1 prefix character as used in the next subsequent augmentation cycle i.e. the k 1 th augmentation generating said augmented set of degree k 1 , if said checked code is in fact not said k 1 th prefix then means to decode commences to use said augmented set of degree k 1 , if said checked code is identical to said k 1 th prefix then said means to decode continues to use said augmented set of degree k. Preferably said value q at which synchronization is deemed to have occurred is the same as the degree of augmented code set used to encode a data sequence to form said augmented code sequence. The invention will now be described by way of example with reference to the accompanying drawings, in which Figure 1 is a block diagram of a data transmission or data storage system according to the present invention. Figure 2 is a block diagram as for figure 1 with the encoder and decoder being in two parts. Figure 3a is a block diagram of a data channel encoder according to to the present invention. Figure 3b is a block diagram as for figure 3a with the encoder shown in two parts, there being an intermediate stage where the code sequence is represented in a depletion code form. Figure 4a is a block diagram of a data channel decoder according to the present invention. Figure 4b is a block diagram as for figure 4a with the decoder shown in two parts, there being an intermediate stage where the code sequence is represented in a depletion code form. Figure 5a is a block diagram showing an augmented code to source code decoder with code synchronization monitor, decoder controller, and optional error detection correction block. Figure 5d is a block diagram as for figure 5a with decoder shown in two parts as for figure 4b. Figure 6a is a block diagram of process for performing single level of set augmentation according to the present invention. Figure 6b is a block diagram of a process for performing multiple level set augmentation according to the present invention. Figure 7 is a block diagram of a depletion code generator using Read Only Memory listing of masked depletion prefix codes. Figure 7a is a diagramatic representation of the timing pulses on circuits C1, C2 and C3. Figure 8 is a block diagram of example encoding means using ROM. Figure 9a is a block diagram of example decoder to translate an augmented code sequence to a depletion code sequence. Figure 9b is a block diagram example of a decoding system to translate an augmented code sequence to a depletion code sequence. Figure 10 is a block diagram of example encoder using ROM. Figure 11a shows the phase amplitude states of a conventional 16 QAM system. Figure 11b shows the phase amplitude states in an improved version using the intermediate augmented codes of table 6. Consider a character set, C A procedure to produce an augmented set can begin by writing a word list consisting of the original character set C Next, one of the initial characters D Each word in the list is then assigned uniquely to one of the character symbols D An example of apparatus for performing the above augmentation algorithm is depicted in block diagram form in Figure 6a. An algebraic notation representing the construction of a code set from a initial set C If the set C Repeated application of the algorithm, q times, on a set C As a number of choices exists for any augmentation process the above notation will be seen to be ambiguous in this respect. However, in section XII hereinafter further notation is introduced for set designation thereby providing a means with which to resolve any such ambiguity which may otherwise exist. An example showing the repeated application of the augmentation algorithm is given, in Table 1 hereinafter where the binary set C⁰ 0.1 , i.e. containing the characters 0 and 1 , is used. An example of apparatus for performing multiple augmentation is depicted in block diagram form in Figure 6b. A significant property possessed by the augmented codes of the invention, is their ability to recover character synchronization automatically during the decoding process following any perturbation or break during serial comma free transmission of an encoded sequence. An example of the synchronization process is illustrated in table 2 hereinafter . If synchronization has been lost at some point during transmission and this noted by some means, then as the proof of theorem 3 hereinafter suggests, a means exists for determining which decoded character represents the start of the correctly decoded sequence following that break. Starting in the base set C⁰, one waits until receipt of the first non prefixing character. This marks the end of a valid common character boundary shared with the corresponding sequence of the next augmented character set, C¹. The process is repeated, each time moving to the next augmented set after the receipt of the nonprefixing character. This process is achieved in its most efficient form by proceeding to the highest available set C Finally one arrives at the desired decoding character set C This is not to say that if one were to have continued the decoding immediately following the break using only the set C The decription of the process above for determining the point of character correct synchronization is an example of the kind of process performed by the apparatus pictured in block form in Figures 5a and 5b as the synchronization monitor and source code decoder. It is convenient to introduce a notation for the size of a set. If a set C If C Finally where q is the degree set of augmentation Augmented binary code sets are of particular interest in this basically binary world of digital computers and communications systems using a binary number base. Here the base character set contains only the two elements 0, 1 C⁰ 0,1 . We now form an augmented set of the first degree according to the procedure outlined in section I. Table 1 shows this and also the further repeated application of the augmentation process producing an augmented binary character encoding scheme of the 4th degree, which is subsequently used to illustrate a number of the properties of the augmented codes. Table 1 shows an example of the construction of augmented binary codes of degrees q 1,2,3,4. Consider the character sequence L,H,C,M,B,D,I,... etc. using Table 1 we may simulate a fault in the transmission system as follows. Table 2 illustrates the capabilities of the augmented binary codes of degree q 4 from table 1, to recover character synchronization following a simulated error. In table 2 the received string is shown to omit the fifth data bit corresponding to a simulated error. Upon decoding the recovered character string is shown to have resynchronized in this case after only two incorrect characters. Other simulated errors may be tried such as scrambling, bit loss etc., and in each case the comma free codes displayed will resynchronize. A number of useful results may be derived for this family of augmented binary codes. Clearly the lengths of each of the subsequent prefixing characters are strictly dependent on the choice of previous prefixing characters, and it has not thus far been possible to express this in a simple algebraic form. For this reason, the statistical characteristics such as the average character size, assuming equal frequency of occurrence of each augmented code set will need to be evaluated specifically for the set at hand. The prefixing characters for the sets may be derived by simply following through the construction of the codes, in each case noting these as they are selected during the augmentation process. Clearly in the construction of the minimal augmented binary codes the first two possible prefixing characters are 0 and 1 , each of length 1. The next prefixing characters are of length 2 and the four possible codes are 00 , 01 , 10 , 11 of which only three will be available for prefixes for subsequent augmentation processes depending on the previous choice s of prefix. And so on. This is further illustrated in table 1. The method outlined below for constructing related block codes lends itself to the determination of both the augmented binary codes and the binary prefixing characters in a systematic manner using a digital computer. It also results in a further series of related codes which will herein be called the depleted codes. The following description exemplifies the depletion process for determining a set of depletion codes. It may be noted however, that the example, which is based on the augmented binary codes does not require the steps of deleting those surplus codes whose literal characters are illegal, i.e. those codes satisfying the criterion that the literal character, interpreted to be an integer w, is greater than or equal to the integer n where n is the number of characters in the base character set. Storing sets of irregularly sized character codes in a system which uses a fixed word format, such as the typical digital processors in use today, can be cumbersome. In a number of cases, where code construction is systematic and if processing time is available, it is possible to use an algorithm for generating the required representation at the particular instant it is required. The augmented binary codes may be represented in a block code form which is amenable to internal manipulation within a digital processor and which may be easily transformed into the variable length representation suitable for subsequent serial transmission or storage. Note that the example given next may be extended in kind, for augmented code sets resulting from a construction using a base character set other than the binary characters. Clearly, if there are 2 As shown in the following example it is possible to construct all the related block length codes and then consequently the associated variable length codes without making any reference to the augmentation algorithm proposed previously. This is done using an iterative depletion algorithm involving q repetitions, and producing what will be called the depleted fixed length codes of the qth degree. The following example will serve to demonstrate the algorithm. Initially, a complete list S, of codes of length q 1 are arranged in their respective numerically ascending order. The list of codes is then depleted according to the rules outlined hereinafter and illustrated as in the example of table 3, showing the construction of the depleted binary codes of the third degree denoted S 1,3,0 . Set specification will be given as listing in order the numerical entry of the code deleted according to the steps described next The codes in the list S are grouped into pairs. This is shown in the first column of table 3. A deletion is effected in each of the alternate groups at corresponding positions within each pair of codes and further constrained in that a deletion must occur within the first group. In column 2, the two possible choices for this step are shown with deletion marked with a D and the corresponding codes which are to be saved are marked with an S . Clearly there can only ever be two possible choices for the first step, and this corresponds to the existence of the anti symmetric families of augmented codes already mentioned. The resulting sets S 0 and S 1 , are next grouped into fours. This is shown in column 3 of table 3. For simplicity, the example is continued with set S 1 only although clearly set S 0 may be used similarly with the same rules and constraints applied. A further deletion is effected, again at corresponding positions in alternate groups and yet again with the constraint that a deletion must occur in the first group and must not occur at a position where a previous deletion has taken place. Obviously, the choice is reduced to one of the three remaining codes, since one has already been dispensed with in step 1. The possible options are shown in column 4. This yields the three distinct sets S 1,0 , S 1,2 , S 1,3 listed in column 5. Of course, by using the set S 0 , the three other antisymmetric sets S 0,1 , S 0,2 , S 0,3 are produced. In the third step, the codes are again regrouped, but now into groups of 8 or 2³. In this last step in the construction of the depleted codes of the third degree, for the sake of brevity only S 1,3 is considered. Here a possible choice of one of five codes is available. The set S 1,3,0 for example has been produced by deleting the first possible such character, 0000 . It is a simple process to prove the connection between the depleted fixed length codes and the augmented variable length codes and while such a proof has been omitted the details of the correspondence between these code sets are considered next and provide some useful techniques for implementing the serial encoding and decoding of the augmented binary codes. It will be clear from the above example that the steps may be extended to apply in the more general case of constructing the depleted code set of degree q. An example of apparatus for performing the steps generating depletion codes is depicted in Figure 7. A quick inspection of the depletion algorithm reveals that as required 2 Construction of block codes using the Depletion Algorithm Table 3 illustrates the application of the depletion algorithm in the construction of the depleted code set S 1,3,0 . The following comprises an example of the process of generating the augmented codes from the depletion codes. Implicit in the relationship between the two code types is the inverse process of deriving the depletion codes from augmented codes. Examples of apparatus for performing these transformations are depicted in block form in Figures 8, 9a and 9b. Examples of expected kinds of application are depicted in Figures 1 and 2 with example detail of the kinds of variations possible in the implementation of the encoding and decoding operations depicted in figures 3a, 3b, 4a, 4b, 5a and 5b. To understand the relationship between the Depleted and Augmented code sets it is necessary to associate at each step of the depletion process, a corresponding binary prefixing code with the deleted characters in each first group. These prefixing characters may be derived as follows. In any block code the least significant bit LSB will be interpreted literally as the LSB binary characters for the corresponding augmented code for instance in the code 0101 , where the LSB is a 1 this is directly interpreted as the LSB of the corresponding variable length prefix code. Each subsequent leading LSB in the block code will determine either the inclusion or omission of respective prefix characters in their respective order of selection. These can essentially only be determined in the order of selection. In table 3, the character deleted to produce set 2 was the code 0001 . The literal binary character 1 , is then saved as the first of the prefix characters. The leading LSB, i.e. the bit adjacent to the LSB is now used to denote the presence or absence of the previously determined prefix in this case the 1 . In step 2, the code deleted in the first group to produce the set S 1,3 was the code 0011 . Since the leading LSB, and the LSB are each set to 1 this code is interpreted to represent a new prefix created by appending in the order dictated by the block code, the last previous prefix a 1 appended to the literal binary character also in this case a 1 . Thus, for the example, the new prefix is This new prefix is now associated with the Step 3, shows the construction of set S 1,3,0 with the deletion of the character 0000 . Since none of the leading LSB s are set, no prefix characters are required to derive the third prefix which simply becomes the literal bit or LSB, 0 . This third prefix is noted and, as above, is associated with the next available leading LSB which is clearly the last remaining bit, in other words the MSB. At this stage any of the residual codes shown in S 1,3,0 may be interpreted to produce the equivalent variable length augmented code. As earlier, these are converted by interpreting the individual bits of a binary depletion code as implying either the inclusion or omission of corresponding prefixes and with the LSB interpreted literally as the LSB of the resulting variable length code. An example of the conversion from the block code 1010 to the corresponding variable length code is shown in table 4. As before, each of the bits in the block code is interpreted to indicate either the inclusion or omission of the corresponding prefix and the LSB is interpreted literally, and is directly transferred as the last bit in the sequence. Block code 1010 corresponds to the augmented code 010 Some example applications using the augmented binary codes are discussed briefly next showing typical implementations of serial encoding and decoding in communication and data storage systems. Figure 1 depicts a block diagram for a general communications system of the kind considered here. In particular it is convenient to view such a system with the encoding means or encoder and decoding means or decoder split into two as in figure 2. In principle many communications systems require few changes to be able to take advantage of the augmented codes and the subsequent synchronization capabilities possessed by the augmented codes herein. For example, the insertion of the extra processing blocks of figures 3 and 4 in the data paths connecting the source and channel encoders and the channel and source decoders respectively of figure 2 suffices. The functions of these extra processing blocks are respectively i to encode the incoming source data into an appropriate augmented binary set, and ii to decode the received or replayed augmented codes to the corresponding outgoing source data sequence. An example of a system, such as is depicted in figure 2 is the acoustically coupled 300 baud terminal modem modem computer link via a transmission means such as a telephone network. Here, a means such as a frequency shift keying FSK is used in the bidirectional channel encoder and decoder as a method for encoding asynchronous serial binary data. The binary data at the terminal modem or modem computer interface is most usually a 7 bit ASCII data word marked using a single low start bit and followed by two high stop bits. A sequence of characters thus encoded uses 10 bits character and may be sent asynchronously since the process for decoding in a decoding means is cued by detection of the low start bit. For the most part character synchronization is established simply, because of the low data exchange rates. Large periods of time are spent with the data channel idle so that the presence of a character is marked unambiguously by the low start bit. However, during periods when the data channel is working to capacity, it is much more difficult to identify with certainty the correct character boundaries. For the most part, if character synchronization is established at the start of such a transmission the data is readily interpreted, but if synchronization is for some reason lost during the course of a sustained character transmission it may not be until the transmission is complete that character synchronization can be re established. Loss of synchronization is invariably caused by false start bit detection due to some channel disturbance or noise. With characters each encoded as fixed length words it is often simply a matter of chance as to whether the receiving device will recover character synchronization during a sustained transmission. The performance of the above system is improved considerably with the application of a suitable set of augmented binary codes as described by way of the example next. Clearly, the augmented binary codes have the right kind of properties for an application such as the one above. Each of the 129 codes in the 7th degree set may be assigned to the standard 128 ASCII codes with a single character conveniently left available for transmission during the times the channel is idle. Thus at all times some augmented character will be transmitted even if no actual information is exchanged. Table 5 for example, shows one such assignment of the ASCII codes. The first column shows the printing character or control character mnemonic followed by the octal and hexadecimal representations of the ASCII binary code in column 2. The 4th and 5th and 6th columns list in octal, hex binary, the block codes respectively corresponding to the variable length augmented codes of column 7. The respective prefix characters for this particular construction are, in the order corresponding to the block code references Table 5 lists an assignment of the 128 ASCII American Standard Codes for Information Interchange character codes to seventh degree set of depleted codes and augmented binary codes. For example consider the process of generating the augmented code for the letter p having the ASCII octal representation 160₈. This for example may be used as an index in a look up table or ROM Read Only Memory to locate the corresponding block code, 056₈ shown in column 3. As demonstrated earlier the individual bits in the binary block code represent the inclusion or omission of the above corresponding prefixes, with the exception of the LSB which is in fact simply transferred over to become the LSB in the variable length code. While the character assignment given in table 5 is not necessarily optimal for all computer applications it does represent a reasonable choice based largely on commonly available figures for the frequency of occurrence of the alphabetic characters. The example serves to illustrate the kinds of advantages possible when using the augmented codes. Without making the distinction between the upper and lower case of the alphabet characters and by estimating the relative frequency of occurrence of the control characters, it has been possible to assign the ASCII characters to take advantage of the variable lengths of the augmented codes. The fill character has been assigned one of the shortest character lengths and one in particular which will avoid a sustained error echo condition. Since E and T are rarely found repeated as capitals they have been assigned to the augmented codes 0000 and 1111 respectively and this avoids a situation where the error echo condition could be sustained. In table 5 all of the alpha numeric characters have been placed in the first half of the list and use codes of between 4 and 9 bits long. Thus, a substantially better efficiency of representation is possible for alpha numeric text than that of the 10 bits character used in the standard asynchronous ASCII encoding mentioned in section XIII. If the first 65 characters of table 5 are assumed to occur with equal frequency the average length is 6.95 bits character which compares favorably with the raw 7 bit ASCII code. The 6.95 bits character represents a 44 improvement in the character transmission rate if comparing with the 10 bits character ordinarily used. Alternatively the improvement may be compared to an increase in the bit transmission rate of from 300 baud to something greater than 430 baud. Yet all we have done is change the encoding scheme. Weighting each character length with the expected frequency of occurrence for example the letter e occurs about 13 of the time the average character size for text is found to approach 5.45 bits character or equivalently an increase in efficiency of 83 over the 10 bits character rate. This is equivalent to increasing the bit rate, assuming the existing technology in the 300 baud MODEM, to about 550 baud. Ordinarily, most communications systems using the augmented codes will allow some optimization to be made in terms of the frequency of use of the various characters and the variable character lengths available for their representation. In any case it should not be overlooked that the real improvement resulting from the use of these codes lies in their ability to recover synchronization following any kind of channel disturbance and essentially irrespective of the transmitted data. That the data transmission rate may also be improved through using the augmented codes herein described, is incidental and comes about primarily because of the redundancy that must be added in other coding schemes to determine correct data synchronization. In the previous application we have ignored the question of bit synchronization. Obviously, at the character level the system behaves essentially as if it were asynchronous. However, at the bit level the system must be bit synchronous. In the character assignment given in table 5 the codes have been ordered to minimize the condition of error echo which by the same token maximizes the likelihood of bit transitions. Naturally this is of essence if the receiver is to maintain bit synchronization. With the given character assignment it is unlikely that more than 10 15 bits will pass by without at least one transition occurring to provide synchronization information. Certainly this is not an impossible or even an especially difficult technical constraint to meet in terms of the accuracy of the encoder and decoder oscillator frequencies and the previous application is easily possible. In a more demanding communications protocol it may be necessary to include the data clock information with the data itself. One such scheme is the Bi Ø L Bi Phase Level binary encoding representation such as is used in the local area network Ethernet . In this Bi Ø L encoding scheme it is possible to determine with absolute certainty the first character guaranteed to be correct following a break in the transmission, where the break may be detected from the loss of the data clock. In a conventional 9600 baud modem, the synchronous transmission of sixteen distinct character states may be achieved through amplitude and phase modulation of a carrier tone at a line signalling speed of 2400 symbols per second. The above modulation system, sometimes designated 16 QAM Quadrature Amplitude Modulation , operates synchronously with the data clocked by a phase modulation in the carrier tone occurring at unit time intervals. In figure 11a, the x axis is taken to be the relative phase of the carrier tone during the last previous 4 bit character and in the following symbol period the phase of the character is shifted to one of the 12 radial phase vectors shown at 30 degree intervals and offset from the x axis by a further 15 degrees. These phase states offer a possible twelve data states with four of the twelve further augmented by two levels of amplitude modulation of the carrier to produce a more suitable number of sixteen amplitude phase states. In relation to the augmented binary codes an improved version can be considered based on the same concepts of Quatrature Amplitude Modulation of a carrier tone. Figure 11b shows five of the twelve phase states with two levels of amplitude modulation producing a complement of seventeen states labelled A through Q and shown with the augmented binary codes of the fourth degree of table 6. Table 6 also includes the 5 bit block code or depletion code representations for reference. Table 6 lists an intermediate augmented binary set. From earlier results it will be immediately apparent that the same code set is related to the augmented binary codes of the seventh degree shown in table 5. A further three augmentations performed using the 17 character set in table 6 yields the full 129 codes given in table 5. Codes such as those in table 6 will herein be said to be intermediate to those of a higher degree of augmentation, such as in this case the codes of table 5. In this example the prefix characters to be used in consecutive augmentations to obtain the codes in table 5 are A, B and C respectively of table 6. It will be obvious that the block codes of table 5 contain, as the low order bits, the corresponding block codes listed in table 6. Since the characters, A, B and C in table 6 have special significance in this example as prefix characters they have been assigned complementary positions on the phase plane figure 11b maximizing the margin of phase discrimination and in turn minimizing the possibility of sustaining an error condition resulting for example from the mistaken substitution of one prefix for another. The remaining characters in the 17 character set have been assigned arbitrarily, although it should be noted that the fill character, 0001 , of table 5 which corresponds to E of table 6, represents an advance in the carrier phase of 15 degrees every unit time period. Thus, it is possible to transmit all of the ASCII character codes in terms of the intermediate characters of table 6. Depending on the particular ASCII character being encoded, these will form as one, two, three or at most four of the intermediate characters. An algorithm can be developed for determining with certainty character correct synchronization i.e. the point following which all decoded characters are guaranteed correct. The algorithm provides a basis for evaluating the expected synchronization delays in which a probability transition matrix P is used to describe the likelihood of level transitions as shown in table 8. Finally, the concepts are applied to the problem of determining synchronization in conventional telemetry streams. In an example a procedure, considered to be optimal for such an application, is developed and demonstrated. The example showing the construction of the code set S 1,3,0 of the 3rd degree, using the depletion algorithm furnished as in table 3 will suffice to demonstrate the development of an algorithm for determining character correct synchronization. Only the sets pertaining directly to the construction of the desired depleted code set need be considered. Thus, in considering the synchronization algorithm for the set S 1,3,0 in table 3 only the sets S, S 1 , S 1,3 , and S 1,3,0 are required. The procedure for developing the synchronization algorithm begins with the purging of all of the non essential codes which may be identified as being those following each first group boundary in each of the respective lists. The result of the purge in the sets S, S 1 , S 1,3 and S 1,3,0 of table 3 is shown below in table 7. Table 7 illustrates the clearing of the non essential codes in preparation for establishing a transition diagram for determining character correct synchronization. The D markings have been preserved during this step as they are important in determining available transitions between the code lists in the process of determining synchronization. The respective lists have been labelled for convenience as level 0 through to level 3 and correspond to the augmented codes of the corresponding degree. Allowable transition paths are indicated by the insertion of arrows connecting corresponding codes in adjacent lists, and terminating the path at any code flagged by a D . Determining character correct synchronization involves starting in level 0 and then, when an appropriate code is received, moving to the highest possible level indicated by the corresponding transition. At the point when level 3 is reached character correct synchronization has been established. Table 8 illustrates the determining of the valid transitions. The process of determining character correct synchronization always begins with a character search from the left most list, level 0. A level transition, where each level corresponds to a set whose degree of augmentation is given by the level number as in table 8 , may occur such that the level is always increased by a transition. Each transition is initiated by the receipt of a code listed in the current level for which a transition path is shown corresponding to that particular code. Once a transition is initiated the indicated path is followed until the right most position is reached whether terminated by a D or simply because one has reached level 3. While it is certainly possible to limit the transition step size to single level increments the most efficient process for determining synchronization follows from always moving to the right most level attainable for each given transition. Table 9 shows the equivalent information of table 8 but with the block codes replaced with the corresponding variable length codes produced using the prefix codes 1,11,0 for the set S 1,3,0 . Table 9 lists the augmented code sets in example of a completed transition diagram. For example, assume for the moment that a break has occurred in the transmission of a serial binary stream of data encoded using the augmented set S 1,3,0 , and that, following the resumption of transmission, it is necessary to determine character correct synchronization. If, following the break, the first bit received is a 0 then starting Level 0 it is found that the code 0 listed provides a transition path leading all the way through to level 2. The code search now continues using the level 2 character codes. To proceed successfully through to level 3, either a 10 , 110 , 1110 or a 1111 must be received. Alternatively, if a 1 occurs immediately following the break while this is also listed in level 0, no transition path is available for a level shift and the search remains in level 0. It will be apparent that in this particular transition map a code search will never take place at level 1, unless one specifically chooses to pause at the intermediate position on the path leading from level 0 through to level 2 corresponding to the augmented code 0 . This is simply a consequence of the particular construction of the set S 1,3,0 . In the construction of the minimal sets of augmented binary codes however, a path structure is produced enabling all of the intermediate levels to be accessed form preceding levels, although particular synchronization paths may well skip intermediate levels in the course of synchronization. Essentially, any data handling system using augmented codes in the decoding apparatus, as illustrated in 4a and 4b, may include optionally further apparatus for performing character synchronization monitoring and decoding control, as described above and this is further illustrated in figures 5a and 5b. The codes herein presented have still further utility in applications involving closed code rings. An example of a closed code ring, such as is shown in table 10, may be formed by connecting the two ends of a finite code string W C⁰ , such as the following which has been coded using the augmented binary code of the seventh degree using the augmented binary code of table 5. It will be clear then that following a short period of synchronization the decoded sequence of data from the ring will be unique and repeat precisely with each completed cycle. Further, it will be clear that exactly an integral number of characters is decoded from the ring regardless of the size of the ring, provided that the ring is not smaller than some integer lower bound B corresponding in some manner to the augmentation set in use. Table 10 illustrates decoding the ring using codes of table 5. If the ring is decoded starting at some arbitrary point as shown in table 11 then following a short period of synchronization, usually two or three characters long, character correct synchronization will have occurred and the correct string resumes. Many applications of this nature are possible using the codes herein described, and include shaft encoders, magnetic disk storage systems, bubble memories, charge coupled systems, dynamic refresh memories, and so on. Also possible applications include methods or apparatus involved in the cataloguing and processing of DNA sequences, particularly closed ring DNA sequences such as in plasmids or bacteriophages. The power of the augmented codes and the related block codes should be clear. If a message or information string comprising a sequential listing of symbolic characters be they electronic represented or whatever, is encoded using a coding scheme such as described herein, then the message may be transmitted and stored for subsequent recovery with the ability for character synchronization to be established and maintained even in the presence of occasional channel disruptions. The significance of the codes lies in the fact that each has been unambiguously defined in terms of a serial representation of base characters according to algorithms herein detailed. Examples included here show the codes to be particularly suitable for serial transmission or storage of serial data. A depletion algorithm provides a convenient method of constructing and manipulating the sets of augmented codes in machines using fixed word sizes. Certainly the complete decoding and encoding processes could be implemented in a single programmable silicon ship preferably with a suitable interface for an 8 bit microcomputer, providing all of the convenience of and a superior performance to the traditional UART s Universal Asynchronous Receiver and Transmitter and USART s Universal Synchronous and Asynchronous Receiver and Transmitter . The coding system of the present invention would be used in applications such as general digital encoding, remote computer and computer terminal and peripheral interface, data text transmission and storage, disk memory systems, magnetic tape systems, laser disk systems and so on. Further applications to cyclical systems have been suggested earlier and include, shaft encoders, tachometers, DNA cataloguing and string searching, and so on. A further very significant area for application of the augmented codes is in conjunction with the digitizing of analog information and subsequent encoding for transmission or storage. This will have an impact on voice transmission systems, music recording systems, video systems and so on. Still another important application includes using the codes for the construction of variable length instructions for micro computers, computers and or other processors such that the accidental issinterpretation of bus data is partially compensated for by the assurance that the processor will after several instructions resume the execution of correct program material. This will be especially important where digital processors are used in electrically noisy environments and where data integrity is of particular significance. In the area of digital processing, the codes will be useful especially in applications involving string or pattern searches within sequential information or data. Here the string handling apparatus may utilize the synchronization capabilities of the codes to pack the sequential decoded data using the depletion code representations into fixed word size storage elements. The data processing system may then perform standard algorithms for pattern searching on the depletion code sequences with improved storage and processing efficiencies. Figures 1 10 represent simplified block diagrams of means and methods for encoding and decoding sequential information in data handling systems. The block diagrams may represent hardware implementations, firm wired software implementations, or purely software implementations, in a multi purpose digital processor. They are intended to be representative characterizations of means for implementing the generic methods set forth in the specification and claims. Figure 1 illustrates a block diagram of a communications or storage system utilizing a source, which may be the output of a CPU, or a keyboard wherein the output of the source 11 is passed to an encoder 12 for converting the source code into first an augmented code form and then into a form suitable for passing to the data channel or data storage system delineated as 13. The variable length augmented code is particularly suited for data transmission over data channels or data storage. The fixed length block code or depleted code is particularly suited for the storage system. The decoder 14 is the converse of the encoder 12 and restores the variable length code to source code or fixed length block code depending upon the destination 15. Destination 15 may be another CPU, a disk storage means, or a computer terminal utilizing ASCII codes. Figure 2 represents a more conventional data communication system having a source 11 and a source encoder 12 which converts the source code eminating from 11 into the variable length augmented code. Channel encoder 16 represents a modem or other means of converting binary digital pulses into analog signals for transmission over a conventional data link 17 such as a telephone line or a microwave link. The channel decoder 18 is also a modem which translates the variations in frequency from frequency shift keying or variations in phase and amplitude from a quadrature amplitude modulation into variable length augmented code words of binary data for the source decoder 14. Source decoder 14 then converts the variable length augmented code to either a source code or a fixed length depleted block code for destination 15. Figures 3a, 3b expand upon the encoder 12 illustrated in Figures 1 and 2. As indicated in Figure 3a, the encoder 12 can be a simple lookup table or data array which is addressable via the given characters of the given source code. Upon receiving the address, the table or array provides the corresponding augmented code sequence out. Encoder 12 may also be a hardware implementation, a firm ware implementation, or a software implementation of the algorithm for generating the variable length code from a given source code. Figure 3b illustrates a source code to augmented code sequence encoder that utilizes the intermediate depletion code representation which may be useful in data handling or storage. The incoming source code is converted to the depleted block codes by the source depletion sequence encoder 20 to generate a depletion code sequence. The depletion to augmented code sequence encoder 21 may be either a lookup table or a hardware, firm ware, or software implementation of the algorithm for generating the augmented variable code from the depletion code as hereinbefore previously described. Likewise, Figure 4a illustrates the decoder 14 of Figures 1 and 2 which receives the augmented code and provides a source code sequence. The decoder 14 is a lookup table or data array that is addressable by the variable length augmented code to provide a source code sequence out. Alternately, as hereinafter described, the decoder may include a synchronizing means for reestablishing synchronization. Figure 4b represents an augmented code to source code decoder using an intermediate depletion code representation wherein the augmented code is converted to depletion code by either a lookup table or hardware, firm ware, or software implementing an algorithm for converting the augmented code to a given depletion code. The depletion code is then furnished to the depletion to source code decoder 23 which is conventionally a lookup table or data array. Figure 5 illustrates an augmented code to source code decoder with code synchronization. In addition, an optional error, detection and correction system for reestablishing synchronization after error detection is also disclosed. The optional error detection and correction system operates independently of the self synchronizing nature of the augmented codes. Many computer manufacturers provide specific characters, phase encoding, or parity detection systems to indicate transmission errors. The present invention operates independently of these optional error coding detection and correction systems. Figure 5a illustrates the manner in which the error detection system is incorporated into the decoding system. As indicated previously, the decoder 14 receives an augmented code sequence in and provides a source code sequence out. However in contrast to the earlier description of the decoder 14 additional functional control and status information is available at the interface between the decoder 14 and the code synchronization monitor and decoder controller 25. Firstly, the decoder 14 is capable of being switched between the augmented code sets ranging from C⁰ ... to C The code synchronization monitor and decoder controller 25 comprises two devices. The first device is a decoder controller which may switch the level of the decoder 14 in accordance with a predetermined criterion. The second device monitors the decoded code sequence and provides an output to increment the decoder controller whenever the monitored code word is found not to correspond to the prefix character of the next subsequently higher augmented code level. The second device is further capable of responding in the event of an error or break in communications by initiating the re synchronization process whereby the decoder controller is set to select the lowest decoding level corresponding to the base code C⁰ . The monitor then examines each code produced by the decoder, and corresponding to the selected decoding level, until a non prefix bit is received. The monitor then increments the decoder controller to the highest possible level for which the same received bit is still deemed to be a non prefix bit. The decoding continues in this new level and the decoder monitor again determines whether the next decoded bit sequence is a non prefix code, that is a code other than the prefix code for the next subsequently higher level of augmneted code. This process continues until the selected decoding level has been incremented to q, at which time the decoded characters are known to be in sync. It should be noted that the synchronization monitor and decoder controller 25 may be triggered by events in the decoder 14 or may infact be triggered by the optional error detection correction device 24. The status of the decoder and synchronization level are further made available to the optional error detection or correction device 24. Figure 5b is an illustration of an augmented code to source code decoder with an intermediate depletion code representation. The intermediate depletion to source code decoder provides the ability to use the source code for data storage in the event it is desired to capture an incoming file, or for subsequent CPU processing in the event the central processor is using the depletion code characters rather than other conventional codes such as the ASCII code or EBCDIC code. It should be noted that the depleted block codes may be used as general purpose characters in the computer rather than the ASCII or EBCDIC characters. In some environments, it may be desirable to send the depleted block codes along a parallel bus path such as indicated at 26 when the computer is used in a particularly noisy environment. The depletion to source code decoder 23 provides a conversion between the depletion code and the source code when it is necessary to convert to a more conventional source code device such as ASCII for a peripheral such as a printer or a CRT display. The operation of the code synchronization monitor and decoder controller 25 is as previously described with respect to Figure 5a. Figure 6a and 6b disclose block diagrams for forming single and multiple levels of augmentation on a source code character set. The devices disclosed in Figures 6a and 6b are identical except for the multiple level of augmentations performed. The device illustrated in Figure 6b will generate the augmented codes to be loaded in the ROM lookup table of Figures 8, 9a and 10. The base character set n indicated at 28 may be binary, or may be any additional initial character set C⁰ that is desired to be augmented. The additional base character set is supplied to the input code means 29, and control logic 30 selects through the system control 31, the prefix that is to be deleted from the initial code set and added to the replicated code set. The code symbol to become a prefix is directed by the control logic 30 to the prefix buffer 32, and the remaining members of the input code set are written into the code buffer 33. The first character set C⁰, minus the deleted character set is then transmitted out of the code buffer and through the prefixing processor 34 to the output code set 35. The remaining portion of the augmented first level C⁰ is then formed by control logic 30 which writes the input code set in 29 back into code buffer 33. As the original set C⁰ passes through the prefixing processor 34 the second time, it affixes the prefix present in prefix buffer 32 to each character read into the output code set 35. At the completion of this prefixing operation, the output code set present in 35 represents the first level augmentation C¹. C¹ is then routed by control logic 30 back to the input code set via bus 36. The process is then repeated with code set C¹ to provide a second level of augmentation. The levels of augmentation are determined by the control logic and system control 31. Thus, the operator may select both the deleted codes and the level of augmentation to be performed to create the variable length augmented code set. In addition, the prefixes utilized in prefix buffer 32 may also be stored for each level of augmentation, and these prefixes may be utilized to create the masker prefix codes used in the depletion code sequence. As illustrated in Figure 6b, the input code set 29 provides a means for receiving the original character set C⁰ and subsequent character sets C¹... to C Figure 7 is an illustration of one means of generating fixed length depletion codes or block codes that may be used in data processing systems or for data storage. As illustrated in Figure 7, the clock generator generates three signals, C¹, C², and C³, the interrelationship of which is illustrated in Figure 7a. Signal C³ is used to count out the number of symbols m 1 to be used in the final depletion code wherein 2 The code masker passes on the least significant portion of the code received previously from 39 to the comparator 38. The length of the portion passed from the code masker to the comparator is a function of which masked prefix code is selected, as determined by 38. Simultaneously, the masked prefix code is transmitted to comparator 42 along input line b. The comparator then compares the signal on input a and input b, and when the signals are not equal, it enables the depletion code output register 43 to load a valid depletion code from the depletion code counter 39. The entire process is repeated with each load pulse from clock generator 37 along signal line C². Figure 8 illustrates a block diagram of depletion to augmented code sequence encoder as previously described in Figure 3b. As illustrated in Figure 8, the depletion code is first stored in input buffer 46 which then simultaneously indexes two ROM lookup tables, 47 and 48. ROM 47 contains a variable length augmented code symbol that corresponds to each of the depleted codes. ROM 48 contains the length in digits of the variable length codes stored at the same address in ROM 47. The output of ROM 48 relating to the code length is then fed to counter 49 which sends a control pulse and a code length signal to shift register 50 to prepare the register for receiving the new augmented code from ROM table 47. As each new variable length augmented code is loaded into shift register 50, a load signal is returned to the input buffer in code register 46 to load a new depletion code for translation. Figure 9a is a block diagram illustrating one means that will translate the augmented code into depletion code by means of a ROM lookup table, The augmented code, being of variable length is first loaded in the input code buffer 51. Inasmuch as the length of the augmented code will vary, the elapsed time used to translate the code will vary, and some means is needed to restart the loading sequence with each new word. In addition, it is impossible for the input code buffer 51 to know when a complete word has been assembled inasmuch as the length of the word is, at this point, variable. ROM lookup table 52 contains both the augmented code by length, and its corresponding depletion code. Each of the bits is examined in order until a match is found for the augmented code, and when the match has been ascertained, the code length for that match is fed over data bus 53 to the counter 54. Counter 54 then supplies a control pulse back to control logic 55 indicating that a match has been found for the augmented code, and signalling control logic 55 for a new word to be loaded from input code buffer 51 to the ROM table 52. When the means illustrated in Figure 9a is used in the ASCII environment, an augmented code having seven levels of augmentation, will result in 129 variable length code symbols, the longest of which is 15 bits. Thus, ROM 52 will always be reloaded to at least 15 bits from input code buffer 51 each time control logic 55 indicates a new word. The number of bits loaded from input code buffer 51 to ROM 52 will vary from word to word as the words are translated. When ROM 52 identifies a match, the corresponding depletion code is provided to output buffer 56, and the entire process is repeated beginning with the variable loading between input code buffer 51 and ROM table 52. Figure 9b illustrates a block diagram of a decoding process in which an input sequence of augmented codes is decoded to a sequence of depletion codes by a ROM prefix listing. As illustrated in Figure 9a, the ROM listing must be large enough to contain C As illustrated above, the prefix codes 101, 100...0 represent the prefix codes for seven levels of augmentation. The augmented variable length code is 1100101. This variable length code is received by the input buffer 57 and control logic 58 is activated. The seven prefix codes noted above are listed in the ROM prefix listing, together with the number of characters occupied by each of the prefixes and the designated position represented by each in the depleted block code. The operation is essentially the inverse of the operation previously described on page 38. After the input buffer 57 has been loaded with 1100101, the control logic 58 calls for the highest level prefix for the most significant bit which in the case illustrated is 101. This prefix is then supplied by the ROM prefix listing 59 to the comparator 60. Simultaneously, the prefix length is supplied along the masked length circuit to code masker 61. Simultaneously, control logic 58 writes the variable length word present in the input buffer into the code masker 61. Code masker 61 then sends the three most significant bits to the comparator 60 which compares the three most significant bits in the input buffer with the seventh level prefix from the ROM prefix listing 59. As indicated previously, the three most significant bits in the input buffer are 110, and the seventh level depletion is 101. Since comparator 60 does not find a match, it signals the control logic that no match is found, and control logic 58 then enables the prefix selection, and a 0 is provided to the left most designated position of the depletion code in depletion code register 62. Control logic 58 then initiates the search for the sixth level of augmentation and ROM prefix listing 59 provides the sixth level listing of 100 to the comparator 60 and a mask length of three most significant bits to the code masker 61. Inasmuch as the three most significant bits present in the code masker are still 110, comparator 60 will find no match, and will signal control logic 58 which will in turn enable the prefix selection code and cause a second zero to be entered into the second most significant bit position, at depletion code register 62. Each prefix is associated or designated to a specific bit location in the depleted block code, both the highest level prefix designated to the most significant bit. Control logic 58 then calls for the fifth level depletion prefix code which can be seen from the foregoing table is 11. ROM prefix listing 59 will forward 11 to comparator 60, and signal code masker 61 that only the two most significant digits are to be examined. Code masker 61 will then select the two most significant digits from the augmented input signal which are 11, and comparator 60 will find a match. The match is then communicated to control logic 58 over the comparator output, and control logic 58 will then load a 1 into the depletion code 62 indicating that a prefix exists for that position. Control logic 58 will then index the code masker 61 two positions and will send the fourth level prefix 01 to the comparator 60. Code masker 61 will then examine the third and fourth positions from the left and input buffer 57 will provide 00 to comparator 60. Comparator 60 will again indicate that no match is found and control logic 58 will signal a 0 to be loaded in the designated position of the depletion code. Control logic 58 will then select the third level prefix code 00 which will be furnished to comparator 60 and code masker 61 will again furnish 00 to comparator 60. Comparator 60 will then signal a match to control logic 58 which will again load a 1 in the designated position of depletion code resister indicating that a prefix code exists for this position in the depletion code. Control logic 58 again loads the prefix code for the second level depletion which is a single 1, and indexes the code masker 61 to examine the fifth digit from the left, inasmuch as matches have been found for 11 and 00. ROM prefix listing 59 provides a 1 to comparator 60 and code masker will also find a 1 for the fifth position of the augmented code. Comparator 60 will signal a match to control logic 58 which will provide a significant bit or 1 to the depletion code 62 indicating a prefix exists for the sixth position of the augmented code, as read from the left. Finally, the control logic 58 will signal the ROM prefix list to send the first level prefix code 0 to comparator 60, and will index the code masker to the sixth position of the augmented code. Inasmuch as this position is also a 0, comparator 60 will again find the match and will signal control logic 58 which will place a 1 in the seventh position of the depletion code indicating the prefix exists for this position. Finally, control logic 58 will enable the literal code to become the least significant bit of depletion code 62 and will simultaneously signal that the output of the depletion code is ready to send. As the depletion code 62 is set, a new augmented code may be loaded in input buffer 57. Figure 10 illustrates a block diagram of an encoder using read only memory to translate source code into augmented code. The operation of this circuit is essentially the same as the operation of the circuit described in Figure 8. The source code is first loaded in input buffer 63 which simultaneously accesses two ROM lookup tables 64 and 65. ROM lookup table 64 contains the variable length augmented code symbol assigned to the incoming source code. The code length ROM 65 contains the length of the variable length augmented code present in ROM lookup table 64. The code length is then supplied to counter 66 which signals shift register 67 to accept an augmented code corresponding to the length of the variable length augmented code present in ROM 64. As the augmented code is transmitted from shift register 67, a new source code character is then loaded in input buffer 63.