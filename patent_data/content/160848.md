# Computer systems for curve solid classification and solid modeling

## Claims
System zur Darstellung mehrdimensionaler Objekte wobei folgendes vorgesehen ist Darstellung von Bildern solcher Objekte aus den Schnitten von Kurven mit primitiven Körpern solids und aus Bool schen Satz oder Mengenoperationen an den Schnitten aus denen das Objekt konstruiert werden kann was primitive Klassifikationsmittel PC aufweist zur Berechnung der Schnitte einer Vielzahl von Kurven mit den primitiven Körpern, eine Vielzahl von Mitteln cc Fig. 6 zur Berechnung der Klassifikationskombinationen und zwar in entsprechender Weise angeordnet mit den primitiven Klassifikationsmitteln in einem binären Baum der das Objekt durch konstruktive Körper Geometrie definiert, wobei die Klassifikationskombinations Berechnungsmittel jeweils einem unterschiedlichen Verzweigungspunkt Knoten des Baums entsprechen und programierbare Mittel Fig. 8 aufweisen zur Berechnung einer Mengenoperation für ihren entsprechenden Knoten.

## Description
The present invention relates to computer systems for characterizing plural dimensional objects, including providing image representations of such plural two or three dimensional objects by solid modeling and particularly to the processor for such systems which compute the intersections of curves with solid objects for generating data from which such representations can be provided. The invention is useful in the generation of images of solids on a cathode ray tube CRT or a graphic hard copy read out device printer or other graphic display for computer aided design, computer assisted manufacturing CAD CAM applications. It may be used for robot and machine tool simulation in order to program a robot for use in a working area without collision and interferences. It may also be used in the generation of character fonts with high resolution by characterizing each letter in the font as a tree of two dimensional objects circles squares, triangles, etc. . The invention may also find application wherever displays, mass properties of solids, boundary evaluation, interference detection or other interactions of two or three dimensional objects with their enrivonment are needed. CAD CAM systems require means to store and manipulate computer representations of two and three dimensional objects. Moreover, there is a need to display these objects rapidly, compute their mass properties such as volume and moments of inertia , compute if two objects interfere and so forth. One popular method for representing two and three dimensional objects is by means of constructive solid geometry CSG . To represent a solid, one uses regular set operations, union, intersection and difference, on a set of primitive solids oriented in space. The primitive solids are simple objects like blocks, balls, cones, cylinders and tori. The set operations are union, intersection and difference. Internally, an object is represented as a binary tree. The leaves of the tree are the primitive objects and the internal nodes are the set operations. Fig. 1A illustrates a three dimensional object bracket with a hole and a CSG representation of that object. A more complete description of CSG solid representation can be found in A.A.G. Requicha H.B. Voelcker, One technique for generating shaded displays of three dimensional objects or computing the volume of three dimensional objects is to use ray casting, see S.D. Roth, The object of this invention is to provide an improved computer system that will compute the intersection of lines and other curves with two and three dimensional solids represented as CSG trees. A processor of the system computes these intersections in parallel at much higher speed than is possible with a general purpose computer. A general purpose host computer is attached, in an embodiment of the system, via two interface units, to the processor. The general purpose host computer loads the processor with data and instructions for a given computation and receives the results of the computations for further processing. In accordance with the present invention a system for the representation of plural dimensional objects as set forth in claim 1 is provided. Prefered embodiments of the invention are disclosed in the dependent claim. The foregoing and other objects, features and advantages of the invention will become more apparent from a reading of the following description of a presently preferred embodiment thereof in connection with the accompanying drawings, each figure of which is labeled with a discriptive title. FIG. 1 shows a solid in FIG. 1.A, a CSG representation for the solid in FIG. 1B, and in FIG. 1C a general system configuration for computing curve solid classification in accordance with the invention. FIG. 2 illustrates the computation needed for curve solid classification. FIG. 3 is a diagram which illustrates the ray casting technique. FIG. 4 is a block diagram of a portion of the system in accordance with an embodiment of the invention. FIG. 5 are diagrams which illustrate the imbedding of a binary tree in a FIG. 6 is a block diagram which schematically illustrates the system in accordance with an embodiment of the invention. FIG. 7 is a block diagram of a primitive classsifier processor. FIG. 8 is a block diagram of a combine processor. FIG. 9 is a functional block diagram which shows the data path unit of FIG. 7. FIG. 10 is a functional block diagram which shows the quadratic polynomial evaluation unit. FIG. 11 is a functional block diagram which shows the bit reversal unit. FIG. 12 is a functional block diagram which illustrates the bit serial square root unit. FIG. 13 is a functional block diagram which shows the linear polynomial evaluation unit. FIG. 14 is a functional block diagram which shows the output section and buffers of the primitive classifier PC processor of FIG. 7. FIG. 15 is the flow diagram of the PC output controller. FIG. 16 is a block diagram which shows the PC s main control section. FIG. 17 A, B, C is the flow diagram of the PC main controller. FIG. 18 is a block diagram which shows the combining section of the combine processor CC shown in FIG. 8, which also shows the CC data path. FIG. 19 shows the min max network of FIG. 18. FIG. 20 is a more detailed block diagram which shows the CC registers of FIG. 8. FIG. 21 is a more detailed block diagram which shows the CC output section. FIG. 22 A B is the flow diagram for the output controller shown in FIG. 21. FIG. 23 is a more detailed block diagram which shows the right input control section of FIG. 8. FIG. 24 A, B C is the right input controller flow diagram. FIG. 25 is a more detailed block diagram which shows the bottom input control section of FIG. 8. FIG. 26 A D is the bottom input controller flow diagram. FIG. 27 is a block diagram which shows the CC main control unit of FIG. 8. FIG. 28 A H is the main controller flow diagram. FIG. 29 consists of timing diagrams which show the communication handshake protocol used by the CC. In CSG representation, each complex solid is represented as a binary tree. The leaves of the binary tree are the primitive solids oriented in space. The internal nodes of the tree are the set operations union, intersection or difference that define how to combine the primitive solids in order to define the complex three dimensional solid. FIG. 1A gives a simple example of a three dimensional object and FIG. 1B a CSG representation. The object is made by taking the union of two blocks A and B and subtracting a cylinder C. In order to compute the intersection of a line with a composite CSG solid, first the intersection of the line with each primitive solid is computed See FIG. 3 . The line is represented as a one parameter family of points Once the intersection of the line with each primitive solid is known, one must compute the set operations defined by the CSG tree FIG. 1B on the line segments in order to compute the line intersections with the composite object. The results of the classification against primitive solids are propagated up the CSG tree. At each node 12 and 14 of the tree, the set operation on the results coming out of the two son or children nodes 16, 18 and 20, 22 is computed. FIG. 2 illustrates the computation needed for line solid classification. First the intersection of the line with each primitive solid I In accordance with the invention see FIG. 1C , all the line primitive intersections are computed in parallel in the primitive classification processors PC . The classification combiners CC or combine processors are connected into a binary tree that duplicates the binary tree defining the CSG solid. Each combine processor CC that corresponds to an internal node in the CSG tree computes the set operation that resides in that node. It receives from its children nodes a list of interval segments and it computes the set operation to produce a new list of interval segments. That new line segment list is sent to the processor parent another CC . The parent processor receives two sets of intervals from its children, computes its set operation on the sets, and sends the result to its parent. The final result comes out of the root processor the top CC in FIG 1C . Thus, the system as shown in FIG. 1C operates as a classification machine. The primitive classifier task is to compute the intersection of a given curve with a given primitive. The computation to be done depends on the kind of primitive solid and the curve that one wishes to classify. If the curves are polynomials or piecewise polynomial curves and the primitives are blocks, balls, cones, cylinders and tori, then the computation consists of multiplications and additions to compute polynomial equations. The roots of the polynomials are the end points of the intersecting curves. Generally, the roots are computed using a general root finding procedure. While it is possible to construct a general curve primitive classifier using a microprocessor and programming it to do the classification, the classification done this way will not be fast enough to keep up with the combine processors. Incremental classification is preferred since it can be done at very high speed. In order to explain incremental classification, we will make the following simplifications An array of parallel lines with the primitive solid is classified, not just an individual line, because of the parallel processing in the PC s. A small part of the computation is done only once for the whole array as a preprocessing step. This step is preferably done outside the classification machine by a general purpose host computer, as will be described in greater detail in connection with FIG. 7. Once the preprocessing step is done, the amount of computation to classify each line in the array is small. To classify each line against a quadratic half space, a second order equation is computed and solved. See explanation below. In order to reduce the amount of computation needed, instead of first computing the equation and then solving it for each line separately, a recurrence relation is derived that enables an equation to be computed and solved using only four additions, one subtraction and one square root operation per line. As a preprocessing step, the host computer computes the coefficients of the recurrence relations. This computation, however, is done only once for the whole array of lines. The primitive classifier, PC, is loaded with the recurrance coefficients and the array size. Using these coefficients, the PC needs to compute only six arithmetic operations in order to classify each line. Incremental classification of a family of lines is carried out as follows One constructs a two parameter family of straight lines P h,t . For each fixed value of h, say h₀, P h₀,t is a straight line. By varying h, one can construct a collection of lines. If In order to classify the line against a primitive half space, say a unit cylinder It is well known that if one needs to compute the value of an Nth degree polynomial over a set of equally spaced points, one can use a difference table to compute the polynomial values using only N additions per value. For example, Let The incremental algorithms for classifying parallel lines can be extended to work on a regular lattice of parallel lines, not only lines that lie in a single plane. Let P s,h t be defined as Therefore, in order to compute the coefficients of the difference table for D s In conclusion, we have shown that four additions, one subtraction and one square root per line are needed for incrementally computing parallel line classification against any quadratic half spaces. Four additions are needed to update the incremental computation coefficients when going from one row of lines to the next. The combine processors CC are connected so they can classify curves against any CSG solid. The binary trees representing CSG solids, of course, can vary and have no regular form. It is not useful to connect the combine processors as a fixed binary tree, since it is impossible to tell a priori what kind of a binary tree the CSG tree will be. Unfortunately, it is impossible in general to balance the CSG tree. A tree structure is selected that will enable one to embed any binary tree in it. In particular, we have found that any right heavy binary tree could be imbedded in a A binary tree is right heavy if the number of nodes in each right subtree is greater or equal to the number of nodes in the corresponding left subtree. A binary tree can be made to be right heavy by interchanging some of its left and right subtrees. A right heavy binary tree with N leaves can be imbedded into a FIG. 5 illustrates a binary tree and its imbedding into an array. The leaves of the tree are circles and the internal nodes are squares. The circles in the array show where the leaves of the tree will be and the square nodes show where the internal nodes of the tree could be. It is important to note the following points Each classification combine processor receives two lists of interval segments. Each interval is represented by two fixed point numbers l and t where l is the leading edge of the interval and t is the trailing edge of the interval. The two lists come from the bottom and right neighbors. Each combine processor computes a set operation union, intersection, difference on the two lists of interval segments. The results from each combine processor are passed to it s left and top neighbors. FIG. 4 illustrates how the combine processors are interconnected. Each processor in the interior of the array receives input from its right and bottom neighbors and sends its output to both his top and left neighbors. The bottom row of processors receive their right input from their neighbor and the bottom input from a PC. At the top row, each processor only communicates with its left neighbor, with the exception of the upper left corner CC, the root processor, that sends its output to the DMA interface unit. FIG. 6 is the block diagram of the curve solid classsification, CSC, system provided in accordance with the invention. The core of the machine is a All the PCs are connected by a local bus 5. Each PC has a register which is given a unique address and can be read or written to from the bus. An interface unit 3 connects the local bus to the host system bus thus enabling the host to read and write directly into the PCs registers. The PCs are programmed by loading their registers. The host computer downloads each PC with the recurrence coefficients it needs. It also loads some additional information to the PC, namely, how many lines are at each row, how many rows there are, and in what mode of operation to work. The different modes of operations are explained below. The host computer can also load the CCs with instructions, but not directly. The instructions to the CCs are loaded into the output buffers of the PCs and are then loaded onto the CC array bit serially the same way the data from the PCs are loaded. Each CC instruction is 3 bits long. The instructions are packed into two 16 bit words packet . The instructions are passed up the column from a CC to its top neighbor. Each CC strips the 3 bits of its instructions out of the coming word and rearranges the bits in such a way that the first bit of the next CC s instruction is the most significant bit in the leading edge cord. See also detailed description below . The instructions to the CCs are very simple. There are only 7 different instructions. The instructions tell each PC what its function is. The functions are compute union compute intersection compute right input minus bottom input compute bottom input minus right input pass information from the right pass information from the bottom and no op. In addition, there is a bit configuration that signals that no more instructions are in the packet. Each instruction is coded into 3 bits. All the instructions of a single column are packed into two 16 bit words. Since the two words are transmitted together, the instructions are packed as follows The instruction for the bottom CC in the column is first, then comes the instruction of its top neighbor and so on. The bits of the instructions are alternately put in the first and second words starting with the most significant bit. Hence, the first bit of the first instruction is the most significant bit of the first word. The second bit of the instruction is the most significant bit of the second word, the third bit is the next bit of the first word, and so on. The CSC machine is programmed by loading the PCs registers and by loading the CCs with instructions. The host computer 7 activates each PC by writing into its fixed instruction register. When activated, the PC starts to classify lines, one line at a time. The result of the classification is then passed to the CC directly above. The result of the classification is either an interval segment or a null interval zero length segment . An interval is represented by two 16 bit numbers, the leading edge L and the trailing edge T. In order to communicate the two numbers to its parent, each processor first goes through a full hand shake sequence with the receiving processor. FIG. 29 illustrates the hand shake protocol. In addition, two bits of header information are passed to tell the receiving processor the nature of the coming information. The coming packet of information could be two 16 bit words of data, that is, an interval segment, or two 16 bit words of instructions, or an end of line signal EOL . A null interval segment is represented by two EOL signals with no data in between, that is, no data is passed to represent a null interval. The PC has several modes of operations 1 Mode 1 normal mode In this mode, the two numbers coming out of the data path are taken to be the interval segment end points, L and T. 2 Mode 2 In this mode L is , that is, the largest 16 bit number all bits 1 , and T is taken out of the data path. 3 Mode 3 T is , that is, the smallest integer all bits 0 . Note that the PC uses fixed point twos complement arithmetic but the CCs use scaled fixed point by adding 2¹⁶ to all the numbers. Therefore, 0 is the smallest number and 0177777 base 8 is the largest 4 Mode 4 In this mode the PC receives from the host the line classification data and passes it to the CC. 5 Mode 5 In this mode the PC receives from the host an instruction for the CC column and it passes it to the CC array unchanged. The machine illustrated in FIG. 6 includes N primitive classification processors 1, an array of FIG. 7 illustrates the main building blocks of the PC. The PC is made of a data path 11, an output section that includes an output controller 13 and output buffers 131 and a main controller 12. The actual computation is done in the data path 11 see FIG. 9 . The data path is a computational pipeline that has a quadratic evaluation unit QEU 112, a bit serial square root unit 116, and a linear evaluation unit LEO 111. The QEU evaluates The main controller 12 controls the operations of the output controller 13 and counts the number of lines classsified. It activates the data path, and it controls the update of the computation of the QEU and LEU registers and notifies the host computer 7 FIG. 6 when the PC operation is complete. FIG. 8 illustrates the main building blocks of which the combine processor is made. The combine processor is made up of a main controller or control unit 23, combine data path the combining section 24 , a set of four shift registers 24 two intermediate registers and two output registers , two input controllers 25 and 26 and one output controller output section 27 . Each CC processor has four inputs two 212 and 227. L The main control unit 23 controls the data path computation, the shift registers 28 and the I O controllers 25, 26 and 27. The main control unit 23 controls which set operation is being computed on the sequence of interval segments. It receives the state of each input controller 25 and 26, the state of the output controller 27 and the flags from the data path 24. Using this information, the main controller initiates I O sequences and resets the comparison network units. The combine data path the combining section 24 is illustrated in FIG. 18. The task of the combine data path is to compute set operations on two lists of interval segments. The datapath is made of an input selector multiplexer 244 , min max comparison network 240, a controlling programmable logic array PLA 247 , and an output selector multiplexer 243 with its PLA 246. The main controller 23 FIG. 8 controls both the input and output MUXes 244 and 243 feeding the min max network 240. By selection of inputs and outputs, all the possible set operations, union, intersection and difference, can be computed in addition, input from the right or the bottom can be passed through the data path the entire section 24 unchanged. The bottom and the right controllers 25 and 26 FIG. 8 are very similar. Both controllers are finite state machines implemented by PLAs. In addition, each controller has a counter to count the 16 bits of the data going by. The task of the input controllers is to communicate with the bottom and right neighbors respectively and to input the data from the neighbors. The bottom controller is slightly more complicated than the right controller. It has additional hardware to strip 3 bits out of the coming instruction word and to rearrange the instruction bits. See also detailed explanation below. The output controller 27 FIG. 8 , like the input controllers, is a finite state machine, implemented by a PLA. Also, like the input controllers, it has a 16 bit clock counter. The output controller communicates with its top or left neighbor. The output controller doesn t know which one it is communicating with . It transmits to the neighbor the data stored in the output or the intermediate registers. Referring to FIG. 6, the curve solid classification machine CSC is made of N primitive classifiers PCs 1, The result of the computation comes out the top left corner of the combine array. The results are buffered and stored in the host computer memory 6 by the DMA unit 4. Referring to FIG. 7, each primitive classifier PC is made of four main functional blocks. The data path 11, the main controller 12, the output controller 13 and the output buffer 131. The data path incrementally computes the intersection of lines with linear and quadratic half spaces. The main controller 12 controls the data path 11 and the output controller 13. It also communicates with the outside world. The output controller task is to communicate with the CC processor directly above it. The output buffer stores the computation results from the data path data, or instructions coming from the outside. Data or instructions are passed to the CC above using the same protocol that is used in the combine array for communication between the CCs. Referring to FIG. 9, the PC data path 11 is made of two pipelines that operate in parallel feeding a bit serial adder 114 and a bit serial subtractor 117. The main pipeline Units 112, 114, 116 incrementally computes the square root of the discriminant, that is SQRT B 2A ² C A . The second pipeline unit 111 incrementally computes B 2A. The results from these two pipelines are used to compute B 2A SQRT0 using the adder 119 and B 2A SQRT using the subtractor 117. The main pipeline has a quadratic polynomial evaluation unit 112 that incrementally computes B 2A ² C 2A. The computation is bit serial, two bits at a time. The next stage in the pipeline is a bit reversal unit 114 that reverses the order of the bits in the result. The least significant bit become the most significant one and vice versa. This is done since the quadratic polynomial evaluation unit computes the least significant bit first and the next stage, the square root unit 116, needs the most significant bits first. The next stage is a bit serial square root unit 118. This unit require two bits at a time. It outputs one bit of result at a time. The results from the square root unit go to the bit serial adder 119 and the bit serial subtractor 117. All the registers of the data path are connected to an internal bus 110. Each register has an address on the bus and is loaded from the outside from the host computer 7, FIG. 6 by writing into that address. Referring to FIG. 10, the quadratic polynomial evaluation unit is made of two main blocks. The main unit is a second degree evaluation unit. It is made of two bit serial adders 1120, 1122 and three shift registers 1121, 1123, 1124. The two adders are bit serial, adding two bits at a time. The shift register shifts two bits at a time. The first adder 1122 adds the two numbers in registers 1123 and 1124. The results of this addition are fed back into register 1123 and into the next adder 1120. The second adder 1120 adds the result from 1122 to the number in 1121. The result from adder 1120 is added, fed back to register 1121 and is output to the next pipeline stage. This quadratic evaluation unit computes the recursion relation Referring to FIG. 11, the bit reversal unit 114 is made of two parallel loadshift registers 1140 and 1141. The bits are shifted in to register 1140, then they are transferred to register 1141 and are shifted out in the reverse order. In addition there is circuitry, two NOR gates 1147, to detect if the number in register 1140 is positive or not. The results of that circuit go to the main controller 12. Referring to FIG. 12, the bit serial square root unit 116 is a 6 bit unit that illustrates the operation of the 16 bit unit in the primitive classifier. The Bit Serial Square Root unit 116 is made of a Controlled Adder Subtractor unit CAS 1161. The CAS unit 1161 adds or subtracts its bottom input from its top input depending on the control line 1166. If the control is 0 low then it adds, if it is 1 high then it subtracts. Feeding the CAS are two registers The R register 1162 and the Q register 1163. The R register 1162 is a collection of D Flip Flops DFF . The output from the CAS 1161 is connected back into R register 1162 shifted by two positions to the left. The carry out of the CAS is used to detect when the result of the addition subtraction is positive. The carry out is fed into a D flip flop 1164. The value in the D flip flop 1164 is used to control the CAS, as the third bit in the Q register 1163, the lowest order bit that was computed so far, and its inverse is the second lowest order bit in the Q register. The lowest bit in the Q register, 1167, is always 1. The higher portion of the Q register is a shift register. At each clock on line 1176, it holds one more digit of the square root. The square root computation starts by resetting the R register, loading the first two bits into the CAS, setting the DFF 1164 to high and resetting the Q register. On the next clock the first bit of the square root is computed. Each clock, two more bits are loaded onto the square root unit 116 on lines 11431 and 11430. The carry out C out 1160 of the CAS is the next lower bit of the square root. The computation continues until the Q register is full. Then the result is transferred from the Q register to the bit reverse register. The bits come out of the bit reverse register with the least significant bit first. Referring to FIG. 13, the Linear Evaluation Unit 111 is made of a bit serial adder 1110 and two 16 bit shift registers 1112, 1111. The unit evaluates a linear recurrence relation. The values in registers 1112 and 1111 are added and stored back into register 1112. The register update unit is also made of a bit serial adder 1114 and two shift registers 1116 and 1117. The unit operation is controlled by the main controller 12, FIG. 7 . The control line shift 1212 shifts the registers 1111 and 1112. If the Update control line 1214 is on, the update unit FIG. 10 is activated and MUX 1113 loads register 1112 with the value computed by the bit update unit. Referring to FIG. 14, the PC output controller task is to communicate with the bottom input controller of the CC directly above it. The controller is made of a finite state machine 1300 implemented as a PLA, a 16 clock timer 1304 and output multiplexers 1305, 1306. The output buffers are made of two pairs of shift registers 1310 1311 and 1312 1313. The data from the data path 11 FIG. 9 is shifted into registers 1310 and 1312 least significant bit first and is transferred under the PC main controller control 1263 into registers 1311 and 1313, inverting the most significant bit. The data is shifted out of registers 1311 and 1313, most significant bit first, under the output controller control 1303. Registers 1310 and 1312 could also be loaded by the host via the local bus 110 not shown . The output multiplexers 1305 and 1306 are used to control the data flow to the output ports Tout 1321 and Lout 1320. MUX 1305 has the following inputs The output of register 1311, ground, header1 1272, header2 1273 and trailing out 1322. It is controlled by the three control lines Tselect 1307, SelectHeader 1308 and headers 1309. Using these controls, the output controller outputs the trailing out 1322 signal for hand shake protocol, the headers 1272, 1273 or a line segment. The mode control line 1255 controls whether ground or the output from register 1311 are used. Similarly, the mode bit 1254 controls whether the output of register 1313 will be used or high signal all ones . Referring to FIG. 15, the output controller starts in an idle loop Q1 waiting for the output buffer to be full. When the output buffer is full, it initiates the handshake protocol with its parent processor. Top or left neighbor . It raises the To signal and waits for Lo to be raised Q2. If it is raised, it starts transmitting the header information Q3, Q4. If the first bit in the header is zero Q5, then an interval segment is going to be transmitted. It then waits for the other processor to reply by lowering the Lo line Q9. When it does, it starts the timer to send the data out Q10. When the timer goes off Q12, it resets the outbuffull flipflop and goes back to the idle loop Q13. If the first bit of the header is 1, then it looks at the second bit. If the second bit is 1, Q5, then a new instruction is being passed. The controller waits until the parent processor lowers the Lo line Q9 then starts the timer Q10. When the timer is off Q12, it resets the outbuffull flipflop Q13 and goes to the idle loop again. If the second header bit is 0, then the EOL signal is being passed. The controller waits for the parent processors to lower Lo Q7 then it resets outbuffull Q8 and goes to the idle loop. No data is being passed. Referring to FIG. 16, the task of the PC main controller 12 is to control the data path, the output controller and to communicate with the outside world i.e. the host computer. The controller is made of a finite state machine FSM 1200 implemented as a PLA. In addition, the controller has a 16 clock timer 1210, two counters, the X counter made of a 16 bit register 1220 and a decrement unit 1221, and a Y counter with a 16 bit register 1230 and a decrement unit 1231. The X register 1220 and Y register 1230 are connected to the bus 110 now shown in the figure. The registers can be loaded from the bus by the host computer. The X register is used to store the number of lines to classify in each row and the Y register stores the number of rows. The valid buffer 1240 is a two bit wide, three bit long shift register. It is used to store the status of the data in the three stages of the pipeline. One bit position indicates whether the output is present signal 1242 and the other bit indicates whether the output is a valid line segment signal 1243 . The out present signal 1242 is computed as NAND of X count 0 and Y count 0. Output valid comes from the bit reverse unit and it is on if the number in the bit reverse unit is positive. The output valid computation can be overridden by setting a bit 1257 in the mode register 1250. The valid buffer can be reset by the controller using signal 1244. A three input NOR gate 1241 is used to compute whether the pipeline is empty. The mode and headers register 1250 is a six bit latch. It is connected to the local bus 110 not shown in the figure and can be loaded by the host. Two bits are used to store header information. Each interval segment or instruction loaded into the CSC machine is preceded by two bits of header information. The headers are generated by the main controllers. They can also be loaded from the outside. Two bits of mode 1254 and 1255 are used to control the leading or trailing MUXes 1305 and 1306 FIG. 14 to select whether the output will come out of the register or will be a constant or . One bit 1256 tells the main controller whether the information is to be loaded from the outside or not pass mode . The last bit 1257 is used to mask the OutValid bit. An RS flipflop 1260 is used to communicate with the output controller. The flipflop is set by the main controller to indicate that the output buffer has information in it. The flipflop is reset by the output controller to indicate that the output buffer is empty. Referring to FIG. 17A, the main controller starts at an idle state P1. The idle output is on to indicate to the host that the PC is idle. When the controller receives the go command from the host if it is not in a pass mode , it latches the X and Y registers values into the decrement units and resets the data path valid buffer P2 If either X or Y registers are zero, then an error flag is set P8 and the processor goes to an idle state. Now the processor starts the main computation loop. Y count is decremented P4 and X register is decremented P5 and then the timer is started P6. The timer on signal stays on for 16 clocks P7. It is also used as the shift control for the data path. When the timer goes off, the latch buffers signal goes on for one clock P11. This signal activates the transfer in the bit reverse unit and the SQRT unit. If there is a valid output at the end of the pipe P12 see FIG. 17B , that is, the output valid bit is on, then the main processor waits until the output buffer is empty P13. It transfers the data into the output buffer and latches the value line segment into the header buffer P14. If the output at the end of the pipe is not valid, that is, the line did not intersect the primitive, the main controller skips that part. It then waits for the output buffer to be empty P15. When the buffer is empty, it latches end of line EOL code into the header buffer. It shifts the valid buffer once and if there was an output at all at the top of the pipeline it signals that output buffer is full P 16. At the beginning, the pipeline needs to be filled by going through the loop 3 times but no output is available at the end of the pipe . At the end of the loop there are four different cases In the case the processor is in pass through mode, when the go signal is active the processor waits for the output buffer to be empty P9 then the values are transferred to the output buffer and the processor goes to the idle loop P10. Returning to FIG. 4 and FIG. 6, the classification combine CC array is made of Referring to FIG. 18, the combine data path combining section 24, FIG. 8 is made of an input multiplexer 244, a min max comparison network 240, an output multiplexer 243 and two decoding PLAs 246, 247. PLA 246 controls the output multiplexer 243. It receives a three bit code from the main controller 2301, 2302, 2303 and decodes it into five controls union 2461, intersection 2462, other 2463, pass bottom 2464 and pass right 2465. The output multiplexer 243 selects four outputs L The input multiplexer 244 has seven inputs and four outputs. The inputs are Lo 283, the leading part of the OUTPUT register, L Table 1 summarizes the Input and Output MUX operation, as well as the inputs and outputs of PLA 246 and PLA 247 see FIG. 18 . Column 1 gives the operator currently used. Column 2 gives the control code C 2301 2303. Column 3 gives which output MUX control line is high. Column 4 gives what the test condition was in the previous cycle. Column 5 gives the value of the Output variable 4471. Columns 5, 6 and 7 give the values of the control lines for the Input MUX 244. Columns 8, 9, 10 and 11 give the values of the outputs of the Input MUX 244. Columns 12, 13, 14 and 15 give the values of the Output MUX 243. MinL stands for minimum L₁,L₂ , MinT is minimum T₁,T₂ , maxL is maximum L₁,L₂ , maxT is maximum T₁,T₂ , minX is minimum maxL,minT , and maxX is maximum maxL,minT . Referring to FIG. 19, the min max network is made of five identical functional blocks 2421, 2422, 2423, 2424, 2425. Each block is a finite state machine that computes bit serially max a,b min a,b a b b a for its inputs a and b. The comparison results signals 2401 2408 are fed into the PLA 247 and the min max results signals 2410 2419 are fed into the multiplexer 243. FIG. 20 describes the CC machine register set. There are two pairs of registers. The OUTPUT pair 281, 282 and the INTERMEDIATE pair 283, 284. Each register is a 16 bit shift register. In addition there are two, two bit registers that are used to store the header information. The inputs 2431 2434 come from the multiplexer 243 of the combine section. The outputs of the registers 2811, 2821, 2831 2841 and the headers 2850, 2851, 2852, 2853 go into multiplexers 271, 272 controlled by the output controller 270. See FIG. 21. FIG. 21 shows the output control section. The output section has a finite state controller 270, a 16 clock interval timer, 2702, and two multiplexers 271 and 272. Multiplexer 272 selects the output for the leading line 21 and is controlled by WhichBuffer 2721 . If WhichBuffer is 0, the output register 2811 is selected and if WhichBuffer is 1, the intermediate buffer 2831 is selected. Multiplexer 271 selects the output for the trailing line 22 and has 4 control lines, WhichBuffer, 2721 , SelectHeader 2724 , TSelect 2725 and Headers 2723 . The output of this multiplexer is selected from seven inputs, one of which is supplied by the controller trailing out 2722 in order to initiate the handshake protocol. Table 2 shows the operation of multiplexer 271. The interval timer 2702 counts the 16 clock cycles necessary to shift out the data. It is started when the data is ready to be shifted out. The inputs to the finite state machine 270 consist of the leading edge coming back from the parent node 21 , the trailing edge being sent out by this node 273 , OutputAvailable 275 from the main controller indicating that an output is available, and the signal from the interval time 2703 indicating that the data has been shifted out. There are seven outputs from the finite state machine. Four of these 2724, 2725, 2723, and 2722 are used with multiplexer 271 as indicated above. OutputDone 274 signals the maincontroller that an output has started OutputDone high so that the main controller can start another input, and that the outputting is done OutputDone low . StartTimer 2704 is used to start the interval time 2702, and 2701 is used to switch between handshaking mode and outputting mode. The state diagram for the finite state machine 270 is given in FIG. 22 A and B. The output controller is initially in the reset state O0. It stays in this state until the main controller indicates by a high on OutputAvailable 275 that a packet is ready to be sent, at which time it goes to state O1 and outputs a 1 on trailing out 2722 to start the handshake with the parent node. It waits in this state O1 until leading 21 goes high, at which time it goes to state O2 and makes trailing out 2722 low. It immediately goes to state O3 and outputs the first header. If the first header is a one, it goes to state O4 to output the second header, otherwise the data to be sent is another line segment on the current line and it goes directly to state O7 to wait. From state O4, if the second header was a 0, it goes to State O5 indicating the end of the current line, otherwise it goes to state O7 to prepare to send out a complete packet. In state O7 the output controller waits for the parent node to indicate it is ready to receive a packet by a 0 on the leading edge 21 . When this occurs it goes to state O8 and starts shifting out the data and starts the timer. It immediately goes to state O9, signals the main controller with a high on OutputDone 275 , and shifts out the rest of the data. When the data is shifted out 2703 goes low , it goes to state O6. In state O5 there is no data to be sent, so when the handshake is completed low on 21 the controller immediately goes to state O6. In state O6 the controller waits for the main controller to indicate it is ready, OutputAvailable 0 and goes back to state O0. FIG. 23 describes the right input controller. This input controller consists of finite state machine 250 and an interval timer 2502. The inputs to the finite state machine are the trailing 251 and leading 252 wires from the son node, two signals from the main controller, Go 2508 and Active 2507, and the signal from the interval timer 2503 telling it when the interval timer is timing. There are also 6 outputs from the finite state machine. Two of these, leading 2509 and outputting 2501, control the handshake protocol with the son node. Start timer 2504 is used to start the interval timer, and the other two are ready signals 2505 and 2506 which go along with 2503 to the main controller to indicate the status of the right inputs. The state diagram for the finite state machine 250 is given in FIG. 24 A and B. The right input controller is initially in the reset state R0. It stays in this state until the trailing 251 goes high indicating that the son node has output ready to send. If this occurs when the controller is active, the controller outputs a high, state R1, on the leading wire 211 to indicate that it is ready to receive headers indicating what type of input is coming. The headers are read in state R2 and possibly R3 with 0x indicating a line segment is coming, 10 indicating the end of the current line, and 11 indicating that a new tree is being loaded in the column to the right. If a line segment is coming, the controller enters state R4, signals the main controller with a 01 on ready lines 2506 and 2505 and waits for the main controller to indicate it is ready to receive this input by a 1 on go 2508 , whereupon it completes the handshake and starts the timer in state R5 and then waits in state R6 for the input to be completed and finally goes back to state R0. If an end of line indication is seen in state R3, the controller goes to state R7 and signals the maincontroller with a 10 on ready 2506 and 2505 , waits in that state for the main controller to indicate it is ready for the next line with go 2508 and then completes the handshake in state R8 and goes back to state R0. If a new tree is indicated in state R3 the controller stops controlling the handshake line 211, and enters state R9. In this state it signals the main controller with ready 11 and enters state R14 of the set of states for the inactive controller which are described next. When active 1507 is low, the controller follows the handshakes on leading and trailing in order to keep synchronized so that it will be in the proper state when a new tree is loaded which makes this node active. States R10, R11, R12, R13, R14, R15 and R16 shadow states R1, R2, R3, R4 R5, R6, and R7 respectively. If go 2708 and active 2707 are both high in state R13 or state R16, then the controller switches to the next corresponding active state R5 or R8. The bottom controller 25 which is shown in FIG. 25 is very much like the right input controller. The major difference between the two is the special mechanism added to the bottom controller that enables it to load new instructions a new tree into the combine processor. To configure a tree of processors, each processor in the array needs to receive 3 bits of data. The instructions to the combine array are loaded in pipelined fashion the same way interval segments are loaded. Instructions are loaded vertically. Each column of the array receives a packet of instructions from the primitive classifier at the bottom of the array. The instructions are packed, with bit 1 the most significant bit of the leading packet, and bit 2 the most significant bit of the trailing packet, and bit 3 the next bit of the leading packet. Bit 1, 2, and 3 for the next processor up the column are in the second bit of the trailing packet, and the third bit of leading and trailing. When these instructions are being loaded treeing 1 , the circuit 264 swaps the leading and trailing packets with the trailing delayed by one clock. This will make the control packets identical for each processor in the column. The state diagram for the finite state machine 260 is given in FIG. 26 A, C and D. The bottom input controller is initially in the reset state B0. It stays in this state until the trailing 2612 goes high indicating that the son node has output ready to send. If this occurs when the controller is active, then the controller outputs a high, state B1, on the leading wire 212 to indicate that it is ready to receive headers. The headers are read in state B2 and possibly state B3 with 0x indicating that a line segment is coming, 10 indicating the end of the current line, and 11 indicating that a new tree is being loaded. If a line segment is coming, the controller enters state B4, signals the main control with a 01 on ready lines 2606 and 2605 , and waits for the main controller to indicate it is ready to receive this input by a 1 on Go 1608 , whereupon it completes the handshake and starts the timer in state B5 and waits in state B6 for the input to be completed and finally goes back to state B0. If an end of line indication is seen in state B3, the controller boes to state B7 and signals the main controller with a 10 on ready 2606 and 2605 , waits in that state for the main controller to indicate that it is ready for the next line with Go 2608 and then completes the handshake in state B8 and goes back to state B0. If a new tree is indicated in state B3, the controller enters state B9, signals the main controller with a 11 on ready 2606 and 2605 , waits for the main controller to indicate that it is ready for a new tree to be loaded with 11 on Go 2608 and Active 2607 , and then goes to state B5 and B6 to read in the packets. When Active 2607 is low, the controller follows the handshakes on leading and trailing in order to keep synchronized and be ready to read in a new tree. States B10, B11, B12, B13, B14, and B15 shadow states B1, B2, B3, B4, B5 and B6. Referring to FIG. 27, the main controller 23 consists of a finite state machine. This controller implements the algorithms to the control the other 5 sections of the classification combine machine, 24, 25, 26, 27, and 28. There are two major algorithms. One of these is concerned with filling the register section with packets to be output. These may consist of instructions to reconfigure the tree, a line segment, or a line separator. This algorithm provides the control for the input sections, 25 and 26, the combine section, 24, and most of the control of the registers, 28. The second algorithm is concerned with emptying those registers. It provides the control for the output section, 27 and some of the control for the registers, 28. The main controller has 12 inputs and 19 outputs. The state diagram for the main controller in given in FIG. 28 A through E. The reset state is state M1 where the combine processor waits until the bottom input section indicates that the instructions for a new tree are being loaded from below. This is indicated by a Ready 1,1 2606 2605 from the bottom input controller. When this occurs, the main controller shifts to state M2 and signals the bottom input controller 26 with a 1 on NewTree 2610 , ActiveBottom 2607 , and GoBottom 2608 to start shifting in a new packet. This is shifted into the Output register with a 1 on ShiftOutput 2363 . In state M2 and one of M4 or M5 or M6, 6 bits are read. Three of the bits determine the state and the next three determine if this is the top processor on the column. If the second 3 bits are 000, then top is set to 1. The controller then goes to state M7, loads the output headers to indicate a new tree, and waits until the input is done indicated by a 0 on TimingBottom, 2603 . When the input is done, it goes to state M8 and if this is not the top of the column indicates that the output buffer is full. It also shifts the input buffer to bring the state for the next processor to the head on the output packet. It then goes to state M9, where it waits until the new tree has been loaded in the column to the right, indicated by Ready 1,1 2506 2505 from the right input controller. At this time, the state of this processor has been loaded. There are three possibilities, tested in M10. The processor state is 000, indicating the processor is idle and the controller goes back to state M1 to wait for a new tree to be loaded. The processor state is 1XX, indicating that the processor is going to be actively combining, and the controller goes to state M11. The processor state is 01X, indicating that the processor is going to be passing packets, and the controller goes to state M42. If the processor is combining, it will reset the data path with C 2301, 2302, and 2303 000 and InputDone 2450 1 in state M11. Throughout this section, ActiveBottom 2607 and ActiveRight 2507 will be high to indicate that inputs are coming from both the bottom and the right. The controller will then go to state M12 where the data path control is set to the processor state and wait until the required inputs are available and the output register is available. This is tested in M13. When the above conditions are met, there are seven possible outcomes State M20 is the beginning of a loop that dumps the bottom input to the output. Throughout the loop the mode C 2301 2303 of the data path is set to 010 to pass the bottom input to the output register. In state M20 the data path is reset by InputDone 2450 1. The controller wait in this state until an input is available and the output register is not full. Then it goes to state M1 Ready 11 , State M11 Ready 10 or state M26 Ready 01 . State M26 starts the input of the line segment with GoBottom 2608 and StartInput 2400 both high. It waits until the input is done and then goes to state M28, loads the output headers 2856 high and goes back to state M20 to wait for another input. State M21 is the beginning of a loop that dumps the right input to the output. Throughout the loop the mode C 2301 2303 of the data path is set to 011 to pass the right input to the output register. In state M21 the data path is reset by InputDone 2450 1. The controller waits in this state until an input is available and the output register is not full. Then it goes to state M1 Ready 11 , state M11 Ready 10 or state M27 Ready 01 . In M27 the input is started 2501 high and 2400 high and the controller waits until the input is done. It then goes to state M29 to load the output headers 2856 high and goes back to M21 to wait for another input. State M30 is the beginning of a loop that removes unwanted input on the bottom input. The controller waits in that state until input is available from the bottom Ready 2606 2605 00 . If a new line is indicated by Ready 10, the controller goes to state M11 to start a new line. If a new tree is indicated by Ready 11, it goes to state M1 to read in the new state. Otherwise, it goes to state M31 where the input is started and the controller waits until the input is finished before going back to state M30 to wait for another input. State M32 is the beginning of a loop that removes unwanted input on the right input. The controller waits in M32 until input is available from the right Ready 2506 2505 00 . If a new line is indicated by Ready 10, the controller goes to state M11 to start a new line. If a new tree is indicated by Ready 11, it goes to state M1 to read in the new state. Otherwise it goes to state M34 where the input is started and the controller waits until the input is finished before going back to state M32 to wait for another input. In state M35 the controller is ready to read in another set of inputs. In that state the data path is reset with StartInput 2400 , the needed inputs are started with go bottom 2608 set to want bottom 2454 and go right 2501 set to want right 2455 , and the outputs of the data path are shifted into the registers with shift output 2363 and shift intermediate 2361 . It then goes to state M36 and continues to shift into the registers until the input is done, indicated by a 0 on both timing right 2503 and timing bottom 2603 . When the input is done,the controller goes to state M37 where, if there is output 2471 high , the state variable FullO is set and the headers are loaded with LoadOHeader 2856 . The controller then goes to state M12 to wait for new segments. In state M38 the controller is about to output the intermediate buffer. It sets the intermediate buffer full, sets WhichBuffer 2721 to 1, loads 00 on h1 and h2 2854 2855 into the intermediate headers with a high on Load 1 Header 2857 and then goes immediately to state M39. It waits in state M39 until the output has been started. This is indicated by FullI going back to 0. When this occurs it goes to one of four states. If R2 Bottom 2605 0, then there are line segments on the bottom input to be dumped to the output and the controller goes to state M20. If R2 Right 2502 is 0, then there are line segments on the right to be output and the main controller goes to state M21. If Ready Bottom 2605 and 2606 and Ready Right 2505 2506 are both 10, then a new line is indicated and the controller goes to state M11 to start the new line. Otherwise, both ready s are 11, indicating a new tree and the controller goes to state M1. If the condition tested in M10 indicated that the processor is passing, it will go to state M42. In that state the data path is reset with InputDone 2450 1. It waits there until a buffer is available and there is something to be passed. It looks at Ready Bottom 2606 2605 if it is passing from below indicated by State 010 , or at Ready Right 2506 2505 if it is passing from the right indicated by State 011 . If the appropriate Ready is 10 or 01 then there is something to be passed. In this case, it goes to state M47 if the ouput buffer is empty or to state M49 if the ouput buffer is full and the intermediate buffer is empty. If both buffers are full or the appropriate Ready is 00, it stays in state M42. It must also wait in state M42 if a new tree is indicated and the intermediate buffer is full. Otherwise, the appropiate Ready indicates a new tree with 11 and it goes back to state M1 to load the tree. In state M47 the controller starts to pass an input to the output buffer. It starts the appropiate input with a 1 on GoBottom 2608 or a 1 on GoRight 2501 , loads the output header 2856 1 , and shifts the output registers 2362 1 . It then goes to state M48 where it continues to shift the output register 2632 1 until the appropiate input is done, either 2503 0 or 2603 0 . When the input is done, the outputbuffer is marked full FullO 1 and the controller goes back to state M42 to await further inputs. In state M49 the controller starts to pass an input to the intermediate buffer. It starts the appropiate input as indicated in the previous paragraph, loads the intermediate headers 2857 1 , and shifts the intermediate registers 2361 1 . It then goes immediately to state M50 where it continues to shift the intermediate register 2361 1 until the appropiate input is done, either 2503 0 or 2603 0 . When the end of the input is indicated, the intermediate buffer is marked as full FullI 1 and the controller goes back to state M42 to wait for possible inputs. From the foregoing description, it will be apparent that there has been provided a computer system which can 1 classify curves against CSG solids 2 classify arrays of lines against CSG solids 3 incrementally classify arrays of lines against linear and quadratic halfspaces 4 compute shaded displays of 3D solids 5 compute mass properties of solids such as volume and moments of inertia and 6 compute solid interference and detect null objects.