# COMPUTING APPARATUS AND METHOD FOR TRANSLATING INTO A LINEAR QUERY A GRAPHIC LANGUAGE QUERY

## Claims
Verfahren zum Betreiben einer Rechnereinrichtung zum Übersetzen einer in einer Graphiksprache gehaltenen Abfrage in eine lineare Abfrage, wobei die in einer Graphiksprache gehaltene Abfrage als ein oder mehrere Elemente ausgedrückt ist, die Beispielelemente 18, 19, 27, 29 und implizierter Operandenprädikate einschließen, die in Reihen 7 und Spalten 5 einer Beispieltabelle 2, 4, 16, 26, 36 , die eine oder mehrere Quellen 2, 16, 26 und Ziel 4, 36 tabellen einschließen, und wahlweise in Bedingungsblöcken 6 auftreten, gekennzeichnet durch die Schritte

## Description
This invention relates to a computing apparatus and method for translating into a linear query a graphic language query. More specifically, it relates to an apparatus and method for synthesizing from a graphic language query an equivalent linear query for accessing a relational data base. An example of a linear query language is provided by the IBM Structured Query Language SQL , as is described in SQL Data System Terminal User s Guide, IBM Publication SH24 5016 0 and SQL Data System Application Programming, IBM Publication SH24 5018 0. Such a linear query language provides for defining, accessing, and modifying multiple views of stored tables in a relational data base, such as is described in M. W. Blasgen, et al, System R An architectural overview , IBM System Journal, Vol. 20, No. 1, 1981, pp. 41ff. An example of a graphic query language is provided by the IBM Query by Example QBE , as is described in Query by Example Terminal User s Guide, IBM Publication SH20 2078 0. Such a graphic query language also provides for defining, accessing, and modifying stored tables in a data base, and provides a particularly user friendly format for the terminal operator, such as is described in M. M. Zloof, Query by Example a data base language , IBM System Journal, Vol 16, No. 4, 1977, pp. 324ff. The SQL and QBE query languages have each been designed to access data bases, but a data base managed by one is not readily accessible by the other. One approach to this problem is described by D J McLeod in IBM Research Report RJ1730 No 25348, dated 27 February 1976, on pages 1 to 30. This reference proposes an algorithm for translating a QBE query into an SQL query which processes the QBE query in a series of seven steps to produce a result which is either final, i.e. usable as a SQL query, or intermediate, requiring one or more further invocations of the algorithm. While no practical implementation is described, it is clear that the procedure is highly serial and iterative in nature, with consequent penalties in speed of operation. The present invention implements the translation of QBE queries into SQL queries in two phases. In the first, analysis, phase, data from a QBE query is processed to load a set of tables with data, pointers and flags, which are then used in the second, synthesis, phase to synthesise an equivalent SQL query. In accordance with the invention there is provided a method for operating a computing apparatus to translate into a linear query a graphic language query expressed as one or more elements, including example elements and implied operand predicates, appearing in rows and columns of an example table including one or more source and target tables and, optionally, in condition blocks, characterised by the steps of generating row names into a row name table having one entry for each row in a source table for each data field within each row named in said row name table which contains an example element definition or implied operand predicate, generating and loading into a column data table an entry specifying the row name, column name, and data marking as bound those column data table entries containing an example element not having an implied condition and generating into a conditions table an entry containing a basic predicate for each column data table entry containing an implied operand predicate or an example element having an implied condition thereby establishing in the row name table, column data table, and conditions table a data structure for synthesizing into a linear query a graphic language query specified as a target print query, or a combined print query, or an insert query, or an update query, or a delete query. In accordance with another aspect of the invention, a method is provided for determining from the column data table the row name and column name for example elements referenced in the condition block, and responsive thereto generating into the conditions table a condition entry for each condition specified in a condition block. In accordance with a further aspect of the invention, a method is provided for synthesizing a graphic combined print query into a linear query comprising the UNION of generated select statements. In accordance with a further aspect of the invention, a method is provided for synthesizing a graphic target print query into a linear query comprising any generated ORDER BY clause and the UNION of generated select statements. In accordance with a further aspect of the invention, a method is provided for synthesizing a graphic insert query into a linear insert statement and any generated select statements. In accordance with a further aspect of the invention, a method is provided for synthesizing a graphic delete query into a linear delete query comprising the logical ORing of condition statements. In accordance with yet a further aspect of the invention, a method is provided for synthesizing a graphic update query into a linear update query including a SET clause and any generated WHERE clause and sub query. In accordance with yet a further aspect of the invention, a computing apparatus is provided for translating into a linear query a graphic language query expressed as one or more elements, including example elements and implied operand predicates, appearing in rows and columns of an example table including one or more source and target tables and, optionally, in condition blocks. The apparatus includes means for generating row names into a row name table having one entry for each row in a source table means, responsive to each data field within each row named in said row name table which contains an example element definition or implied operand predicate, for generating and loading into a column data table an entry specifying the row name, column name, and data means for marking as bound those column data table entries containing an example element not having an implied condition and means for generating into a conditions table an entry containing a basic predicate for each column data table entry containing an implied operand predicate or an example element having an implied condition thereby establishing in said row name table, column data table, and conditions table a data structure for synthesizing into a linear query a graphic language query specified as a target print query, or a combined print query, or an insert query, or an update query, or a delete query. Figure 1 illustrates an example table of a graphic query which is a named, or source, table. Figure 2 illustrates an example table of a graphic query which is an unnamed, or target, table. Figure 3 illustrates a graphic query conditions box. Figure 4 is a diagram illustrating a relational data base, a typical graphic query for accessing that data base, and the output responding to the query. Figure 5 is a diagram illustrating the control blocks structure implemented according to a preferred embodiment of the invention for synthesizing a linear query from a graphic query. Figure 6 is a diagram illustrating the processing modules implemented according to a preferred embodiment of the invention for synthesizing a linear query from a graphic query. Figures 7A and 7B illustrate the steps performed by the graphic form manager module DSQGFTM 110, table input process module DSQGFTT 114, and source process module DSQGFTS 116 of Figure 3. Figure 8 illustrates the steps performed by the retrieval process module DSQGFTP 120 of Figure 3. Figure 9 illustrates the steps performed by the output, or target, table process module DSQGFTX 126 of Figure 3. Figure 10 illustrates the steps performed by the delete process module DSQGFTD 118 of Figure 3. Figure 11 illustrates the steps performed by the update process module DSQGFTU 124 of Figure 3. Figure 12 illustrates the steps performed by the insert process module DSQGFTI 122 of Figure 3. In Table 49 is set forth a listing of abbreviations used in the description which follows. Referring to Figures 1 through 4, an introductory explanation will be given of an example of a graphic query language in this instance, the Query By Example QBE language. QBE allows a user to express a query by creating examples of the items being queried. The example tables 2 and 4 also referred to as skeletons , illustrated in Figures 1 and 2, and the condition box 6 in Figure 3, are used to create the example query Q. The items being queried are in a 2 dimensional table form, as is illustrated in Figure 4, tables 40 and 50. Conditions 8 may appear in a QBE query that limit the selection data 9 from tables 2, 4. The terms, example table , example row , and example column , are used in referencing an example table. A table is a rectangular array of elements. Example table refers collectively to all the items that appear in an example table 2 or 4. A skeleton is another term for an example table. Example row refers collectively to row 7 and data fields 9 that appear in one row of an example table 2, 4 and example column refers collectively to the column name 5 and data fields 9 that appear in one column of an example table 2. A source table 2 may have a column name field 5, but a target table 4 may not. Actual tables are made up of elements, each of which appears in a particular row and column of a table. A QBE data field 9 may contain an example element EE 18 Figure 4 , that is an example of the actual elements that appear in a column 42 of a table 40. In the embodiments herein described, an example element name begins with an underscore _ . The elements in a column usually have the same significance. For example, a column may contain the names of people working for a particular business. A results table 56 is a table created by a QBE query. Each row of a results table may be viewed as containing elements from a single row of an extended Cartesian product ECP . An ECP is a matrix product formed from one or more source tables 2. The concept of an ECP is used in this description to aid in understanding, but it should be understood that an actual ECP is not necessarily constructed in the preferred embodiments hereinafter described. Since an ECP is a matrix product of all source table 2 rows, the row dimension of the ECP is the product of the row dimensions of the source tables, and the column dimension is the sum of the column dimensions of the source tables. A row is a duplicate row if each element of the row is a duplicate of each element with the same ordinality in some other row of the table. Elements of a table have the same ordinality as the column and row containing the element. For example, the 3rd element in a row is in the 3rd column, and the 12th element in a column is in the 12th row. Not all rows of an ECP need be used in formulating a results table 56. That is, a QBE query may contain selection criteria that selects a subset of ECP rows to be used in the formulation of a results table 56. In addition, not all columns need be selected in formulating a results table 56. Thus, a QBE query need not name all columns from selected ECP rows. An element in a results table 56 may be a copy of an element from a column of a selected ECP row. It may be the evaluation of an arithmetic expression containing copies of 1 or more elements from the selected ECP row. It may even be a constant value not copied from a selected row. Generally, no duplicate rows appear in a QBE results table. That is, only one copy of duplicate rows produced by the QBE query are retained in the QBE results table. Referring to Figure 4, an example of a QBE query is shown. Appearing on the screen of the terminal user would be example tables 16, 26, and 36 and result table 56. The relational data bases being accessed by the query, and stored in the data storage area of a host computer, are illustrated as tables 40 and 50. Table 16 includes a table name 10 of SALES, column names DEPARTMENT 12, and ITEM 14, and example elements _TOY 18 and _INK 19. Example table 26 includes a table name SUPPLY 20, column names 22, 24 ITEM and SUPPLIER , and data fields 27 and 29 contain example elements _INK and _IBM. Tables 16 and 26 are source, or named, tables. Table 36, on the other hand, having its name field 30 blank, is a target table, and illustrates the information to be displayed in output table 56 in response to the query of tables 16, 26, and 36. Figure 4 illustrates a query where a target table 36 is required, for data from two tables SALES table 40 and SUPPLY table 50 are to be combined in the output, or results, table 56. Example element 19 illustrates an example element with an implied condition, the condition implied being that 0001.ITEM 0002.ITEM, where 0001 is the row name assigned to the row including data field 19, and 0002 is the row name of the row including data field 27, as will be more fully described hereafter. The query of Figure 4 is interpreted as follows. In data field 38 is P.AO 1 ._TOY . P. is a QBE print command, AO 1 . is a QBE sort or ordering parameter, and _TOY is an example element. _TOY is in the DEPARTMENT column 12 in SALES table 10, thus directing the query, as is illustrated by line 60, to access SALES table 40 and put into the corresponding column 57 of output table 56 data from column 12 that satisfies the query.. Similarly, the _IBM in data field 39 references example element _IBM 29 in the SUPPLIER column 24 of SUPPLY table 20, thus directing that data from SUPPLY table 50, SUPPLIER column 54 which satisfies the query be printed out to the result table 56 in column 58. The example elements 19 and 27 provide the link between tables 40 and 50. Thus, as is illustrated by line 62, output table 56 will include in column 57 the department name from sales table 40, and, as is illustrated by line 66, in column 58 the supplier name from supply table 50 where, as is illustrated by line 64, the item from column 44 is the same as the item from column 52, with data ordered first as is specified by AO 1 . in element 38 on department name, and second as is specified by AO 2 . in field 39 on supplier name. Referring now to Tables 1 through 14, the terms essential to an understanding of the metalanguage statement of the procedure of the invention will be given a formal syntactic definition together with semantic rules. Specification progresses from the more elemental to the most complex concepts in order to obviate the need for forward references. The syntax notation used herein is defined in IBM Standards Manual 33 07 Standard I B 3 9001 008 , with the addition of the additional syntax notation of the may be repeated box, and the with box. A construct bracketed by a may be repeated box may be repeated. When two constructs are separated by a with box, both constructs may be present. Table 1 gives the syntax definition of a character. A character is a digit or a letter or a special character. A special character is any graphic character which is not a digit or a letter. Table 2 provides the syntax definition of a constant, which is a string constant, or a numeric constant. A string constant is a string of one or more characters, or an identifier. An identifier is a letter followed by one or more letters or digits. A delimited identifier is one or more characters enclosed within quotes . Table 3 provides the syntax definitions names. A table name is an identifier or a delimited identifier, optionally preceded by a name qualifier followed by a period . . A column name is an identifier or a delimited identifier. A name qualifier is an identifier or a delimited identifier. An example element is an underscore _ , followed by one or more letters or digits. A table name is the name of a predefined table. Column names are names of predefined columns. An example element is a variable name for the elements that appear in a particular column of a table. A name qualifier is used to give uniqueness to tables with the same table name. Table 4 provides the syntax definition of tokens. A token is any one of the following identifier example element numeric constant order spec or keyword occurrence. A keyword occurrence is a keyword which is not contained in a character string constant. A keyword is any one of the following sequences of non blank characters NOT IN LIKE AND OR P. I. U. D. A keyword may also be a character or character string signifying equal or not equal or greater than or less than or greater than or equal to or less than or equal to . A spacer is a sequence of one or more blank characters. A token may be preceded and or followed by a spacer. Table 5 provides the syntax definition of expressions. An expression is an arith term, or an expression followed by an infix op 1 followed by an arith term. And infix op 1 is an addition or a subtraction sign. An arith term is an arith factor, or an arith term followed by an infix op 2 followed by an arith factor. An infix op 2 is a division or a multiplication sign. An arith factor is a primary, which may be preceded by a prefix op. A prefix op is an unary plus or an unary minus sign. A primary is a constant, or an example element reference, or an expression enclosed within parentheses. An example element reference EER is an underscore _ followed by a letter or a digit, which may be followed by one or more letters or digits. An example element reference EER is a reference to an element value represented by the example element name used in the reference. Expressions in a QBE query apply to each row of an ECP formed from source tables referenced by the query. QBE processes each row of an ECP formed from source tables referenced by the query. As each row is processed, expressions are evaluated by substituting for each example element reference, a corresponding element value. Table 6 sets forth the syntax of predicates. A predicate is a basic predicate, or an in predicate, or a like predicate, or a null predicate. A basic predicate is an expression followed by a comp op followed by an expression. An in predicate is an expression, followed by IN or NOT IN, followed by one or more constants separated by commas. A like predicate is an example element, followed by LIKE or NOT LIKE, followed by a character string constant. A null predicate is an example element followed by a null comp op followed by a null symbol. A basic predicate compares two values, each derived from the evaluation of the expressions that appear in the basic predicate. The like predicate is used to ignore certain character positions in comparing an element to a string constant. The characters _ and , for example, may be used in a string constant to indicate, respectively, one or more character postions that are to be ignored. The in predicate is evaluated as true if the element referenced by the example element is equal to one or more of the constant values expressed to the right of the IN comp op comparison operator . Table 7 provides the syntactic definition of an implied operand predicate. An implied operand predicate appearing in a data field 9 refers to the column in which it appears in an example table. As each row of an ECP is processed, a basic predicate is formed from the element in the referenced column followed by the implied predicate. Table 8 gives the syntax of condition lists. A condition list is a condition, which may be repeated. A condition must appear in a condition box 6. One or more conditions boxes 6 may be used to contain a conditions list. Conditions in a QBE query apply to each row of an ECP formed from source tables referenced by the query. As each row is processed conditions are evaluated by substituting for each example element, the corresponding element value. Table 9 gives the syntax of a source table list. A source table list is a source table, which may be repeated. A source table is one or more tables, each table including a table name in a table name field 3, and a source entry in at least one data field 9, and, optionally, a column name in a column name field 5 for the column containing a data field 9. A source entry is an example element definition, or an implied operand predicate, or empty. The term source row is used to refer collectively to all of the source entries that appear in the same source row. An example element reference EER refers to an example element definition EED if both contain the same example element EE name. More generally, an item X refers to an item Y if the item X contains an example element reference which refers to an example element definition contained in the item Y. Two rows R1 and R2 in a query Q are directly linked if one or more of the following is true R1 refers to R2 R2 refers to R1 there is a condition in the query Q which refers to both R1 and R2. Two rows R1 and R2 in a query Q are linked if one or more of the following is true R1 and R2 are directly linked R1 is directly linked to some other row RX in the query Q and RX is linked to R2. In QBE, one and only one source entry may appear in a source row. Also, in a source table a source entry in a column without a column name must be empty. An example element which can be parsed as either an example element definition or an implied operand predicate shall be parsed as an example element definition. This latter rule specifies the manner in which the syntactic ambiguity between example element definition and implied operand predicate must be resolved. The ambiguous case involves an implied operand basic predicate with an omitted comp op and an expression which is an example element reference. Such a case is treated as an example element definition. In this embodiment, the implementation of empty is an entry consisting entirely of blank characters. Table 10 provides the syntax of a combined print query. A combined print query is a combined print table, which may be preceded by a condition list, which may be preceded by a source table list. A combined print table is an example table with a table name, with at least one column having a column name and an optional source entry, and which example table may have one or more rows having a combined row attributes in row field 7 and one or more combined entries in data fields 9. A print command is designated by P. . An order spec is AO or DO . An integer value in parentheses may optionally appear before the closing . A set spec is an all spec or an unique unq spec . An all spec is represented by ALL. The unq spec is represented by UNQ. , and requires that single copies of duplicate rows be presented in the results table. The term combined row is used to refer collectively to the combined row attributes and the combined entries of a row in a combined print table. A combined print table can be made up of source rows and combined rows. The term combined print row is used to refer to a row of a combined print table, whether it is a source row or a combined row. In a combined print table, the number of source entries in each source row must be equal to the number of column names. A source entry may, however, be blank .A combined print row contains at least one print command. A QBE combined print query produces a results table that is then displayed on the screen from which the query was submitted. The result contains elements copied from the source table named in the combined print table. A P. print command in a column data field 9 indicates that elements from the like named column of the source table are to be copied into the results. A P. in a row field 7 causes elements from all columns 5 named in the query to appear in the results. Examples of elements to be displayed may be used in a query. Thus, a P._SMITH appearing in a data filed 9 of a column having a column name 5 of NAME and in a table 2 having table name 3 of EMP will display all the NAMEs, including but not limited to SMITH, for example, from the EMP table. Examples of data to be displayed are optional. That is, if _SMITH were omitted from the preceding example, the results would be the same. AO. means sort in ascending order, and DO. means sort in descending order. If an order spec appears in a combined column, results table rows are sorted by the elements in that column. If more than one order spec appears in a combined print query, data is sorted first by the lowest integer value in an order spec, then by the each succeeding higher integer value in the remaining order specs. Only defined tables may be named in a combined print query That is, tables that are being queried must already exist and be in the library of tables available to the user. Columns that are referenced must be defined as part of defined tables. A qualified retrieval is one that contains conditions and or implied predicates. All of the conditions and all of the basic predicates formed from implied operand predicates are logically ANDed to form a selection criteria. The same rules for the valuation of conditions applies to the evaluation of selection criteria. As each row of an ECP formed from a combined print query is processed only elements from those rows that meet the selection criteria appear in a combined print query results table. A combined print query may be either a simple retrieval or a query dependent retrieval. A combined print query is a simple retrieval if no source rows appear in the query. Selection of elements from a row of a table is dependent only upon values of elements in the same row. An ECP is formed for each combined print row that is a copy of the table named in the combined print table. A combined print query is a query dependent retrieval query if it contains one or more source rows linked to a combined print row. Conditions 8 in a combined print query may be expressed in one or more condition boxes 6. When two or more combined print rows appear in the same example table, each combined print row is treated like a separate query. An ECP is formed for each combined print row consisting of a copy of the table referenced by the combined print row and a copy of a source table for each example row linked to the combined print row. The results from each query are then UNIONed to form one results table. If a combined print query contains sort criteria, the results apply only to the final results table. Table 11 provides the syntax of a target print query. A target print query is a source table list with a target print table, with an optional condition list. A target print table is an example table 4 having in row field 7 a target row attributes and in data field 9 a target entry the target row attributes and target entry may be repeated. A target row attributes is a print command followed by an optional set spec. A print command is designated by P. . A target entry is an expression, preceded by an optional order spec, which may be preceded by a print command. The term target print row is used to refer collectively to all of the target entries in a target row. If the target row attributes of a target print row do not contain a print command, then each target entry contained in that target print row must contain a print command. If a target print table contains more than one order spec, then each order spec must contain an integer value. If an integer value appears in one such order spec, the same value may not appear in another order spec in the same target print table. The combined print query syntax of this example permits a results table that contains only copies of elements from one source table. The target print query syntax, on the other hand, allows creation of a results table that contains constant values, expressions, and elements from more than one source table. In general, conceptually, an ECP is formed consisting of a copy of a source table for every example row linked to the target row. A combined print query can be expressed in target print query syntax. When multiple target print rows appear in a target print query, each print row is treated like a separate query just as in a combined print query. An ECP is formed for each query, and the results are UNIONed to form a final results table. Sort criteria applies to the final results table only. The maintenance queries are insert, delete, update, and create queries. Table 12 shows the insert query syntax. An insert query is an insert table, optionally preceded by a condition list, which may be preceded by a source table list. An insert table is a source table 2 having a table name in table name field 3, a column name in column field 5, an insert row attributes in row field 7, and an insert entry in data field 9. A plurality of column name and insert entry fields may appear. An insert command is designated by I. . The term insert row is used to collectively refer to a row containing insert row attributes and one or more insert entries. The number of insert entries in the insert row of an insert table is equal to the number of column names in that insert table. A given column name must not be contained more than once in an insert table. Herein, the table name of the insert table of an insert query must not be the table name of any source table of that insert query. This restriction is due to the SQL rule that the SQL query spec in an SQL row insertion must not refer to the table being augmented. An insert query causes one or more rows to be added to an existing table. A simple insert query is one in which all insert values are constant values. A query dependent insert query is one in which insert values contain elements from one or more source rows. Columns defined for a table that are not named in an insert row receive the null value for each new row inserted in the table. If more than one source row appears in a query dependent query, an ECP is formed that contains a copy of a source table for each source row. Table 13 provides the syntax of an update query. An update query is an update table, with an optional condition list, with an optional source table list. The update command is designated by U. . The term update row is used to refer collectively to the source entries or the column update entry. In an update table, the number of update entries in the update row must be equal to the number of column names. A column update row must contain at least one column update item. This rule resolves the syntactic ambiguity between source row and column update row. A column update entry that contains an update command may not refer to a source entry. This restriction is due to the SQL rule that the SQL query spec in a SQL row update may refer only to columns of the table being updated. An update query modifies existing elements in selected rows of a table. An update query is a simple query if the query does not contain source rows. An update query is a query dependent update if the query contains one or more source rows. The conditions for forming an ECP are the same as for insert queries. Table 14 provides the syntax of a delete query. A delete query is a delete table, with an optional condition list, with an optional source table list. A delete table is an example table 2 having a table name in field 3, a column name in one or more fields 5, and one or more rows including at least one row with a delete command in field 7 and a delete entry in one or more fields 9, and, optionally, a source entry in zero or more data fields 9. The delete command is designated by D. . A delete entry is a source item. The term delete row refers collectively to the delete command and delete entries of a row in a delete table. The number of delete entries in the delete row of a delete table must be equal to the number of column names in that delete table. The table name contained in the delete table of a delete query must not be contained in any source table of that delete query. This restriction is due to the SQL rule that the SQL query spec in an SQL row deletion must not refer to the table being augmented. A delete query deletes rows from a table. A delete query is a simple delete query if no source rows appear in the query. A delete query is a query dependent delete if one or more source rows appear in the query. If more than one delete row appear in a query, each delete row is treated like a separate delete query. An ECP is formed for each delete row consisting of a copy of the table referenced by the delete row and a copy of the table referenced by each source row linked to the delete row. Referring now to Figure 5, a description will be given of one possible structure for use in implementing the translation procedure of the invention. GFTSQL 70 is a buffer area in storage into which the SQL query is generated, forming the output of the procedure of Figures 7 12. Examples of generated SQL queries are set forth in the tables which follow , and will be described further hereafter. The collection of tables shown in Figure 5 is referred to as the DXTGFT tables 106. GFTTABLE 72 provides one entry for each skeleton, or example table 2 in a query Q. The contents 91 of GFTTABLE 72 are set forth in Table 15, and include GFTPTCOL GFTCOLCT 74, which provide a pointer 73 to GFTCOLMN 78, and GFTPTROW GFTROWCT 76, which provide a pointer 75 to GFTROW 82. GFTCOLMN 78 provides one entry for each column of an example table in a query Q. The content 89 of GFTCOLMN 78 is set forth in Table 16, and includes a GFTCNMPT field 80 providing a pointer 71 to GFTSQL 70. GFTROW 82 provides one entry for each row of an example table in a query Q. The contents 93 of GFTROW 82 are set forth in Table 17, and include a GFTPTRCL GFT FLDS field 84 providing a pointer 87 to GFTCOLCN 96, and a GFTBLEIX field 86 providing a pointer 77 to GFTTABLE 72. GFTCOLCN 96 includes an entry for each data field 9 in an example table in a query Q. The contents 99 of GFTCOLCN 96 are set forth in Table 18, and include GFTPTRCN GFTCONLN field 98 providing a pointer 105 to GFTCNTNT 104, and GFTROWIX 100 providing a pointer 81 to GFTROW 82. GFTCNTNT 104 provides a collection 101 of variable length entries, each entry including the contents of a condition in a data field 9 of an example table. GFTCDATA 88 provides one entry for each condition which appears in a condition box 6 or in a skeleton data field 9. The contents 95 of GFTCDATA 88 are set forth in Table 19 , and include GFTPTCDT GFTCDTLN 90 which provide a pointer 103 to GFTCONTB 102, GFTBINDR 92 which provides a pointer 83 to GFTROW 82, and GFTSIMCN 94 which provides a pointer 85 to GFTROW 82. GFTCONTB 102 provides a collection 97 of variable length entries. Each entry is a condition. The pointers, fields, and flags are initialized during an analysis phase and utilized and further modified during a synthesis phase, as will now be described in connection with Figure 6. In these DXEGFT 106 tables, by the use of the various indexes, extents, and flags, is logically formed the extended Cartesian product ECP previously described. During the analysis phase, GFTT 114 creates in GFTTABLE a row containing the table name 3 for each example table 2 that is, skeleton in the QBE query. Then, for each column in a table, GFTT 114 loads into GFTCOLMN at the location indexed by GFTPTCOL GFTCOLCT 74 the column names GFTCNAME and data peculiar to the column such as a P. flag GFTCLMP . Next, GFTT 114 initializes GFTROW 82, with an entry for each row of an example table. The entry contains data about the row, including a generated row name RN in field GFTROWNM. Herein, this row name is of the form 0000N, a unique identifier assigned to each N rows of the query. GFTT 114 then initializes an entry in GFTCOLCN 96, at the location indixed by GFTPTRCL GFT FLDS 84 for the data entries of a row, for each data field contained in the query. COLCN 96 contains information about the data field, and index the location in GFTCNTNT into which the actual data is stored for each data field of the query. GFTS 116 then creates GFTCDATA 88 and GFTCONTB 102 from information derived from GFTCOLCN 96. GFTCDATA contains information about conditions, and GFTCONTB 102 contains the conditions themselves, with each of tables GFTCDATA 88 and GFTCONTB 102 having an entry for each condition. To build CDATA 88 and CONTB 102, GFTS 116 locates an example element which appears alone in a data, or source, field, and marks it bound in COLCN 96 field GFTBOUND Table 18 . It then looks to see if the same example element in a COLCN 96 entry is bound anywhere else. If it is, a condition is implied, and a condition entry created in GFTCONTB 97. When all of the example elements in GFTCOLCN 96 have thus been processed to identify implied conditions, GFTS 116 then processes data field entries in GFTCOLCN 96 which are not bound example elements such entries are conditions, and the condition is fetched from the GFTCNTNT 101 location indexed by GFTPTRCN GFTCONLN 98 and placed into GFTCONTB 97. If an example element appears in a condition in GFTCNTNT 104, it is replaced by the name of a data field where it is bound when loaded into GFTCONTB 97. Finally, GFTS 116 examines the conditions appearing in condition boxes 6 in the query. These have not been previously loaded into any of the DXEGFT 106 tables. Conditions 8 are, therefore, loaded into GFTCONTB 97, with the names RN.CN of example elements appearing in the conditions obtained from field GFTCORNM of GFTCOLCN 96. During the analysis phase, the GFTTABLE 72 entry for the example table containing the P., I. U. or D. known as the target table, not to be confused with target table 4 of Figure 2 , is identified and pointed to by a pointer GFTGT not shown . During the synthesis phase, the DXEGFT 106 tables are examined and updated to synthesize a SQL, or linear language, query as will be described hereafter in greater detail. For example, during the synthesis of a P. query, DSQGFTP 120 is called to build the SQL equivalent. During GFTS 116 processing GFTCDTRF in GFTROW is set if any condition references the row, and GFTXTRMS in GFTROW 82 is set if any condition in the row has cross terms. Only GFTCDTRF was set if the condition is a simple condition. GFTP 120 builds the SQL buffer 70. GFTCOLMN 78 is examined to determine the rows that have P. Table names are obtained from GFTTABLE 72 as indexed by GFTGT. During a scan of GFTROW 82, when a P. flag is found indicating that there is at least one condition, GFTDATA 88 is searched, the conditions located in GFTCONTB 102, and added to the SQL buffer 70. Referring now to Figure 6, in connection with Figures 7 12 and Tables 20 48, a more detailed description will be given of the various programming modules structured to implement the procedure of the invention. Figure 7 describes the analysis phase executed under control of modules GFTM 110, GFTT 114, and GFTS 116. This phase is described in greater detail in Tables 20A and 20B, wherein is set forth the translate query procedure. Graphic Form Manager 110 initializes and controls the translation from a user composed QBE query to an equivalent SQL query. Initialization includes the determination of the number of tables, rows, and columns in the user query and the acquisition and subsequent release of the necessary space for the GFT common variables structure DXEGFT 106 comprising the tables and data areas set forth in Figure 5. GFTM 110 controls the translation by calling the parameter processor 112, as is represented by line 113, to assure the user has passed all required parameters in the query Q, and thereafter by calling the example table analyzer GFTT 114 followed by the source tables and conditions processor GFTS 116, as is illustrated by lines 115 and 117, respectively. Graphic form example table processor DSQGFTT 114 does the analysis of the example tables contained in the user query Q. It performs the method step 152 of Figure 7A, as is set forth in more detail in Table 20A at lines 304 306. GFTT 114 packs the tables DXEGFT 106 in Figure 5 with the qualifier, table, and column names and tests the name fields to assure only valid contents. The row fields of each row are analyzed to see that they contain only valid operators and flags are set in tables DXEGFT 106 to indicate the type of operators used. A row name RN is generated for each example table row that may be used as a correlation variable in the generated SQL query. Herein, row name and correlation identifier are synonyms. The data fields are analyzed to see that they contain valid operators, and flags are set in DSTGFT accordingly. Also, existing example elements and expressions are put into DXEGFT tables, literal constants not in quotes are stored in quotes, null and not null are translated to IS NULL and IS NOT NULL before storing in the tables 106, and example elements that appear alone in a data field 9 are identified. Overall query error checking is also done and the target table 2, 4 identified that example table that has I., U., P., or D. in the rows. Thus, as used here, target table is not just the target table 4 of a target query type. In this embodiment, while not essential to the invention, during a parameter substitution phase of GFTT 114 processing, parameters are substituted for each table field starting from the top left most field the table name field 3 and proceeding from the top to the bottom of each column from left to right. The GFTSQL buffer 70 may be used to contain the table after values have been substituted for parameter names. Later, GFTSQL 70 would be blanked and then used to contain the SQL translation from the query Q. GFTT 114 goes to tokenizer 134 for each serial token it reads in the scan of the query. Following the scan of the table and column names fields 3, 5, GFTT 114 scans the row field 7. A row field 7 may contain only a P., D., I., or U.. For each row, a correlation variable is created, using the row index for uniqueness. Each correlation variable is identified using an initial set of characters that may not be used as an identifier in the users query, such as the character set . A data field 9 may contain a P., U., AO., DO., sort priority, a condition, or an expression. Each row is tested for invalid conditions. A single row may not have a mix of P., I., U., or D. operators. Only P. s may appear in both a row field 7 and data fields 9. If a row contains one of these operators, the example table 2 containing the row as a target table. If a preceding table had a row with one of these operators, the query is invalid because only one table may contain a P., or an I., or a U., or a D. operator. If the row is a pure source row it appears in a named table that is not a define query and the row has none of the P., I., U., or D. operators , then it must not have ar ALL. or UNQ. specifier. The results of this analysis are stored in the flag bits of the DXEGFT 106 tables. Graphic form source and condition processing module DSQGFTS 116 processes source fields 9 and conditions 8 that are composed in condition boxes 6. It performs, among other things to be described hereafter, the method steps 154 160 of Figures 7A and 7B, as are more fully set forth in Tables 20A and 20B at lines 308 330. A source field is a data field 9 that contains either a condition or an example element EE . A source field may be any of the following 1 a data field in a pure source row, that is, a row in a named example table 2 that has no P., I., U., or D. 2 a data filed 9 that appears in a P. row of a named table 2 3 a data field 9 that appears in a D. row of a named table 2 4 a data field 9 that does not contain a U. but is in a row that contains a U. A source field cannot be any of the following 1 a data field 9 in an unnamed table 4 2 a data field 9 containing a U. 3 a data field 9 in a row containing an I.. If an example element EE appears alone in a source field, except for a P., AO., DO., or U. it is flagged as defining that data field and is said to be bound to that data field. An EE is said to be bound to the column and row that it defines an EE cannot be bound to a row in an output table, a row containing an I. or U. in the row field, a row used as a defining row in a table definition, or a column containing an I., U., or D.. An EE can be bound more than once. When such is the case, an equivalence condition is generated unless the EE is bound in two different rows that are not pure source rows. If the same EE name appears in more than one source field 9, an equivalence condition is implied, and a condition is generated and stored in the DXEGFT tables 106 for the implied condition. When a newly bound EE has the same name as a previously discovered bound EE, a condition is generated. The condition is generated on the first hit to ensure equivalence of EE s when there are more than two bound EE s with the same name. An implied operand condition may appear in a source field 9. If so, the column name 5 is the implied operand that precedes the condition. If no comparison operator precedes the implied operand condition, an equal is implied. The condition is completed and stored in the DXEGFT tables 106 using the correlation variable for the containing row and the column name 5 for the containing column. A condition is originated in the GFTCDATA table 88 for a condition being moved to the GFTCONTB table 102. The GFTCDATA table 88 entry contains data about the condition. The GFTCONTB table 102 will contain the condition itself. Entry to GFTCDATA is originated by the first reference in the condition to a particular row and column in a skeleton. The reference may be an EE for a generated condition, an implied reference from a skeleton condition, or an EE that appears in a box condition 8. Since this is the first reference by the condition to a skeleton, it is not known if the condition references more than one row. Initially, it is assumed that only one row is referenced. The correlation variable for the referenced row and column is moved to the GFTCONTB table 102. If the reference is an EE, the correlation variable replaces the EE. Later, if the correlation variable is not necessary, it is stripped from the condition. Conditions that appear in condition boxes 6 are processed, replacing example element EE references with a correlation variable and column name for the row and column referenced by the EE. Conditions are error tested to see that no conditions cross reference two rows containing P., U., or D. operators. Data about each condition, such as whether or not the condition references more than one row is determined and stored in DXEGFT tables 106. An EE in a condition is always a referencing EE. The same EE must be used in a data field to define the row and column to which it refers. If the EE is not so defined, the EE is flagged as not having been defined. A defined EE is marked as having been referenced. Retrieval Process module DSQGFTP 120 is a graphic form P. processing module which processes rows that contain a P. and are in a named table 2. It performs the procedure steps set forth in Figure 8, steps 170 180, as are more fully set forth in Tables 21 Translate Combined Print Query and 22 Translate Combined Print Row. Tables 23 29 illustrate various P. queries, and show the equivalent SQL queries generated by implementation of the procedure of the invention. If a P. row in a named table 2 is not linked to another row, then it is a simple retrieval query, as is shown in Table 23. If such a row is linked to one or more other rows, then the query is a query dependent retrieval query, as is shown in Tables 24 29. Two rows are said to be linked if any condition references both rows. Two rows linked to the same row are also linked to each other. The simple retrieval query of Table 23 selects data from each row of a table based solely upon data in the same row. A dependent retrieval query, such as in Tables 24, 25, and 27, selects data from each row of a table based upon data in other tables. A multi query is one that contains more than one P., as is shown in Tables 26 and 27, or more than one D. row. A single SQL SELECT statement is generated for all simple retrieval rows. The table name in the table name field 3 of the example table 2 is used in the SQL FROM clause. Conditions that reference a simple retrieval row are logically ANDed to each other. If there is more than one simple retrieval row, the conditions that reference one row are logically ORed to conditions that reference other simple retrieval rows. All such rows conditions appear in a generated SQL WHERE clause. A SQL SELECT statement is generated for each query depended row that appears in a retrieval request. A generated FROM clause will contain the table name 3 of the table 2 containing the P. row and the table name of the table containing a linked row for each such linked row. A correlation variable name will follow each table name in the FROM clause. The correlation variable name is the row name of the linked row that cause the table name to be moved to the FROM clause. A unique row name is generated by DSQGFTT 114 for each row, having the format 0001, 0002, ... , 000n, where n is the number of rows in the query. In the examples set forth in the Tables, the format is sometimes used, and sometimes the row names are given a letter designation, such as X, Y, which should be interpreted as representing the format. All conditions that reference the linked rows are logically ANDed into a WHERE clause in the generated SQL, which is stored in GFTSQL 70. A SQL UNION statement is generated between each generated SQL request. The UNION removes all duplicates. Therefore, if two or more P. rows are used, the language rule is that all duplicates will be removed. If ALL. is used and there is only one P. row, duplicates are retained and a subquery must be generated because an outer join might produce spurious duplicates. The column names 5 of the columns containing P. s are used in all generated SQL statements. SQL syntax requires that the same columns be selected for UNIONed SELECT statements. For this reason, all rows in an example table 2 that contain P. s must have them in the same data field. A row field 7 P. is the equivalent of a P. in each of the data fields 9 under named colums of the row. If the query contains one or more sort specifications, a SQL ORDER BY clause is generated. DSQGFTX 126 is the graphic explicit target processor. This module processes rows that contain a P. and are in an unnamed table 4. This is an output table retrieval query, also known as a target retrieval query. Such a table may be called a target table or an output table. GFTX 126 performs the procedure steps set forth in Figure 9, as are more fully explained in Tables 30 Translate Target Print Query and 31 Translate Target Print Row. Tables 32 35 set forth examples of P. queries appearing in unnamed tables 4. Table 32 illustrates that a target retrieval may be used to combine data and or to collect data from more than one table. A target row specified data to be inserted into a new row. Note that no conditions can be expressed in target rows. Table 33 illustrates a multi target retrieval, with a plurality of P. rows in the target table. Table 34 illustrates an outer join, where rows linked to a target row are joined in an outer query. Table 35 illustrates that a multi target retrieval translates to UNION. Thus, according to the procedure of the invention, as implemented in GFTX 126, a SQL SELECT clause is generated for each P. row that exists in a target table. The select list will contain constants or expressions that exist in the data fields 9 of the P. row for which a select statement is generated. Such a P. row references other rows in the request by referencing EE s defined in other rows. Such an EE reference is replaced by the correlation variable row name, RN, of the format 000n, of a row in which it is defined followed by the table name 3 of the table 2 containing the defining row. DSQGFTD module 118 is the graphic form D., or delete, processor. This module processes rows that contain a D. and are in a named table 2. If such a row is not linked to another row, then it is a simple delete row. If such a row is linked to a delete row, it is a dependent row. Two rows are said to be linked if any condition references both rows. Two rows linked to the same row are linked to each other. GFTD 118 executes the procedure set forth in Figure 10, as is more fully explained in Table 36 Translate Delete Query. Tables 37 39 provide examples of a simple delete, a dependent delete, and a multi delete, respectively. According to the GFTD 118 process, a SQL DELETE clause and a SQL FROM clause are generated first. The table name 3 of the example table 2 containing the D. s is used in the FROM clause. If there are any conditions, a SQL WHERE clause is generated. Conditions that reference only a simple D. row are logically ANDed in the WHERE clause. If there are query dependent rows, a SQL subquery is generated for each set of dependent rows linked to each other and to the D. row. Each such subquery is logically ANDed, using the SQL EXISTS comparison operator, to conditions or subqueries previously generated in the WHERE clause. A SQL SELECT is generated in each subquery, followed by a FROM clause. SELECT is a shorthand notation in SQL for selecting all of the fields of a row. A subquery FROM clause contains a table name 3 of the table 2 containing a linked row for each such linked row. A correlation variable name will follow each such table name in the FROM clause. The correlation variable name is the row name RN of the linked row. All conditions that reference the linked rows are logically ANDed into a WHERE clause in the generated subquery. If there is more than one D. row, the conditions that reference one D. row are logically ORed to conditions that reference a different D. row. Update processing DSQGFTU module 124 processes U. commands. GFTU 124 performs the procedure set forth in Figure 11, as is more fully described in Table 40 Translate Update Query. Table 41 provides an example of a simple update query U., and its equivalent SQL, and Table 42 illustrates a dependent update. GFTU 124 generates a single SQL UPDATE statement for an update query U. One and only one U. row may appear in a QBE query Q. Any column containing a U. may only reference other columns in the U. row. This is because of the SQL restriction that one can only update from the same row of the same table. A SQL SET statement is generated using either constant values or expressions that reference other columns in the same row. If a U. row is not linked to another row then it is a simple update query. If the U. row is linked to one or more , the query is a dependent update query. Two rows are said to be linked if any condition references both rows. Two rows linked to the same row are also linked to each other. Conditions that reference only the U. row are logically ANDed to each other and are generated into a SQL WHERE clause. If the query is a simple update, the SQL is complete. If the query is a query dependent update, then a SQL subquery is generated and ANDed to any conditions already in the WHERE clause using the SQL EXISTS connector to connect the subquery. The subquery FROM clause will contain the table name 3 of the table 2 containing a linked row for each such linked row. A correlation variable name will follow each such table name in the FROM clause. The correlation variable name is the row name of the linked row that cause the table name to be moved to the FROM clause. All conditions that reference the linked rows are logically ANDed into a WHERE clause in the generated SQL subquery. DSQGFTI module 122 processes insert queries I. GFTI 122 executes the procedure set forth in Figure 12, as is more fully described in Table 43 Translate Insert Query. Table 44 is an example of a simple insert query, and Table 45 of a dependent insert query, each setting forth QBE query format and the equivalent SQL query. In translating the queries of Tables 44 and 45, an insert I. row is considered a target row not to be confused with a row of a target table 4. GFTI 122 generates a single SQL INSERT statement for a QBE insert query I. If only constants appear in the insert row, then it is a simple insert query and only the INSERT statement is generated. If another row in the request is linked to an insert row a dependent insert row then a SELECT statement is generated after the SQL INSERT statement. One and only one such statement is generated. The SELECT list will contain constants or expressions that exist in the data fields 9 of the I. row as well as references to columns 5 in other tables 2 linked to the I. row. A SQL FROM statement is generated that contains a table name 3 of any table 2 containing a linked row for each such linked row. A correlation variable follows each such table name. The correlation variable is a unique name generated and stored in DXEGFT 106 by DSQGFTT 114 for each row in the query. All conditions that reference rows that are referenced in the I. row are logically ANDed in a SQL WHERE clause. Tokenizer interface module DSQGFTK 134 is a service module used by DSQGFTU 124, DSQGFTD 118, DSQGFTP 120, DSQGFTT 114, and DSQGFTS 116 to do token processing, as is indicated by lines 121, 123, 127, 131, and 135. Subquery generate module DSQGFTDP 136 is used when the query being processed is a dependent retrieval query, and is called by GFTX 126, GFTU 124, GFTI 122, GFTD 118, and GFTP 120, as is indicated by lines 141, 137, 133A, 125, and 131A, respectively. It serves two functions, selected by the setting of a flag FRWHR. If, when called, FRWHR is off, one or more rows are assumed to be specified as linked, and this module examines the conditions that exist in the query, flagging conditions that reference linked rows and flagging additional rows that are linked by conditions that reference already linked rows. A hit flag is turned on each time a condition is determined to be referenced or a row is determined to be linked. When called, and the FRWHR flag is on, this module generates the SQL FROM and WHERE clauses using the flagged rows and conditions. The FROM clause contains the name 3 of the table 2 that has a linked row followed by the correlation variable name for each linked row. The SQL WHERE clause contains all of the flagged conditions logically ANDed together. DSQGFTSE module 132 is called by GFTI 122 line 133 or GFTX 126 line 143 to generate a SQL SELECT list entry, using the token string pointed to upon entry to the module. The contents of a data field are moved into the SQL buffer 70. If the data field contains an example element, the example element is marked as referenced, and all rows in which the example element is defined are flagged as linked to the row that contains the data field. A trailing comma is moved into the SQL buffer 70 to separate the SELECT field from the next field to be moved into the buffer. The calling module removes the last comma. DSQGDTOD 130 generates a SQL ORDER BY clause, and is called by GFTP 120 line 129 or GFTX 126 line 139 . Table 46 sets forth the Construct Table Expression procedure that is called by Tables 22, 31, 40, and 43 to produce an SQL table expression. Table 47 sets forth the Construct Search Conditions procedure that is called by Tables 36, 40, 46, and by recursion, Table 47, to produce an SQL search condition SC3 . Table 48 illustrates the SQL equivalent of a query including a plurality of condition boxes, illustrating that conditions referencing the same row are logically ANDed in the equivalent SQL query, and that conditions referencing different rows P. or D. are ORed.