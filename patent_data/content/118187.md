# Menu based natural language understanding system.

## Claims
Computer mit einem menü gestützten Eingabesystem, um einer Bedienungsperson die Möglichkeit zu geben, eine Vielfachwort Eingabe durch Auswählen und anschließendes Eingeben von Wörtern oder Wortverbindungen von jedem von einer Vielzahl von aufeinanderfolgend angebotenen Menüs vorzunehmen, wobei die nach dem ersten Menü angebotenen Menüs durch den ausgewählten Eintrag oder Einträge bestimmt sind, der bzw. die von wenigstens einem früheren Menü vorgenommen wurde bzw. wurden, dadurch gekennzeichnet, daß der Computer folgendes enthält eine Einrichtung zum Speichern eines Lexikons, welches Wörter und oder Wortverbindungen, die für den Computer annehmbar sind, zusammen mit unterschiedlichen linguistischen Kategorien enthält z.B. Hauptwort, Wortverbindung, intransitives Verb, Adjektiv, Adverb, Bestimmungswort usw. , zu denen die Wörter und oder Wortverbindungen gehören, eine Einrichtung zum Speichern von Repräsentationen von Grammatikregeln eines untergeordneten Satzes einer natürlichen Sprache, wobei die Grammatikregeln die richtige Bildung und Strukturen in der natürlichen Sprache definieren, die aus den unterschiedlichen linguistischen Kategorien zusammengesetzt ist, und eine Parser Einrichtung, die auf die linguistische Kategorie oder Kategorien des oder jedes Wortes oder der oder jeder Wortverbindung anspricht, das bzw. die früher aus einem Menü ausgewählt und eingegeben worden ist und, wenn mehr als ein solches Wort oder eine solche Wortverbindung eingegeben worden ist, auf die Reihenfolge anspricht, in welcher die früher eingegebenen Wörter und oder Wortverbindungen eingegeben worden sind, um unter Verwendung der Grammatikregeln den Teilsatz zu parsen, der durch das Wort oder die Wörter und oder die Wortverbindung oder Wortverbindungen geformt ist, das bzw. die bis zu diesem Zeitpunkt ausgewählt und eingegeben worden ist bzw. worden sind, wobei die Parsing Operation jedesmal dann durchgeführt wird, wenn ein Wort oder eine Wortverbindung dem Teilsatz hinzugefügt wird und auf alle Weisen, die innerhalb der Grammatikregeln Gültigkeit haben, wobei die Parser Einrichtung so ausgebildet ist, um aus dem Parsing Vorgang eines Teilsatzes die linguistischen Kategorien aller Wörter oder Wortverbindungen abzuleiten, die dem Teilsatz im Rahmen der Grammatikregeln nachfolgen könnten, und um eine Auswahl zu treffen aus den gespeicherten Lexikonwörtern und oder Wortverbindungen, die zu der oder jeder linguistischen Kategorie gehören, welche durch die Parser Einrichtung abgeleitet worden ist, um das nächste Menü für eine Präsentation an die Bedienungsperson zu bilden, wobei die Mehrfachwort Eingabe, die durch die Bedienungsperson vorgenommen wurde, dazu gezwungen wird einen Satz zu formen, der die Grammatikregeln der natürlichen Sprache befriedigt, eine Einrichtung, um es der Bedienungsperson zu ermöglichen, eine Anzeige dahingehend einzugeben, daß die Wörter und oder Wortverbindungen, die eingegeben worden sind, einen vollständigen Satz bilden, und eine Einrichtung zum Übersetzen eines geparsten kompletten Satzes in einen Befehl, der von dem Computer ausführbar ist.

## Description
The present application relates to a computer input interface system. Providing access to computer systems with natural language is a very important step towards the construction of computer systems which are easy to use. However, although ease of use is currently a central goal of builders of computer systems, and although research into the construction of natural language interfaces has gone on for over fifteen years resulting in the construction of many prototype systems , natural language interfaces are not in common use today. The reason for this is that the natural language interfaces that have been constructed to date are quite difficult to use. This is because the current state of the art is such that all systems that are constructed have many limitations in coverage. That is, they can only understand a small subset of all possible natural language queries. The construction of a system which can understand all or even a substantial part of English, or any other natural language, is impossible today. This is likely to remain impossible for many years to come. Thus, in order for current natural language systems to prove useful, the user communities that utilize these systems will have to be able to adapt to system limitations. They will have to learn the limitations of the system and thereby restrict their input to only the subset that can be understood by the system. Unfortunately, all previous systems required users to type queries and thereby required the user to learn and adapt to the limitations of the natural language system, users have been unable to learn these limitations and have therefore been unable to successfully utilize language interfaces, high failure rates result, even for simple queries, in traditional systems. The primary application for natural language interfaces has been to natural language database query systems. For all natural language systems, the user has been required to type his question into the keyboard of a computer terminal. When the entire question had been input, the natural language interface began processing the input string. Processing resulted either in an answer to the user s query or a response that indicates that the query was not understood. Natural language interfaces that have been constructed employ a grammar which characterizes the class of acceptable input strings. The process of taking a sentence and determining whether it is grammatical, given a grammar, is called parsing. For example, if S is assigned to be the designated root symbol, the sentence The lazy cat ate greedily is ruled grammatical by the above grammar because the following tree is the result of parsing that sentence with the above grammar. A wide variety of grammar formalisms and parsing algorithms have been used. Most of these grammar formalisms can, however, be classified under the general heading of augmented context free grammars. This means the basic grammar rules are rules of a context free grammar but each context free rule has, associated with it, augmentations which give the grammar added power. These augmentations generally access attributes and sometimes values of the nodes of the context free rules. Context free grammars consist of an alphabet of symbols and a finite set of rules containing these symbols. Symbols are classified as being either terminal symbols or non terminal symbols. Terminal symbols are those symbols which appear in the lexicon or dictionary and thereby classify words according to categories. For example, terminal symbols commonly used in linguistic work are shown to the left of the colon in the example lexicon below. Nonterminal symbols are those symbols which are not terminal symbols or special symbols such as t , and MORE referred to below. Rules are of the form A B1 ... Bn where n 0 . The Bn s are either terminal or nonterminal symbols. A is a nonterminal symbol. As a simple example, consider the following set of rules S NP VP NP Determiner Adjective Noun VP VP Adverb VP Verb Given the lexicon shown earlier, the above grammar will determine whether sentences containing words in the lexicon are grammatical or ungrammatical, once a nonterminal symbol is assigned as the designated symbol for the grammar. The designated symbol indicates what a sentence is. A parser then accesses this grammar to produce a parse tree or parse trees for ambiguous input for the input string. This parse tree is then translated into an expression or set of expressions which represent the meaning of the input string and which are interpretable by the computer system for which the interface has been built. Natural language parsers are generally based on one of several parsing algorithms that have been employed for parsing context free grammars. First, a context free parse is performed. Then, the augmentation rules are used. In some systems, a partial context free parse is done, then whatever augmentations that are relevant to that portion of the parse are done. This procedure is then iterated until a complete parse is found. The only extensive evaluation of a natural language interface was performed for the PLANES system, a natural language database query system that accessed a military aircraft maintenance database in natural language. The results of this evaluation show quite clearly why natural language interfaces are not in common use today. About 1 3 of the queries input to the system by users were not understood, even though the tasks assigned to these users was to solve problems that had been specifically designed to correspond to relatively straight forward queries. Additionally, all of the queries that were input to the system were simple queries, containing about 6 or 7 words. Often this meant that many queries were needed in order to solve each problem assigned the user. More complex queries, which could have greatly reduced the amount of input required, were never attempted, even though the system had the ability to handle some of these. The reason that more complex queries were not attempted appears to be that the high failure rate for the simple queries gave the users little confidence that more complex ones would work. Thus, the users never attempted to formulate complex queries. Another reason that natural language interfaces are not in common use today is the large amount of time it has traditionally taken to construct a natural language interface. Current technology is such that each interface must be constructed on a case by case basis for each application. Efforts taking from 10 to 30 man years per application are not uncommon. Thus only applications that can justify such a large expenditure of manpower are candidates for possible applications. However, given the quality of the system results, the effort has not proved to be worthwhile. In the journal Computer , vol. 13 1980 , July issue, pages 35 48, there is an article by M.S. Fox et al, entitled The Automated Dictionary in which is describes a computer based device which, in addition to providing definitions of words entered by the user, also can perform searches for synonyms and antonyms, provide spelling and grammar assistance, and word games. The Proceedings of the International Zurich Seminar on Digital Communications Man machine interaction , 9 11 March 1982, Zurich, have the IEEE Catalogue No. 82 CH 1735 0 and on pages 153 158 of the Proceedings there is a paper entitled User friendly interaction with an integrated data base information retrieval system by H.G. Fischer and A. Zeidler. This paper describes the operation of a model of an information retrieval system in which access to the stored data is provided by means of a dialogue between the user and the system. The dialogue may use menus presented by the system to guide the user as to the input which the system requires to select the correct data for output. Other forms of dialogue mentioned are command language dialogue, natural language dialogue and a dialogue with masks. It is an object of the present invention to provide a system for interfacing with a computer, which does not require the user to know any computer language whatsoever. It is a further object of the present invention to provide a computer interface system which does not require large amounts of time for a user to become accustomed to using the interface systems. It is a further object of the present invention to provide a computer interface system which permits natural language inputs, but prevents the user from offering any ill formed inputs. It is a further object of the present invention to provide a computer interface system which makes system limitations obvious to a user, and all sentences that can be input understood by the computer. It is a further object of the present invention to provide a natural language understanding computer interface system which does not require a large and complex grammar to be specified. It is a further object of the present invention to provide a computer interface system, in which users can direct natural language queries to a relational database system without knowing how to type. The present invention solves the problem of providing USABLE natural language interfaces to computer systems. The present invention permits users who are unaware of system constraints and who are completely naive regarding computer operation to provide intelligible inputs to a computer system. Users need not learn or remember system limitations. It also enhances experienced users to interact in a clearer and simpler way. Additionally, both implementation time and processing time for natural language interfaces are decreased. According to the present invention there is provided a computer having a menu based input system to enable an operator to make a multi word input by selecting and then entering words or phrases from each of a plurality of sequentially presented menus, the menus presented after the first menu being determined by the selected entry or entries made from at least one previous menu, CHARACTERISED IN THAT the computer includes means for storing a lexicon containing words and or phrases acceptable to the computer together with the different linguistic categories for example, noun, phrase, intransitive verb, adjective, adverb, determiner, etc. to which the words and or phrases belong, means for storing representations of the rules of grammar of a sub set of a natural language, the grammar rules defining the proper formation of structures in the natural language composed of the different linguistic categories, and parsing means responsive to the linguistic category or categories of the or each word or phrase previously selected from a menu and entered and, when more than one such word or phrase has been entered, to the order in which the previously selected words and or phrases have been entered, to parse using the grammar rules the partial sentence formed by the word or words and or phrase or phrases selected and entered up to that time, the parsing being performed each time a word or phrase is added to the partial sentence and in all ways that are valid within the grammar rules, the parsing means being arranged to derive from the parsing of a partial sentence the linguistic categories of all words or phrases that could follow the partial sentence within the grammar rules, and to select from the stored lexicon words and or phrases belonging to the or each linguistic category derived by the parsing means to form the next menu for presentation to the operator, whereby the multi word input made by the operator is constrained to form a sentence satisfying the grammar rules of the natural language, means for enabling the operator to enter an indication that the words and or phrases that have been entered form a complete sentence, and means for translating a parsed complete sentence into a command executable by the computer. The mode of user interaction with the system is a primary novel aspect of this invention. In the present invention, the user is not required to type a well formulated input to the natural language understanding system, but rather is instead presented with a set of menus. The user successively chooses words or phrases or numbers, etc. from the menus to construct his input. At any point in the construction of a natural language input sequence by the user, only a subset of the set of menus is active. In the embodiments to be described these active menus have white backgrounds with black printing and inactive menus have dark backgrounds and white printing. The user is only allowed to choose from active or white menus. Items are selected from menus by using a mouse. The mouse is moved on the table and a pointer moves in response to this on the screen. When the pointer is over the desired item, that item can be selected by pushing a button on the mouse. Additionally, at various points in the construction of natural language input, only a subset of the items in the menu will be active. Those items in an active menu that are not active at a particular point will not appear in the menu at that point. Thus, at any particular point in the construction of natural language input, only those words or phrases that could legally come next will be available for the user to select. Thus, sentences which cannot be processed by the natural language system can never be input to the system, giving a 0 failure rate. The present invention will be described with primary reference to the presently preferred embodiment, wherein data base queries and updates are addressed to a relational data base. Thus, the present invention provides a method whereby natural language inputs can be limited to any restricted set of inputs, as long as the restricted set of inputs can be formally described by a context free grammar subject to minor limitations . The present invention is a pioneer invention in the area of computer systems capable of understanding natural language inputs, and accordingly has a tremendous scope of applications. A prototype of the system according to the preferred embodiment, is coded in LISP, and has been demonstrated on a LISP machine from LMI Incorporated. It employs the algorithm to be described and uses the Lisp Machine s software for creating the menus required and manipulating them as described above. The prototype implementation is a natural language database query system which accesses the parts suppliers database described in Date 1975 , p. 79. This database is stored in relational form in a relational database management system that was implemented on the Lisp Machine. The Lisp code Lisp machine for the parser and for the construction and manipulation of the menus is included in the Appendices below. The grammar, which characterizes the allowed queries to the database is also included. However, as will be obvious to those skilled in the art, the present invention can alternatively be realized using a wide variety of other physical systems, and the key ideas of the invention can also be translated into other programming languages than LISP. For example, another implementation of the present invention, which is presently under development, realizes the present invention on a Texas Instruments Professional Computer, instructed by source code which is written in C . The presently preferred method of user presentation is a CRT screen, on which the various menus are displayed, together with a mouse which moves a cursor on the screen. However, as is obvious to those skilled in the art, a wide variety of other actual I O devices can be used. For example, a flat graphics display e.g. electroluminescent could be used instead of a CRT, and user control of the cursor could be accomplished, e.g., by a joystick or by voice recognition. The natural language inputs are parsed using a parser which is generally similar to that disclosed in the 1981 dissertation of Ken Ross entitled Parsing English Phrase Structure . It should be noted that the particular parser used in the preferred embodiment is not necessary to the invention, other parsers can be used. Numerous parsers have been disclosed in the prior art. However, the presently preferred embodiment uses a parser which will be described in great detail, starting with the operation of the parser itself. A simplified version of the parser will first be described, and then the modifications which permit word at a time parsing and prediction according to the present invention will be described. As discussed above, the end result which the present invention achieves is to permit the user to input well understood sentences in a convenient language, which is preferably a subset of a natural language such as English . According to this invention, after the user has input each successive word of a sentence, the set of all possible next words which could form the continuation of a grammatical sentence is displayed to the user, so that he needs only to select one of the possible next words. More broadly, some of the possible inputs can be lumped together as a category, so that one of the displayed items would be, e.g., specific number , as will be discussed later. In general, this is accomplished by parsing partial inputs received from the user as they are received, so that the parser generates the set of possible functional descriptions which could be the next element in a legal input, and displays a set of words corresponding to these functional descriptions of possible next elements . Thus, the end result of the operation, after the user has input a complete sentence, is a parsed command which is in accordance with the predefined grammar, and therefore can be trivially translated into an executable instruction, as will be discussed below. The preferred parser can be specified in terms of nonstandard Turing machine instructions, which operate on the upper elements of an alpha stack and a beta stack in accordance with the current state of the upper elements of the two stacks. The topmost elements of these stacks are represented as an ordered pair such as XY, ZW , where X is a string variable corresponding to the upper elements of the alpha stack, Y is the next element of the alpha stack after X, Z represents the upper elements of the beta stack, and W is the next element of the beta stack. The parser rules can then be stated as 1. If one of the rules of the grammar which can be applied is of the form A V₁V₂... V The first association is always a direct translation from a specific word e.g. cat to its directly associated category noun . However, it should be preliminarily noted here that the categories used need not be as broad as familiar English language parts of speech, but, at least for database query applications, are preferably modified to include some semantic information. Thus, in the presently preferred embodiment, categories such as number noun phrase , worker noun phrase , operation noun phrase , job card noun phrase , and others are used. Intuitively, parser Rule 1 means that, where a rule of grammar might be applicable to a topmost element on stack alpha V₁ , that element is removed from the top of stack alpha, and stack beta is pushed down, successively, with the hypothetical parent node of V₁ together with V₁ associated below it , with a place holding symbol t , and with the remaining symbols which would be required by the possibly applicable rule of grammar V₂ . . .V Rule 1 If one of the available rules of grammar applied can be stated as A V₁ V₂... V 2. The second rule of the parser shows how the place holding symbol t is used to indicate that a perfected partial parse can be transferred from stack beta to stack alpha Rule 2 If the place holding symbol t is on top of the stack beta, and is immediately followed by a nonterminal symbol A, the place holding symbol t is deleted and the nonterminal symbol A is transferred from the top of stack beta over to stack alpha Intuitively, the allocation of functions between stacks alpha and beta is that stack alpha contains only parse trees or well formed subparts of parse trees, whereas stack beta is used to hold partially formed subparts of parse trees. 3. The third rule is used to determine when a necessary portion of the elements required to complete a parse has been found. The formal statement is Rule 3 The operation of the parser is initiated by loading the string of words to be parsed into stack alpha, followed by a numeral sign, and by loading the higher level symbol corresponding to the root node of the tree to be constructed, followed by a numeral sign, on stack beta. That is, where as is usual the parser is organizing strings of words into properly parsed sentences, the symbol which indicates a complete sentence in the grammar in rules such as S NP VP is loaded onto stack beta. Thus, the initial condition of the procedure can be represented as W₁ W₂ ... W A successful parse has been found when the final condition of the two stacks is S , S . In this case, the nodes below the S on the alpha stack provide the desired complete parse. If the root node i.e. the object of the parsing is not a sentence parse, but, for example, a noun phrase parse, then the condition indicating a successful parse would be correspondingly different, e.g. NP , NP . When no rule is applicable, the parsing path represents a bad parse, and the parser must retrace and follow a different parsing path. When more than one parser rule can be applied, and or when more than one rule of the grammar can be applied through parser rule 1, alternative parsing paths must be followed. Eventually, all of the alternative parsing paths will result in either successful of unsuccessful parses. The set of successful parses represents the output of the parser, after completion of the parsing process. This has substantial advantages in the present invention, as described below. An example of the operation of this simplified version of a parsing procedure will now be given. Suppose, for example, that the grammar to be applied is as follows In this example, the input string is xyz , which is to be parsed as an S . The foregoing carefully worked out example shows in detail the operation of a parser based on a context free grammar. It can easily be seen from this example that the formal manipulation rules as set forth above translate very simply into programmable operations. For example, the final status of stack beta, in the very last step of the preceding worked out example, could be easily represented in Lisp by a list formatted, e.g., as follows C t A A A x C y S . Note that the is not required in the Lisp implementation, since an empty list is easily tested for. The parser used in the present invention must be able to produce the set of items which can come next, in addition to creating a parse tree. In order to do this, the parser must be able to begin parsing as soon as the first word or phrase is input. Note that not only does the ability to parse a word or phrase at a time enable the parser to be modified so that it can predict what can come next as will be described below , but the ability to parse a word at a time also reduces parsing time. With traditional parsers where the entire sentence must be input before any parsing is done, no parsing can be done while the user formulates and inputs his query. However, if processing begins as soon as the first word or phrase is input, then the time it takes for a user to input his sentence can be put to productive use. This increases the perceived speed of any parser since work can proceed as the user is typing and composing his input. Thus, rather than there being a delay of several seconds or more after the sentence is input, the parse is completed almost instantaneously after input is terminated because most of the work was done before the input was completed. Although the parser set forth in the 1981 Ross publication does have the ability to begin parsing immediately upon input of the first word or phrase, an improved parser will now be described. In addition, for consistency with the published literature, the formalism of the parser will now trivially be altered from the 2 stack formalism used above to a 3 stack informal Turing machine formalism. The formalism differs from the previous formalism in that the incomplete parse trees which were formerly held below the place holding symbol t in stack beta will now be regarded as held separately in a gamma stack. Thus, the presently preferred embodiment uses the improved parser, as will now be set forth. The improved parser is termed the Given this interpretation of the Turing machine instruction, an example of the MSBT parser uses the following Turing machine instructions. To begin parsing a sentence, the input string to be parsed is put on stack alpha, the root symbol of the parse tree to be constructed is put on stack beta and ø is put on stack gamma. ø indicates that there are no contents to the stack. The rules of operation of the MSBT parser are as follows C1 is a Ci type variable as defined earlier. Rules 4 through 10 are added to permit use of grammar rules which contain parentheses and curly brackets. These elements are notationally convenient. Curly brackets indicate that exactly one of the elements within the brackets is to be inserted. Parentheses indicate that one or more or none of the elements in parentheses can be inserted. Ci type variables are added merely to keep track of nested brackets and parentheses although this function is easily accomplished in the Lisp implementation If no rules can be applied, the root symbol is on top of stack beta, the same root symbol is on top of stack alpha, and stack gamma is empty, then a valid parse has been found. If no rules can be applied and the above conditions are not true, then that path has ended without producing a valid parse of the input string. To obtain all valid parses of the input string, all paths must be pursued until they either produce a valid parse or end without producing a parse. The rules stated thus far define a recognition procedure. It will determine whether or not a given string can be parsed into a tree dominated by the specified root node. The following addition is required to enable the parser to produce the parse tree s for the input string. When 1 is applied, attach V1 beneath A. When 3 is applied, attach the B on alpha B as the right daughter of the top symbol on gamma. The parse tree will now appear on stack alpha, instead of just the root symbol. The MSBT parser is called selective because it employs a reachability matrix to eliminate bad parse paths before trying them. The reachability matrix indicates whether X can dominate A where A is on a left branch. The reachability conditions are satisfied if X can dominate A in this configuration. The reachability matrix is a Boolean matrix, which contains a logical value for each pair of nodes N,M in the grammar to indicate whether any legal parse tree could have node N as a The statement of the parser given above is neutral with respect to the control structure that the procedure employs. However, as noted, the parser set forth above must be modified for use in the present invention. The embodiments of the present invention use a breadth first control structure, which carries a parse as far as possible for each word of the input string. Thus, after inputting the nth word, a complete parse up to that word has been performed. The breadth first function will be described in slightly more detail. To do this, a depth first control structure must be described first. A depth first strategy pushes one state as far as it will go. To do this, apply one of the rules that are applicable, get a new state, and then apply one of the applicable rules to that new state. Continue this until either no rules apply or a parse is found. If no rules apply, it was a bad parse path. If a parse is found, it is one of possibly many parses for the sentence. In either case, continue on and pursue all other alternative paths by backtracking to the last choice point, picking another applicable rule, and continuing in the manner described earlier. By doing this until the parser has backed up through all possible choice points, all parses of the sentence will be found. To parse breadth first and introduce the ability to begin parsing given only one word of the input, the input word and the special symbol MORE are put on stack alpha and parsing is begun along a parse path using the parser rules set out above. When no further rules can be applied and MORE is on top of stack alpha, the contents of the beta and gamma stacks are saved and the parser backtracks to the last place the parse paths were split. Once all backtracking is completed, the next word, followed by MORE, is put on alpha and parsing begins again with a set of states, each containing the new input word on stack alpha and the or one of the saved beta gamma pairs, containing the contents of stacks beta and gamma. This procedure is then iterated until all words have been processed. It is straightforward to add a well formed state table to a parser modified in the way just described. Before beginning a parse with new input and a set of beta gamma pairs, the beta gammas can be compared and those with common subgoals can be merged. This has also been implemented in the parser used for the present invention, also known as the NLMenu System. The ability to predict the set of possible nth words of a sentence, given the first n 1 words of the sentence is the final modification necessary to enable this parser to be used for menu based natural language understanding. Fortunately, this feature can be added in a straightforward way. Given any beta gamma pair representing one of the parse paths active n 1 words of the sentence have been input, it is possible to determine the set of words that will allow that state to continue. To do this, look at the topmost symbol on stack beta of the beta gamma pair. This represents the most immediate goal of that parse state. To determine all the words that can come next, given that goal, the set of all nodes that are reachable from that node as a left daughter must be determined. Fortunately, this information is easily obtainable from the reachability matrix discussed earlier. Once the set of reachability nodes is determined, all that need be done is find the subset of these that can dominate the lexical material. Nodes that dominate others are above those others in a parse tree . Now, if this is done for all of the beta gamma pairs that resulted after parsing the first n 1 words and the union of the sets that result is taken, the resulting set is a list of all of the lexical categories that could come next. The list of next words is easily determined from this, e.g. through the lexicon. The most important feature of this procedure is that it can predict the set of possible terminal symbols that could be the nth input item, if it has completed parsing up to the n 1 th input item. It is this facility that enables the proper menus and proper items in those menus to be displayed so that the next input item can be chosen from a menu. To enable the parser to compute this information, for each potential mother node, the list of all possible daughters that could be left corners must be computed. This can be done either directly by accessing the phrase structure rules or indirectly by first computing the reachability matrix and then looking at all pairs X and Y such that X can dominate Y as a left daughter. The preferred embodiment uses the first method. For each mother node of the rules, a list is compiled of all nodes that mother node can dominate as a left corner. This is done by running through all rules and compiling a list. The process by which an unambiguous parse is translated into an executable machine command or an output according to some constrained system, for other applications will now be described. Associated with every word in the lexicon, there is a translation. This translation is a portion of the meaning of a sentence in which the word appears. In order to properly combine the translations of the words in a sentence together, there is a rule associated with each context free rule indicating the order in which the translations of the symbols on the right side of the arrow of a context free rule are to be combined. These rules are parenthesized lists of numbers where the number 1 refers to the first item after the arrow, the number 2 to the second, etc. For example, for the rule X A B C D, a possible rule indicating how to combine translations might be 3 1 2 4 . This rule means that the translation of A is taken as a function and applied to the translation of B as its argument. This resulting new translation is then taken as a function and applied to the translation of 4 as its argument. This resulting translation is then the argument to the translation of 3, which is a function. In general, the translation of the leftmost number applies to the translation of the number to its right as the argument. The result of this then is a function which applies to the translation of the item to its right as the argument. However, parentheses can override this as in the example above. Translations that are functions are of the form lambda x ... x ... . When this is applied to an item like c as the argument, c is plugged in for every occurrence of x after the lambda x and the result is just the expression with the lambda x stripped off of the front and the substitution made. For example, consider the sentence John hit Mary . A reasonable meaning might be hit John Mary If John is assigned to the lexical category NP and assigned the meaning John , and Mary is assigned to the lexical category NP and assigned the meaning Mary , and if hit is assigned to the lexical category V and assigned the meaning lambda x lambda y hit y x , the following rules will yield the desired meaning. S NP VP 2 1 VP V NP 1 2 To see why this is so, note that the meaning of the subtree VP would be the result of applying the meaning of the V to the meaning of the NP because of the rule 1 2 . The result of applying lambda x lambda y hit y x to Mary is lambda y hit y Mary . The meaning of the entire tree is the meaning of the VP, via the function lambda y hit y Mary , applied to the meaning of the NP, John. This function applied to this argument produces hit John Mary . The foregoing discussion shows how inputs are parsed in accordance with a predefined grammar and lexicon. It should be noted that the present invention is applicable to constraining natural language inputs in accordance with any system which can be formally represented by a comparable grammar and lexicon. That is, the present invention is not applicable solely to data base query systems, but can be used to generate well formed executable machine commands in any machine language using natural language input. Moreover, the present invention is not applicable only to semantic grammar defined systems, but can also be used with syntactics grammar defined systems. Moreover, the present invention is not applicable only to provide executable machine commands as outputs, but can be used to provide formally constrained outputs of any type whatsoever, from a natural language input, as long as a correspondence between the desired set of formally constrained outputs and a natural language subset which has a well formed grammar can be defined. The class of grammars currently used by the parser is context free grammars or CFG s . Any arbitrary context free grammar is permitted, with two minor exceptions, namely those grammars containing two classes of rules. These are rules of the form X null and sets of rules that generate cycles, for example, A B, B C, C D and D A. The problem with the first class of rules is that they make it very difficult for the predictive version of the algorithm to determine all and only those words that can come next in a sentence. The problem with the second class of rules is that they result in an infinite number of possible parse trees for a given sentence. The elimination of the second class of rules causes no difficulty and does not impair a grammar writer in any way. way. The elimination of the first class of rules causes a small inconvenience in that it prevents grammar writers from using the existence of null nodes in parse trees to account for certain unbounded dependencies like those found in questions like Who do you think I saw which are said in some linguistic theories to contain a null noun phrase after the word saw . However, alternative grammatical treatments, not requiring a null noun phrase, are also commonly used. Thus, the prohibition of such rules merely requires that these alternative grammatical treatments be used. Simpler and smaller grammars would result if the class of grammars allowed was extended to allow augmentations to be associated with the context free rules. The process of automatically generating a grammar for relational database applications would be greatly simplified by this extension in the class of grammars as well. This would result in increased efficiency throughout the system. A very general mechanism which will assign features to nodes of trees, based on other features of the nodes of that tree, was proposed in Knuth 1968 . Petrick 1973 adopts this mechanism, using somewhat different notation. The work of these researchers has been built upon in the design of the feature percolation mechanism described here. The mechanism is a constrained version of Knuth s. Knuth s mechanism enables feature names attributes in Knuth s terms and their values to be passed up and down a tree. Associated with each phrase structure rule, there is a set of rules which indicates how to pass the features around. These will be referred to as feature percolation rules. Knuth allows the value of a feature for any of the nodes expressed in a phrase structure rule to be set either to the value of a feature of any of the nodes of that phrase structure rule or to the value of a function applied to the values of features of any of the nodes expressed in that phrase structure rule. Once a feature value is assigned for a particular node, it does not change. For a structure like the one given below, the features of Nom1 can be determined by either other features of the node itself, the features of the nodes below it Nom2 and S , the features of the node above it NP or the features of its sister node det . In turn, the features of these nodes could be determined by their mother node, daughter nodes, or sister nodes. This in effect means that information from anywhere in the tree can be transmitted to the nodes which determine the features of Nom1. Utilizing Petrick s notation to illustrate this, the following feature percolation rules could be associated with the phrase structure rule given below. NP det Nom FEATURE1 0 F1 FEATURE2 0 ,FEATURE3 2 FEATURE3 2 F2 FEATURE4 1 FEATURE4 1 FEATURE4 2 The numbers 0,1, and 2 indicate the nodes represented in the phrase structure rule. 0 is the node to the left of the arrow, the NP node. 1 is the node immediately to the right of the arrow, the det node. 2 is the second node to the right of the arrow, the Nom node. In general, N will be the Nth node to the right of the arrow for N 0 . The first feature rule is interpreted as setting the value of FEATURE1 for the NP node to the result of applying the function F1 to the values of FEATURE2 of the NP node and FEATURE3 of the Nom node. Grammars constrain the value of a feature of a node to only be determined by values of features present on nodes that that node dominates nodes that dominate others are above those others in a tree . This means that the feature values of the nodes of any subtree can only depend on the feature values within that subtree. This is accomplished by restricting feature percolation rules so that features will only percolate up the tree, not down. Thus, only percolation rules in which a feature of the 0 node is being determined by a function applied to the values of the features of nodes 1 through N or by the value of a feature of one of nodes 1 through N where this feature percolation rule is associated with a phrase structure rule with N elements following the arrow are permitted. Augmentation rules of another class are used as well. These check the features of nodes and filter out ill formed structures based on the values of these features. These rules are called feature blocking rules and will be written as conditions on the values of the features of the nodes to the right of the arrow. Petrick s notation will be utilized for these rules as well, but here it should be interpreted somewhat differently. In general, blocking rules will state that the value of a feature of nodes 1 through N or the value of a function applied to the values of the features of nodes 1 through N must be equal to either the value of a feature of nodes 1 through N or the value of a function applied to the value of features of nodes 1 through N. These rules are not to be interpreted as assigning feature values. They are, instead, well formedness conditions which indicate whether a subtree is valid, according to the grammar. As an example of the feature mechanism in action, consider a hypothetical language with the following properties. The following phrase structure rules and feature rules characterize the above situation if the values of the feature PERSON range over the numbers 1,2, and 3 indicating first, second and third person , the values of NUMBER range over SING and PLUR, and the values of GENDER range over MASC and FEM. S NP VP PERSON 1 PERSON 2 NUMBER 1 NUMBER 2 none VP V NP none PERSON 0 PERSON 1 NUMBER 0 NUMBER 1 NP det Adj N NUMBER 1 NUMBER 3 GENDER 1 GENDER 3 GENDER 2 GENDER 3 NUMBER 0 NUMBER 3 PERSON 0 PERSON 3 An example of a tree which could be produced by these rules follows. To do predictive parsing with a grammar like the one described above, in addition to calculating the reachability matrix for the context free portions of the grammar rules, the percolation and blocking rules must be taken into account. There are several possible ways to do that. One possibility is to construct a much larger reachability matrix which contains feature information. This can be done by having one entry in the reachability matrix for every possible set of attributes and values that can be associated with each of the symbols. Thus, in the example above, rather than just having an entry indicating whether NP can dominate det, one is required for whether NP with PERSON 2, NUMBER SING and GENDER FEM can dominate det with PERSON 3, NUMBER SING and GENDER FEM, one is required for whether NP with PERSON 2, NUMBER SING and GENDER FEM can dominate det with PERSON 2, NUMBER SING and GENDER FEM, etc. This information can be calculated from the percolation and blocking rules associated with the context free rules that are traversed to determine if det can be reached from NP in the context free case. Except for very small grammars, this first solution would require a prohibitive amount of storage for the reachability matrix. A second solution is to do the same calculation at the point where the reachability information is required rather than prestoring the answer in the reachability matrix. This would take quite a bit of calculation at run time. A third choice, and the one seen as most promising, is to calculate the reachability matrix for the context free version of the rules and then to associate an equation or set of equations with each item in the matrix. In the example above, these equations can be calculated from the percolation and blocking rules associated with the context free rules that are traversed to determine if det can be reached from NP in the context free rules. When the values of the features of the two nodes for which reachability matrix information is required are known, they are plugged into this equation. The result of this equation will be either true or false indicating reachability. It is the ability to determine the set of terminals that can come next that differentiates the method of the invention from others and it is this ability that enables the proper items and menus to be displayed, thus ensuring a 0 failure rate for natural language input to the system. A sacrifice has been made to achieve this 0 failure rate, however. The preferred parser is only able to employ context free grammars and cannot use the augmented context free grammars that were discussed earlier. This is predicting the items that can come next. The present invention can be applied to augmented grammars as discussed above, but the capability is not included in the presently preferred embodiment. Thus, the less powerful context free grammars must be used. For a natural language system that needed to handle all paraphrases as traditional systems must , context free grammars are unacceptable. They do not have enough power to characterize a fragment of natural language that is very large. However, for a system that only needs to characterize one way of saying things, context free grammars are adequate. So, for our system, the sacrifice is not very great. Additionally, a parser that could process input using augmented context free grammars would necessarily be slower than the parser we employ. Thus, this sacrifice actually results in our system being able to parse faster. An example of the appearance of natural language menus to the software user will now be described, with reference to the accompanying drawings, of which Figure 1 shows a sample menu as initially presented to the user. Note that the arrow seen in the middle of the blank space at the bottom indicates the position of a cursor. This cursor is controlled by a mouse. A previous query can be seen above the blank space where the cursor is found. A new query will now be constructed. As seen in Figure 1, the only initially active window of the menus is the menu at the upper left, which permits find , delete , or insert as the initial word of a command. By moving the mouse to one of these words, for example find , and depressing a button on the mouse, one of the possible entries is selected. As shown in Figure 2, a different window or windows will now be highlighted, and the selection process continues as shown in the following figures. As selection proceeds, not only does the set of active windows change, but also the contents of each window changes. This is merely a graphic expedient to clearly present the set of active items to the user, and many other graphic presentation formats could be used instead. Note that in Figure 3 a parenthesis has been selected as one of the items. By this means, queries having greater logical structure can be unambiguously indicated by the operator. Note also that, as shown in Figure 3, only the attributes which could properly apply to a batter are highlighted and available for selection. The items displayed on the menu to the user, and which can be selected by the user, need not be only words or phrases. The user can be offered inputs such as words, phrases, numbers either unconstrained, or constrained , direct typed input e.g. to add a new entry to a database , direct graphics input e.g. by indicating a position on a map or other versatile possibilities. For example, the items displayed will typically include such entries as specific part no or specific supplier . When the user mouses one of these, he is then presented, in a little window, with a list of the names of specific suppliers, which is gathered from the database in real time. Thus, these non word items displayed on the menu add a great deal of versatility and user convenience to this system. These versatile displayed items are referred to generally as experts . The implementation of these experts, once their function has been defined, is quite simple. The critical part which should be noted is that, in translation from a partial parse to a list of displayed items, the lexicon must be modified to generate non word items at this point. Thus, for example, when the partial parse of the instant sentence entry requires that the next word entered be either an adjective or a noun, a pseudo lexical entry for the appropriate expert item must be added if the expert item is to be displayed, in addition to entries in the lexicon which might class Jones brothers as a noun supplier , an additional entry to class the expert item specific supplier as a noun supplier must also be added. Note that, once the expert item has been designated by the user, this designation can merely operate as a call to the expert subroutine. In addition, the use of experts does not affect the final translation of the natural language input into machine commands, since each expert concludes its function and retires immediately before the next word is selected. That is, where, e.g., a map is provided to the user, and the user moves the pointer to select a specific latitude and longitude on the map, the entry which will appear in the partial sentence being parsed would be something like whose latitude is 50 west and whose longitude is 40 north . In addition, where a very large number of items can be chosen from next, an expert can be used to display subcategories of the possible next items. Experts can also be used to remind the user of limitations in the database. For example, in a parts database, if every part has a weight less than five pounds, an expert for part weight can be used which constrains the numerical part weight input to be less than five pounds. The experts can also serve as a convenient aid for the user s memory, so that, for example, where the user of a baseball statistics database cannot remember how to spell Yastrzemski , he can simply call up an alphabetical list of players, or simply a list of players on the appropriate team. Thus, the expert in effect permits sub queries to the database to be transacted in the midst of formulating a larger query, and thus save much time. In addition, the expert can be used, e.g., to select another input channel. For example, if a peripheral system accessory included electronic output from a scale, an expert item in a parts data base could be indicated as specific weight read from scale 7 . In Figure 4, note that an expert item appears under attributes, that is the item specific batter teams . When this item is moused, a pop up expert window appears Fig. 5 , with a menu of specific batter team attributes which can be selected. The list of Houston and Texas is short, due to the limited extent of the actual database supported by the example shown in these pictures. Note also that the pop up window also contains two commands for abort and do it. When one of the entries in the pop up window is selected, the window function is not terminated until one of these commands is moused, or until some overriding command is moused. After the execute command in the pop up expert window has been announced, the pop up window goes away, and the expert performs its function. Note that the output of this expert that is introduced into the sentence being parsed, is merely the sentence element Houston . Fig. 6 That is, the expert has no further effect on the sentence structure being parsed after it has performed its function. In Figure 7, note that numerical comparison operators can be selected. The pop up number expert in Figure 8 permits a numerical input to be selected by mousing, rather than by keyboard input. Of course, the expert can also be adapted to permit direct keyboard input. Note that the expression input would not be well formed if a sufficient number of right parentheses had not been entered. The way in which the system enforces this constraint is that the execute option is not presented to the user until a well formed expression i.e. an expression which can be parsed as a complete sentence has been presented. Note that the command window in Figures 8 and 9 does not contain the execute command, unlike the command window in Figure 10. When a well formed sentence has been entered, the show query command and execute commands appear. The show query command can be used to immediately display the translation of the entered request. When the execute command is moused, the database system executes the access command. Note that, in the presently preferred embodiment, another pop up window is used to provide the user with options regarding the format of the output presentation. This process highlighted or active menu, user selection, parse, new highlighted menu is then continued, until the user indicates that he is finished with the sentence which he wishes to input. At this time, there is necessarily at least one valid parse tree in storage, as discussed above. However, it is possible that there may be more than one valid parse tree. Thus, for example, a sentence such as find suppliers who ship parts to suppliers who own airports and who are located in Boston is formally ambiguous, since it is not clear whether the limitation who are located in Boston refers to the first set of suppliers referred or to the second set of suppliers . To resolve such ambiguities, a final step in the presently preferred embodiment displays to the user, where more than one valid parse exists at the completion of a sentence input, alternative parsed versions of the input sentence, using indentations to show the relative referents of the dependent clauses. The user then selects between the alternative parses displayed, so that the end product is a single unambiguous parse of an input sentence. The save query command, if moused, will save the query just executed for future execution of modification. The retrieve query command can then be used, at a later point, to retrieve a previously stored query. The delete query DLT. Q s command deletes a previously stored query. The refreshed command is not currently used. The play query command is a demonstration command, which will play any saved query back in slow motion, as if it were being entered by the user. The rub out command deletes the last entry. This capability is due to the procedure of storing partially completed parses on the beta and gamma stacks. Thus, for example, if a user inputs a question with an error in it, the question can be edited using the rub out command. Another editing capability is the following certain items in the sentence constructed are mouse sensitive , i.e. when the mouse is moved near a mouse sensitive item the mouse sensitive item suddenly appears boxed. In the presently preferred embodiment, every word or piece of data which has been input with an expert remains mouse sensitive, and when such a mouse sensitive piece of data is later moused, the expert reappears, and that piece of data can then be edited. An example of the appearance of the user interface after an ambiguous query is shown in Figures 13 and 14. After the user attempts to execute the ambiguous query, a display indicating the possible interpretations of the alternative parses is shown to the user, and the user is required to select one of the parses. The parse thus selected is then executed. The very small grammars which can be used in practicing natural language interface systems according to the present invention have a further advantage that ambiguously parsed inputs can easily be identified, and the ambiguity can itself be explicated and resolved as just described. Furthermore, implementation time is greatly decreased because the grammars required can be much smaller, and it is the task of writing a thorough grammar for each application of a natural language understanding system that generally requires much time. Note that the reason larger grammars are not needed is because in traditional systems, every possible paraphrase of a sentence must be understood. The grammar required for this kind of linguistic coverage is quite large. In the present menu based system, only one paraphrase is needed. The user will be guided to this paraphrase by the menus. The presently preferred embodiment also includes a help function. The help function is activated by moving the cursor to a specific item on an active menu and depressing the help button, rather than the activate button, on the mouse. When this is done while the cursor is on an active item on the menu, the help expert pops up. Fig. 15 This expert gives the user a help message, together with a list of all things which could possibly come after the item on which the cursor is currently resting. If the help button is pressed while the cursor is on an inactive portion of the menu, the user is presented merely with the help message, since no item can follow an inactive item. The menu approach to natural language input has many advantages over the traditional typing approach. As mentioned earlier, every sentence that is input is understood. Thus, a 100 success rate for queries input is achieved. Furthermore, users do not need to know how to type. In addition to speeding up implementation time, parsing can be done faster as well. Two factors are responsible for this first, the word by word parse and second, the smaller grammars. Note that parse time is in general a function of grammar size so the smaller the grammar, the faster the parse will be performed. The fact that the menu based natural language understanding systems guide the user to the input he desires is also beneficial for two additional reasons. First, confused users who do not know how to formulate their input can receive help in composing it. They only need to recognize their input by looking at the menus. They need not formulate their input in a vacuum. Second, the limitations of the system s conceptual coverage will be apparent. The user will immediately know what the system knows about and what it does not know about. The application of menu based natural language for which an implementation has been done is a natural language database query system. There are many, many other potential applications. Below, we list a few that we have thought of. However, virtually any computer system for which a natural language interface would be appropriate would benefit from menu based natural language input. The present application has not attempted to delimit the full scope of possible applications, since the scope of applications of this pioneer invention is vast, and certainly includes a large number of subareas of application which have not been thought of. Thus, the scope of the present invention is subject to many modifications and variations, and is expressly not limited except as recited in the claims.