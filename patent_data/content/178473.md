# Method for broadcasting of information in a distributed computing network.

## Abstract
A method for reliably broadcasting information in a point to point network of processors in the presence of component faults provided that the network remains con nected using only an exchange of messages. The method possesses the properties 1 that every message broadcast by a fault free processor is accepted exactly once by all fault free processors within a bounded time, 2 that every message broadcast is either accepted by all fault free processors or none of them, and 3 that all messages accepted by fault free processors are accepted in the same order by all those processors. The method is based on a diffusion technique for broadcasting information and on special message validity test for tolerating any number of component failures up to network partitioning or successful forgery.

## Claims
1. A method for reliably broadcasting information in a point to point network of message exchanging processors, each processor having an amendable log, each processor having a clock approximately synchronized to the clocks of the other processors, the time taken for the transmission of messages between arbitrary points in the network and pro cessing thereof being bounded, comprising the steps of

## Description
This invention relates to the atomic broadcasting of information in a distributed computing network in the presence of faults, where the processors in the network exchange messages asynchronously. Methods for reliably broadcasting information in a distributed network of processors enable the fault free components of that system to have consistent views of the global system state in the presence of faulty components. A reliable broadcast method guarantees 1 that a message broadcast is either accepted by all fault free processors exactly once or by none of them atomicity , 2 that a message broadcast by a fault free sender is accepted correct ly by all fault free processors after a known time termina tion , and 3 that all messages accepted by fault free processors are accepted in the same order by all those processors order . Such a method is an essential part of many protocols for distributed systems, e.g. updating replicated data. Dolev and Strong, Authenticated Methods for Byzantine Agreement , SIAM Journal of Computing, Vol. 12, No. 4, November 1983, describe a method for achieving atomic broadcast assuming a logically fully connected network of processors. In order to tolerate F faults, their method runs for F 1 phases and exchanges N 1 Â² logical messages, where N is the number of processors in the network and the duration of a phase is the maximum network transmission delay. Reference should also be made to Dolev et al, A Method for Achieving Multiple Processor Agreement Optimized for No Faults , copending U. S. application S N 06 485,573, filed April 13, 1983. They describe a method for atomic broadcast in a reliable F 1 connected network of N processors with guaranteed early stopping in the absence of faults, and eventual stopping for F N 2 faults. It is the object of this invention to devise a method for reliably broadcasting information in a point to point network of processors in the presence of component faults, provided the network remains connected, using exchange of messages. Any such method must possess the following properties 1 every message broadcast by a fault free processor is accepted exactly once by all fault free pro cessors within a bounded time termination , 2 every message broadcast is either accepted by all fault free processors or none of them atomicity , and 3 all messages accepted by fault free processors are accepted in the same order by all those processors order . The objects are satisfied by a machine implementable method in which each processor maintains an amendable history of broadcast messages, and executes the following steps The following consequences result when the method of this invention is invoked Fundamentally, the method of this invention is based on a diffusion technique for broadcasting information, and on special message validity tests for tolerating any number of component failures up to network partitioning or successful forgery. This method is an advance over methods which simply adopt a diffusion technique for broadcasting in that prior art methods can only tolerate a small subset of the fault class that the method of this invention can tolerate. Further, the method of this invention is also more efficient than the one published by Dolev and Strong in that fewer messages and less time are needed to complete a broadcast. In order to facilitate appreciation of this invention, it is helpful to consider faults as being of several classes 1 a fault that causes a component not to respond to a given service request is called an omission fault 2 a fault that causes a component to respond to a given request either too early or too late is called a timing fault and 3 a fault that causes a component to deliver a different response than expected is called a Byzantine fault. That is, the set of faults covered by each class is a superset of the one covered by the preceding class, i.e. class 3 includes class 2, and class 2 includes class 1. In this invention, a method for reliably broadcasting information in a network of message exchanging processors with approximately synchronized clocks is presented which is tolerant of the most general fault class, i.e. the Byzan tine faults, and remains operable so long as the network is not disconnected by faulty components. Furthermore, it is demonstrated that if the faults to be tolerated are re stricted to the less general classes, i.e. timing or omission faults, then simpler methods can be derived from the general case. The invention will now be more closely described with reference to the accompanying drawings, where The method presented in this invention is operable in an environment in which In describing the method of this invention, the following notations will be used As a preliminary, the method of this invention is executable upon a computing system of the type including one or more CPU s, each having a main store, input output channel, control unit, direct access storage devices, local addressable clocks, and other I O devices coupled thereto. Such a system is described in Amdahl et al, USP 3,400,371, Data Processing System , issued September 3, 1968. The Amdahl system includes as a resource all of the facilities of either the computing system of an operating system running thereon which are required for the execution of a process including the method of this invention. Typical resources include a main store, I O devices, the CPU, data sets, interval timer, and control or processing programs. Furthermore, such systems are capable of multiprogramming . This pertains to the concurrent execution of two or more processes by a computing system, and can be managed on a computer running under an IBM System 370 operating system as described in IBM Publication GC28 6646, July 1973, and listed in IBM System 360 bibliography, GA22 6822. Networks of asynchronously operating CPU s are described in Fitz gerald, USP 3,940,743, Interconnecting Unit for In dependently Operable Data Processing Systems , issued February 24, 1976 and Antonaccio et al, USP 4,223,380, Distributed Multiprocessor Communication System , issued September 16, 1980. Referring now to Figures 1, 2, 3, and 4, there is exhibited a high level decision flow of the inventive method. Residing at each processor in the network are three tasks that are running concurrently the SEND task, the RECEIVE task, and the END task. The SEND task on each processor s is responsible for initiating the broadcast of messages. Upon receipt of a broadcast request, the SEND task executes the following steps of 1 generating an IDENTIFIER and a TIMESTAMP for that message, to produce the MESSAGE IDENTIFIER, TIMESTAMP, VALUE 2 storing the tuple MESSAGE,1 in its local HISTORY 3 setting its local interval timer to schedule the END task at TIMESTAMP BYZT to accept the MESSAGE VALUE and removing the MESSAGE from HISTORY observe that by the time TIME STAMP BYZT the message should have been received by all fault free processors and finally 4 signing the MESSAGE and broadcasting the result to all of its neighbors. The RECEIVE task on each processor is constantly waiting to receive messages. The main responsibility of the RECEIVE task is to filter out invalid messages, and store each valid message in local HISTORY the first time it is received along with a count of the number of different values that are received with that message IDENTIFIER. Observe that a fault free sender associates an IDENTIFIER with only one message value, whereas a faulty sender may associate several message values with the same IDENTIFIER. It is only the former kind that must be accepted, while the latter must be discarded. Specifically, upon receipt of a signed message X from the network by a processor s, the RECEIVE task on that processor verifies its authenticity and derives from it the original MESSAGE and a sequence of signatures of the pro cessors that have signed that message in the order that they have signed that message with sender s signature being the first signature . If the message is determined to be forged , it will be discarded. If the message is de termined to be authentic , then the RECEIVE task will execute the following tests 1 whether the MESSAGE has duplicate signatures 2 whether the MESSAGE has more signatures than F DIAM F , i.e. too many hops 3 whether the MESSAGE has arrived too early, possibly due to some clock failure and 4 whether the MESSAGE has arrived too late, possibly due to timing faults. If the answer to any one of the above tests is yes , then the received message is determined to be invalid and is, therefore, discarded. Once the message passes all of the above tests, then the RECEIVE task checks if it has already seen this message by consulting its HISTORY. That is, the HISTORY is searched for a tuple M,NUMBER OF VALUES such that M s IDENTIFIER is the same as MESSAGE s IDENTIFIER. The search results in one of the following outcomes The END task is responsible for accepting valid messages, and removing messages from the HISTORY so as to keep it from growing infinitely large. The END task is normally in a wait mode, and is scheduled by interval timer set by SEND or RECEIVE tasks . When it is scheduled at some time T, it processes in increasing order of MESSAGE IDENTIFIERs all MESSAGEs that were scheduled for processing at this time, i.e. all MESSAGEs with TIMESTAMP equal to T BYZT. For each such MESSAGE, the END task removes the tuple MESSAGE,NUMBER OF VALUES from the local HISTORY. If the NUMBER OF VALUES portion of the tuple is 1, then the MESSAGE VALUE is valid, i.e. only one authentic value has been received the END task will accept the MESSAGE. Alternatively, if NUMBER OF VALUES portion is 2 then the message is invalid, either the sender had been faulty or the authentication protocol has been compromised the message is not accepted. Observe that for any given MESSAGE, the END tasks of all fault free processors will process that message at the same clock time TIMESTAMP BYZT. Also observe that all valid MESSAGEs with the same TIMESTAMP are accepted in the same order by all fault free processors. The above three tasks, as shown in Figures 1, 2, 3, and 4, are expressible in a high level programming language. A representation of these tasks written in a high level specification language is appended to this specification respectively as counterpart Figures 5, 6, and 7. The inclusion of these executable tasks is set forth in order to illustrate, by way of example, the ease with which the method of this invention may be practiced by those possessing skill in this art. Other high level language representations such as PL I, PASCAL, or ADA might likewise with equal ease and facility have been drawn. This example exhibits the method s operation in the absence of faults in a network of three interconnected processors as depicted in Figure 8. All three processors are assumed to be fault free. This example exhibits the method s operation in the presence of faults in a network of three interconnected processors as depicted in Figure 8. In this example, processors S and P are assumed to be fault free, while processor Q is assumed to be experiencing timing faults. Suppose that at this time processor Q is affected by a timing fault and becomes inoperable for a long time. The final result in the above example is that the fault free processors S and P accept the MESSAGE VALUE exactly once. If the fault class to be handled by the method of this invention is restricted to timing faults, then a simpler method can be derived from the method of this invention. Specifically, considerable reduction in complexity results because 1 message authentication is no longer needed, typically a complex operation 2 there is no longer a need to protect against multi valued messages and 3 the tests for bad signatures are replaced by a much simpler test. The simpler method can be derived by making the following changes to the method of this invention For the above derived method, a representation of the SEND task, the RECEIVE task, and the END task written in a high level language is appended to this specification respectively as counterpart Figures 9, 10, and 11. If the fault class to be handled by the method of this invention is restricted to omission faults, then a yet simpler method can be derived from the method of this invention. Specifically, considerable reduction in com plexity results because 1 message authentication is no longer needed, typically a complex operation 2 there is no longer a need to protect against multi valued messages 3 tests for bad signatures are no longer needed and 4 tests for message timeliness are replaced by a single and very simple test. The simpler method can be derived by making the following changes to the method of this inven tion For the above derived method, a representation of the SEND task, the RECEIVE task, and the END task written in a high level language is appended to this specification respectively as counterpart Figures 12, 13, and 14. Furthermore, if the order of message acceptance by different processors is not important, then processor clocks need no longer be approximately synchronized. Removing this, yet another source of complexity, a simpler method can be derived from the method of this invention by making the following changes For the above derived method, a representation of the SEND task, the RECEIVE task, and the END task written in a high level language is appended to this specification respectively as counterpart Figures 15, 16, and 17. From the description of the Preferred Embodiment of this invention, those skilled in this art will recognize a variety of applications for the invention and appropriate modifications within the scope of the claims.